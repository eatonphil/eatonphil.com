<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="canonical" href="https://notes.eatonphil.com/compiler-basics-an-x86-upgrade.html">
    <title>Writing a lisp compiler from scratch in JavaScript: 6. an x86 upgrade | notes.eatonphil.com</title>
    <meta name="description" content="Writing a lisp compiler from scratch in JavaScript: 6. an x86 upgrade" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
  </head>
  <body>
    <header>
      <div class="lfw">
	<div class="container">
	  <div class="row">
	    <a href="https://eatonphil.com/hire-me.html">Hire me!</a>
	  </div>
	</div>
      </div>
      <div class="container">
        <div>
          <div class="row">
	    <div>
	      <a href="https://eatonphil.com" class="sm-link">
		Home
              </a>
	      <a href="/" class="sm-link">
		Notes
              </a>
	      <a href="/favorites.html" class="sm-link">
		Popular
              </a>
	      <a href="/rss.xml" class="sm-link">
		RSS
              </a>
	    </div>
	    	      
	    <div class="subscribe">                                     
	      <a href="https://notes.eatonphil.com/compiler-basics-an-x86-upgrade.html#subscribe">       
		Subscribe          
	      </a>
            </div>
	  </div>
	  <hr />
          <h2>December 8, 2019</h2>
          <h1>Writing a lisp compiler from scratch in JavaScript: 6. an x86 upgrade</h1>
          <div class="row" style="padding-bottom: 5px">
            <div class="tags"><a href="/tags/javascript.html" class="tag">javascript</a><a href="/tags/lisp.html" class="tag">lisp</a><a href="/tags/compilers.html" class="tag">compilers</a><a href="/tags/x86-amd64.html" class="tag">x86/amd64</a></div>
          </div>
	</div>
      </div>
    </header>
    <div class="container">
      <div class="col-6">
        <p class="note">
  Previously in compiler basics:
  <! forgive me, for I have sinned >
  <br />
  <a href="/compiler-basics-lisp-to-assembly.html">1. lisp to assembly</a>
  <br />
  <a href="/compiler-basics-functions.html">2. user-defined functions and variables</a>
  <br />
  <a href="/compiler-basics-llvm.html">3. LLVM</a>
  <br />
  <a href="/compiler-basics-llvm-conditionals.html">4. LLVM conditionals and compiling fibonacci</a>
  <br />
  <a href="/compiler-basics-llvm-system-calls.html">5. LLVM system calls</a>
</p><p>This post upgrades the ulisp x86 backend from using a limited set of
registers (with no spilling support) to solely using the stack to pass
values between expressions.</p>
<p>This is a slightly longer post since we've got a lot of catchup to do
to get to feature parity with the LLVM backend. Namely:</p>
<ul>
<li>"Infinite" locals, parameters</li>
<li>Function definitions</li>
<li>Variable references</li>
<li>Arithmetic and logical operations</li>
<li>If</li>
<li>Syscalls</li>
</ul>
<p>We'll tackle the first four points first and finish up with the last
two. This way we can support the same fibonacci program that prints
integers to stdout that we support in the LLVM backend.</p>
<p>As always the <a href="https://github.com/eatonphil/ulisp">code is available on
Github</a>.</p>
<p>But first a digression into how this is suddenly easy for us to do
with x86 and one-pass (sorta) code generation.</p>
<h3 id="stack-based-languages">Stack-based languages</h3><p>Stack-based languages have the extremely convenient attribute that
values are (by default) stored on the stack, which allows a code
generator targeting a stack-based language the option to omit handling
register allocation. And as it happens, x86 has enough support to make
it easy to treat as a stack machine.</p>
<p>As we build out the code generator for x86 as a stack machine we need
to keep two commitments in mind:</p>
<ul>
<li>Every expression must pop all arguments/operands</li>
<li>Every expression must store one result back on the stack</li>
</ul>
<p>In the future, we may replace the second commitment. But for now it is
more than enough.</p>
<h3 id="boilerplate">Boilerplate</h3><p>We'll start with the existing x86 backend code and strip all the
implementation code:</p>
<div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">cp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">require</span><span class="p">(</span><span class="s1">&#39;child_process&#39;</span><span class="p">);</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">fs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">os</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">require</span><span class="p">(</span><span class="s1">&#39;os&#39;</span><span class="p">);</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">GLOBAL_COUNTER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">SYSCALL_MAP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">darwin</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">exit</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;0x2000001&#39;</span><span class="p">,</span>
<span class="w">    </span><span class="nx">write</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;0x2000004&#39;</span><span class="p">,</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nx">linux</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">exit</span><span class="o">:</span><span class="w"> </span><span class="mf">60</span><span class="p">,</span>
<span class="w">    </span><span class="nx">write</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span>
<span class="w">  </span><span class="p">},</span>
<span class="p">}[</span><span class="nx">os</span><span class="p">.</span><span class="nx">platform</span><span class="p">()];</span>

<span class="kd">class</span><span class="w"> </span><span class="nx">Scope</span><span class="w"> </span><span class="p">{}</span>

<span class="kd">class</span><span class="w"> </span><span class="nx">Compiler</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kr">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">outBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">primitiveFunctions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">def</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileDefine</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
<span class="w">      </span><span class="nx">begin</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileBegin</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
<span class="w">      </span><span class="k">if</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileIf</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
<span class="w">      </span><span class="p">...</span><span class="k">this</span><span class="p">.</span><span class="nx">prepareArithmeticWrappers</span><span class="p">(),</span>
<span class="w">      </span><span class="p">...</span><span class="k">this</span><span class="p">.</span><span class="nx">prepareLogicalWrappers</span><span class="p">(),</span>
<span class="w">      </span><span class="p">...</span><span class="k">this</span><span class="p">.</span><span class="nx">prepareSyscallWrappers</span><span class="p">(),</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nx">prepareArithmeticWrappers</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="nx">prepareLogicalWrappers</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="nx">prepareSyscallWrappers</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="nx">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">depth</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="kc">undefined</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">args</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="kc">undefined</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s1">&#39;Invalid call to emit&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">indent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Array</span><span class="p">(</span><span class="nx">depth</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;  &#39;</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">outBuffer</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">indent</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">args</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="nx">compileIf</span><span class="p">([</span><span class="nx">test</span><span class="p">,</span><span class="w"> </span><span class="nx">then</span><span class="p">,</span><span class="w"> </span><span class="nx">els</span><span class="p">],</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="nx">compileBegin</span><span class="p">(</span><span class="nx">body</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="nx">topLevel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="nx">compileDefine</span><span class="p">([</span><span class="nx">name</span><span class="p">,</span><span class="w"> </span><span class="nx">params</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="nx">body</span><span class="p">],</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="nx">compileCall</span><span class="p">(</span><span class="nx">fun</span><span class="p">,</span><span class="w"> </span><span class="nx">args</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="nx">emitPrefix</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;.global _main\n&#39;</span><span class="p">);</span>

<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;.text\n&#39;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nx">emitPostfix</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;_main:&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;CALL main&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;MOV RDI, RAX&#39;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Set exit arg</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="sb">`MOV RAX, </span><span class="si">${</span><span class="nx">SYSCALL_MAP</span><span class="p">[</span><span class="s1">&#39;exit&#39;</span><span class="p">]</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;SYSCALL&#39;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nx">getOutput</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">outBuffer</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;\n&#39;</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Leave at most one empty line</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">output</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/\n\n\n+/g</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;\n\n&#39;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">compile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">function</span><span class="p">(</span><span class="nx">ast</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">Compiler</span><span class="p">();</span>
<span class="w">  </span><span class="nx">c</span><span class="p">.</span><span class="nx">emitPrefix</span><span class="p">();</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">Scope</span><span class="p">();</span>
<span class="w">  </span><span class="nx">c</span><span class="p">.</span><span class="nx">compileBegin</span><span class="p">(</span><span class="nx">ast</span><span class="p">,</span><span class="w"> </span><span class="nx">s</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
<span class="w">  </span><span class="nx">c</span><span class="p">.</span><span class="nx">emitPostfix</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">c</span><span class="p">.</span><span class="nx">getOutput</span><span class="p">();</span>
<span class="p">};</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">build</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">function</span><span class="p">(</span><span class="nx">buildDir</span><span class="p">,</span><span class="w"> </span><span class="nx">program</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">prog</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;prog&#39;</span><span class="p">;</span>
<span class="w">  </span><span class="nx">fs</span><span class="p">.</span><span class="nx">writeFileSync</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">buildDir</span><span class="si">}</span><span class="sb">/</span><span class="si">${</span><span class="nx">prog</span><span class="si">}</span><span class="sb">.s`</span><span class="p">,</span><span class="w"> </span><span class="nx">program</span><span class="p">);</span>
<span class="w">  </span><span class="nx">cp</span><span class="p">.</span><span class="nx">execSync</span><span class="p">(</span>
<span class="w">    </span><span class="sb">`gcc -mstackrealign -masm=intel -o </span><span class="si">${</span><span class="nx">buildDir</span><span class="si">}</span><span class="sb">/</span><span class="si">${</span><span class="nx">prog</span><span class="si">}</span><span class="sb"> </span><span class="si">${</span><span class="nx">buildDir</span><span class="si">}</span><span class="sb">/</span><span class="si">${</span><span class="nx">prog</span><span class="si">}</span><span class="sb">.s`</span><span class="p">,</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
<p>The prefix and postfix stays mostly the same as the original
implementation. But we'll assume a couple of new helpers to get us in
parity with the LLVM backend:</p>
<ul>
<li><code>compileDefine</code></li>
<li><code>compileBegin</code></li>
<li><code>compileIf</code></li>
<li><code>compileCall</code></li>
<li><code>prepareArithmeticWrappers</code></li>
<li><code>prepareLogicalWrappers</code></li>
<li><code>prepareSyscallWrappers</code></li>
</ul>
<p>The <code>prepareArithmeticWrappers</code> helper will define wrappers
for arithmetic instructions. The <code>prepareLogicalWrappers</code>
helper will define wrappers for logical instructions. And the
<code>prepareSyscallWrappers</code> helper will define a wrapper for
syscalls and generate builtins based on the SYSCALL_MAP entries.</p>
<h3 id="scope">Scope</h3><p>Similar to our LLVM backend's Context and Scope helpers we'll define
our own for the x86 backend. Since we're placing all locals on the
stack, the two most important things Scope will do for us are:</p>
<ul>
<li>Map identifiers to escaped strings</li>
<li>Store and increment the location of the local on the stack</li>
</ul>
<p>Here's what it will look like:</p>
<div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nx">Scope</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kr">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">localOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nx">assign</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">safe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">name</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;_&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">[</span><span class="nx">safe</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">localOffset</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">safe</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nx">symbol</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">localOffset</span><span class="o">++</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nx">lookup</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">safe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">name</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;_&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">[</span><span class="nx">safe</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="nx">safe</span><span class="p">,</span><span class="w"> </span><span class="nx">offset</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="p">[</span><span class="nx">safe</span><span class="p">]</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nx">copy</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">Scope</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// In the future we may need to store s.scopeOffset = this.scopeOffset + 1</span>
<span class="w">    </span><span class="c1">// so we can read outer-scoped values at runtime.</span>
<span class="w">    </span><span class="nx">s</span><span class="p">.</span><span class="nx">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="k">this</span><span class="p">.</span><span class="nx">map</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">s</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h3 id="compileexpression">compileExpression</h3><p>An expression will be one of:</p>
<ul>
<li>A function call (possibly a builtin like <code>def</code> or <code>+</code>)</li>
<li>A literal value (e.g. <code>29</code>)</li>
<li>A reference (e.g. <code>&c</code>)</li>
<li>An identifier (e.g. <code>my-var</code>)</li>
</ul>
<p>We'll handle compiling an expression in that order. If the AST
argument passed to <code>compileExpression</code> is an array, we will
call <code>compileCall</code> and return.</p>
<div class="highlight"><pre><span></span><span class="w">  </span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Is a nested function call, compile it</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">arg</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">compileCall</span><span class="p">(</span><span class="nx">arg</span><span class="p">[</span><span class="mf">0</span><span class="p">],</span><span class="w"> </span><span class="nx">arg</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mf">1</span><span class="p">),</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
<p>If the AST is a number, we will push the number onto the stack and
return.</p>
<div class="highlight"><pre><span></span><span class="w">  </span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Is a nested function call, compile it</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">arg</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">compileCall</span><span class="p">(</span><span class="nx">arg</span><span class="p">[</span><span class="mf">0</span><span class="p">],</span><span class="w"> </span><span class="nx">arg</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mf">1</span><span class="p">),</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="nx">arg</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`PUSH </span><span class="si">${</span><span class="nx">arg</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
<p>If the AST is a string that starts with <code>&</code> we will look up
the location of the identifier after the <code>&</code>, push its
<em>location</em> onto the stack and return.</p>
<p>We count on the Scope storing its offset from the "frame pointer",
which we will later set up to be stored in <code>RBP</code>.</p>
<p>Locals will be stored after the frame pointer and parameters will be
stored before it. So we'll need to add or subtract from the frame
pointer depending on if we need a positive or negative offset from it.</p>
<div class="highlight"><pre><span></span><span class="w">  </span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Is a nested function call, compile it</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">arg</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">compileCall</span><span class="p">(</span><span class="nx">arg</span><span class="p">[</span><span class="mf">0</span><span class="p">],</span><span class="w"> </span><span class="nx">arg</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mf">1</span><span class="p">),</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="nx">arg</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`PUSH </span><span class="si">${</span><span class="nx">arg</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">arg</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">offset</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">scope</span><span class="p">.</span><span class="nx">lookup</span><span class="p">(</span><span class="nx">arg</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mf">1</span><span class="p">));</span>
<span class="w">      </span><span class="c1">// Copy the frame pointer so we can return an offset from it</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`MOV RAX, RBP`</span><span class="p">);</span>
<span class="w">      </span><span class="kd">const</span><span class="w"> </span><span class="nx">operation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">offset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s1">&#39;ADD&#39;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;SUB&#39;</span><span class="p">;</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">operation</span><span class="si">}</span><span class="sb"> RAX, </span><span class="si">${</span><span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">offset</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">8</span><span class="p">)</span><span class="si">}</span><span class="sb"> # </span><span class="si">${</span><span class="nx">arg</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`PUSH RAX`</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
<p>Finally, we'll look up the identifier and copy the value (in its
offset on the stack) to the top of the stack.</p>
<div class="highlight"><pre><span></span><span class="w">  </span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Is a nested function call, compile it</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">arg</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">compileCall</span><span class="p">(</span><span class="nx">arg</span><span class="p">[</span><span class="mf">0</span><span class="p">],</span><span class="w"> </span><span class="nx">arg</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mf">1</span><span class="p">),</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="nx">arg</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`PUSH </span><span class="si">${</span><span class="nx">arg</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">arg</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">offset</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">scope</span><span class="p">.</span><span class="nx">lookup</span><span class="p">(</span><span class="nx">arg</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mf">1</span><span class="p">));</span>
<span class="w">      </span><span class="c1">// Copy the frame pointer so we can return an offset from it</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`MOV RAX, RBP`</span><span class="p">);</span>
<span class="w">      </span><span class="kd">const</span><span class="w"> </span><span class="nx">operation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">offset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s1">&#39;ADD&#39;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;SUB&#39;</span><span class="p">;</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">operation</span><span class="si">}</span><span class="sb"> RAX, </span><span class="si">${</span><span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">offset</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">8</span><span class="p">)</span><span class="si">}</span><span class="sb"> # </span><span class="si">${</span><span class="nx">arg</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`PUSH RAX`</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Variable lookup</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">offset</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">scope</span><span class="p">.</span><span class="nx">lookup</span><span class="p">(</span><span class="nx">arg</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">offset</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kd">const</span><span class="w"> </span><span class="nx">operation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">offset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s1">&#39;+&#39;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;-&#39;</span><span class="p">;</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span>
<span class="w">        </span><span class="nx">depth</span><span class="p">,</span>
<span class="w">        </span><span class="sb">`PUSH [RBP </span><span class="si">${</span><span class="nx">operation</span><span class="si">}</span><span class="sb"> </span><span class="si">${</span><span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">offset</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">8</span><span class="p">)</span><span class="si">}</span><span class="sb">] # </span><span class="si">${</span><span class="nx">arg</span><span class="si">}</span><span class="sb">`</span><span class="p">,</span>
<span class="w">      </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span>
<span class="w">        </span><span class="s1">&#39;Attempt to reference undefined variable or unsupported literal: &#39;</span><span class="w"> </span><span class="o">+</span>
<span class="w">          </span><span class="nx">arg</span><span class="p">,</span>
<span class="w">      </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
<p>And that's it for handling expression! Let's add
<code>compileCall</code> support now that we referenced it.</p>
<h3 id="compilecall">compileCall</h3><p>A call will first check if the call is a builtin. If so, it will
immediately pass control to the builtin.</p>
<div class="highlight"><pre><span></span><span class="w">  </span><span class="nx">compileCall</span><span class="p">(</span><span class="nx">fun</span><span class="p">,</span><span class="w"> </span><span class="nx">args</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">primitiveFunctions</span><span class="p">[</span><span class="nx">fun</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">primitiveFunctions</span><span class="p">[</span><span class="nx">fun</span><span class="p">](</span><span class="nx">args</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
<p>Otherwise it will compile every argument to the call (which will leave
all the resulting values on the stack.)</p>
<div class="highlight"><pre><span></span><span class="w">  </span><span class="nx">compileCall</span><span class="p">(</span><span class="nx">fun</span><span class="p">,</span><span class="w"> </span><span class="nx">args</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">primitiveFunctions</span><span class="p">[</span><span class="nx">fun</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">primitiveFunctions</span><span class="p">[</span><span class="nx">fun</span><span class="p">](</span><span class="nx">args</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Compile registers and store on the stack</span>
<span class="w">    </span><span class="nx">args</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">arg</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
<p>Then we will check that function is defined and call it.</p>
<div class="highlight"><pre><span></span><span class="w">  </span><span class="nx">compileCall</span><span class="p">(</span><span class="nx">fun</span><span class="p">,</span><span class="w"> </span><span class="nx">args</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">primitiveFunctions</span><span class="p">[</span><span class="nx">fun</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">primitiveFunctions</span><span class="p">[</span><span class="nx">fun</span><span class="p">](</span><span class="nx">args</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Compile registers and store on the stack</span>
<span class="w">    </span><span class="nx">args</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">arg</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">));</span>

<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">fn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">scope</span><span class="p">.</span><span class="nx">lookup</span><span class="p">(</span><span class="nx">fun</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`CALL </span><span class="si">${</span><span class="nx">fn</span><span class="p">.</span><span class="nx">name</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s1">&#39;Attempt to call undefined function: &#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">fun</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
<p>Then we'll reset the stack pointer (to maintain our commitment) based
on the number of arguments and push <code>RAX</code> (where the return
result of the function call will be stored) onto the stack. We'll make
two minor optimizations for when there is exactly zero or one argument
to the function.</p>
<div class="highlight"><pre><span></span><span class="w">  </span><span class="nx">compileCall</span><span class="p">(</span><span class="nx">fun</span><span class="p">,</span><span class="w"> </span><span class="nx">args</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">primitiveFunctions</span><span class="p">[</span><span class="nx">fun</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">primitiveFunctions</span><span class="p">[</span><span class="nx">fun</span><span class="p">](</span><span class="nx">args</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Compile registers and store on the stack</span>
<span class="w">    </span><span class="nx">args</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">arg</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">));</span>

<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">fn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">scope</span><span class="p">.</span><span class="nx">lookup</span><span class="p">(</span><span class="nx">fun</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`CALL </span><span class="si">${</span><span class="nx">fn</span><span class="p">.</span><span class="nx">name</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s1">&#39;Attempt to call undefined function: &#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">fun</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Drop the args</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`ADD RSP, </span><span class="si">${</span><span class="nx">args</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">8</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`MOV [RSP], RAX\n`</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;PUSH RAX\n&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
<p>When there is only one argument, we can just set the top value on the
stack to be the return result of the call rather than resetting the
stack pointer just to push onto it.</p>
<p>And that's it for <code>compileCall</code>! Now that we've got a feel
for expressions and function calls, let's add some simple arithmetic
operations.</p>
<h3 id="preparearithmeticwrappers">prepareArithmeticWrappers</h3><p>There are two major kind of arithmetic instructions we'll wrap for now:</p>
<ul>
<li>"General" instructions that operate on two arguments, putting the
return result in the first argument</li>
<li>"RAX" instructions that operate on RAX and the first argument,
putting the return result in <code>RAX</code> and possibly
<code>RDX</code></li>
</ul>
<h4 id="preparegeneral">prepareGeneral</h4><p>This helper will compile its two arguments and pop the second argument
into <code>RAX</code>. This is because x86 instructions typically
require one argument to be a register if one argument is allowed to be
a memory address.</p>
<p>We'll use the stack address as the first argument so 1) that
non-commutative operations are correct and 2) the result is stored
right back onto the stack in the right location.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">prepareGeneral</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">instruction</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">depth</span><span class="o">++</span><span class="p">;</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`# </span><span class="si">${</span><span class="nx">instruction</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Compile first argument</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">arg</span><span class="p">[</span><span class="mf">0</span><span class="p">],</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Compile second argument</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">arg</span><span class="p">[</span><span class="mf">1</span><span class="p">],</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`POP RAX`</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Compile operation</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">instruction</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()</span><span class="si">}</span><span class="sb"> [RSP], RAX`</span><span class="p">);</span>

<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`# End </span><span class="si">${</span><span class="nx">instruction</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="w">    </span><span class="p">};</span>
</pre></div>
<h4 id="preparerax">prepareRax</h4><p>This helper will similarly compile its two arguments and pop
the second argument into <code>RAX</code>. But the RAX-implicit
instructions require the argument to be stored in a register
so we'll use the <code>XCHG</code> instruction to swap <code>RAX</code>
with the value on the top of the stack (the first argument).</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">prepareRax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">instruction</span><span class="p">,</span><span class="w"> </span><span class="nx">outRegister</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;RAX&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">(</span>
<span class="w">      </span><span class="nx">arg</span><span class="p">,</span>
<span class="w">      </span><span class="nx">scope</span><span class="p">,</span>
<span class="w">      </span><span class="nx">depth</span><span class="p">,</span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">depth</span><span class="o">++</span><span class="p">;</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`# </span><span class="si">${</span><span class="nx">instruction</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Compile first argument, store in RAX</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">arg</span><span class="p">[</span><span class="mf">0</span><span class="p">],</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Compile second argument</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">arg</span><span class="p">[</span><span class="mf">1</span><span class="p">],</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// POP second argument and swap with first</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`POP RAX`</span><span class="p">);</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`XCHG [RSP], RAX`</span><span class="p">);</span>
</pre></div>
<p>This may seem roundabout but remember that we <em>must</em> pop all
arguments to the instruction to maintain our commitment.</p>
<p>Next we'll zero out the <code>RDX</code> register if the operation is
<code>DIV</code>, perform the operation, and store the result on the
top of the stack.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">prepareRax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">instruction</span><span class="p">,</span><span class="w"> </span><span class="nx">outRegister</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;RAX&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">(</span>
<span class="w">      </span><span class="nx">arg</span><span class="p">,</span>
<span class="w">      </span><span class="nx">scope</span><span class="p">,</span>
<span class="w">      </span><span class="nx">depth</span><span class="p">,</span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">depth</span><span class="o">++</span><span class="p">;</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`# </span><span class="si">${</span><span class="nx">instruction</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Compile first argument, store in RAX</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">arg</span><span class="p">[</span><span class="mf">0</span><span class="p">],</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Compile second argument</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">arg</span><span class="p">[</span><span class="mf">1</span><span class="p">],</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// POP second argument and swap with first</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`POP RAX`</span><span class="p">);</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`XCHG [RSP], RAX`</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Reset RDX for DIV</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">instruction</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;DIV&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`XOR RDX, RDX`</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="c1">// Compiler operation</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">instruction</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()</span><span class="si">}</span><span class="sb"> QWORD PTR [RSP]`</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Swap the top of the stack</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`MOV [RSP], </span><span class="si">${</span><span class="nx">outRegister</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="w">    </span><span class="p">};</span>
</pre></div>
<p>We parameterize the out register because the <code>%</code> wrapper
will call <code>DIV</code> but need <code>RDX</code> rather than
<code>RAX</code> after the operation.</p>
<h4 id="preparearithmeticwrappers">prepareArithmeticWrappers</h4><p>Putting everything together we get:</p>
<div class="highlight"><pre><span></span><span class="w">  </span><span class="nx">prepareArithmeticWrappers</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// General operatations</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">prepareGeneral</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">instruction</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">depth</span><span class="o">++</span><span class="p">;</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`# </span><span class="si">${</span><span class="nx">instruction</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Compile first argument</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">arg</span><span class="p">[</span><span class="mf">0</span><span class="p">],</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Compile second argument</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">arg</span><span class="p">[</span><span class="mf">1</span><span class="p">],</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`POP RAX`</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Compile operation</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">instruction</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()</span><span class="si">}</span><span class="sb"> [RSP], RAX`</span><span class="p">);</span>

<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`# End </span><span class="si">${</span><span class="nx">instruction</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// Operations that use RAX implicitly</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">prepareRax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">instruction</span><span class="p">,</span><span class="w"> </span><span class="nx">outRegister</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;RAX&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">(</span>
<span class="w">      </span><span class="nx">arg</span><span class="p">,</span>
<span class="w">      </span><span class="nx">scope</span><span class="p">,</span>
<span class="w">      </span><span class="nx">depth</span><span class="p">,</span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">depth</span><span class="o">++</span><span class="p">;</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`# </span><span class="si">${</span><span class="nx">instruction</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Compile first argument, store in RAX</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">arg</span><span class="p">[</span><span class="mf">0</span><span class="p">],</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Compile second argument</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">arg</span><span class="p">[</span><span class="mf">1</span><span class="p">],</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// POP second argument and swap with first</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`POP RAX`</span><span class="p">);</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`XCHG [RSP], RAX`</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Reset RDX for DIV</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">instruction</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;DIV&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`XOR RDX, RDX`</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="c1">// Compiler operation</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">instruction</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()</span><span class="si">}</span><span class="sb"> QWORD PTR [RSP]`</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Swap the top of the stack</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`MOV [RSP], </span><span class="si">${</span><span class="nx">outRegister</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="s1">&#39;+&#39;</span><span class="o">:</span><span class="w"> </span><span class="nx">prepareGeneral</span><span class="p">(</span><span class="s1">&#39;add&#39;</span><span class="p">),</span>
<span class="w">      </span><span class="s1">&#39;-&#39;</span><span class="o">:</span><span class="w"> </span><span class="nx">prepareGeneral</span><span class="p">(</span><span class="s1">&#39;sub&#39;</span><span class="p">),</span>
<span class="w">      </span><span class="s1">&#39;&amp;&#39;</span><span class="o">:</span><span class="w"> </span><span class="nx">prepareGeneral</span><span class="p">(</span><span class="s1">&#39;and&#39;</span><span class="p">),</span>
<span class="w">      </span><span class="s1">&#39;|&#39;</span><span class="o">:</span><span class="w"> </span><span class="nx">prepareGeneral</span><span class="p">(</span><span class="s1">&#39;or&#39;</span><span class="p">),</span>
<span class="w">      </span><span class="s1">&#39;=&#39;</span><span class="o">:</span><span class="w"> </span><span class="nx">prepareGeneral</span><span class="p">(</span><span class="s1">&#39;mov&#39;</span><span class="p">),</span>
<span class="w">      </span><span class="s1">&#39;*&#39;</span><span class="o">:</span><span class="w"> </span><span class="nx">prepareRax</span><span class="p">(</span><span class="s1">&#39;mul&#39;</span><span class="p">),</span>
<span class="w">      </span><span class="s1">&#39;/&#39;</span><span class="o">:</span><span class="w"> </span><span class="nx">prepareRax</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">),</span>
<span class="w">      </span><span class="s1">&#39;%&#39;</span><span class="o">:</span><span class="w"> </span><span class="nx">prepareRax</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;RDX&#39;</span><span class="p">),</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
<p>Next we'll tackle <code>compileBegin</code> and
<code>compileDefine</code>.</p>
<h3 id="compilebegin">compileBegin</h3><p>A begin form is an expression made up of a series of expressions where
all expression values are thrown away and the last expression value is
the result of the begin form.</p>
<p>To compile this form we will compile each expression passed in and pop
from the stack to throw its value away. If the expression is the
last in the list we will not pop since it is the result of the begin
form.</p>
<p>We will add one exception to this popping logic: if the begin is
called from the top-level we will omit the popping.</p>
<div class="highlight"><pre><span></span><span class="w">  </span><span class="nx">compileBegin</span><span class="p">(</span><span class="nx">body</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="nx">topLevel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">body</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">expression</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">expression</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">topLevel</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">body</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`POP RAX # Ignore non-final expression`</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
<p>That's it for <code>compileBegin</code>!</p>
<h3 id="compiledefine">compileDefine</h3><p>The prelude for a function definition will add its name to scope, push
the current frame pointer (<code>RBP</code>) onto the stack and store
the current stack pointer (<code>RSP</code>) as the new frame pointer
(<code>RBP</code>).</p>
<p>Remember that we use the frame pointer as a point of reference when
setting and getting local and parameter values. It works out entirely
by convention.</p>
<div class="highlight"><pre><span></span><span class="w">  </span><span class="nx">compileDefine</span><span class="p">([</span><span class="nx">name</span><span class="p">,</span><span class="w"> </span><span class="nx">params</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="nx">body</span><span class="p">],</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Add this function to outer scope</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">safe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">scope</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Copy outer scope so parameter mappings aren&#39;t exposed in outer scope.</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">childScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">scope</span><span class="p">.</span><span class="nx">copy</span><span class="p">();</span>

<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">safe</span><span class="si">}</span><span class="sb">:`</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`PUSH RBP`</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`MOV RBP, RSP\n`</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
<p>Next we copy the parameters into local scope at their negative (from
the frame pointer) location. In the future we may decide to actually
copy in the parameter <em>values</em> into the local stack but for now
there's no benefit.</p>
<div class="highlight"><pre><span></span><span class="w">  </span><span class="nx">compileDefine</span><span class="p">([</span><span class="nx">name</span><span class="p">,</span><span class="w"> </span><span class="nx">params</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="nx">body</span><span class="p">],</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Add this function to outer scope</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">safe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">scope</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Copy outer scope so parameter mappings aren&#39;t exposed in outer scope.</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">childScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">scope</span><span class="p">.</span><span class="nx">copy</span><span class="p">();</span>

<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">safe</span><span class="si">}</span><span class="sb">:`</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`PUSH RBP`</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`MOV RBP, RSP\n`</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Copy params into local scope</span>
<span class="w">    </span><span class="nx">params</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">param</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">childScope</span><span class="p">.</span><span class="nx">map</span><span class="p">[</span><span class="nx">param</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nx">params</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">2</span><span class="p">);</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
<p>Next we'll compile the body of the function within a
<code>begin</code> block.</p>
<div class="highlight"><pre><span></span><span class="w">  </span><span class="nx">compileDefine</span><span class="p">([</span><span class="nx">name</span><span class="p">,</span><span class="w"> </span><span class="nx">params</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="nx">body</span><span class="p">],</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Add this function to outer scope</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">safe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">scope</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Copy outer scope so parameter mappings aren&#39;t exposed in outer scope.</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">childScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">scope</span><span class="p">.</span><span class="nx">copy</span><span class="p">();</span>

<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">safe</span><span class="si">}</span><span class="sb">:`</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`PUSH RBP`</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`MOV RBP, RSP\n`</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Copy params into local scope</span>
<span class="w">    </span><span class="nx">params</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">param</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">childScope</span><span class="p">.</span><span class="nx">map</span><span class="p">[</span><span class="nx">param</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nx">params</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">2</span><span class="p">);</span>
<span class="w">    </span><span class="p">});</span>

<span class="w">    </span><span class="c1">// Pass childScope in for reference when body is compiled.</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">compileBegin</span><span class="p">(</span><span class="nx">body</span><span class="p">,</span><span class="w"> </span><span class="nx">childScope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
<p>Then in the postlude we'll pop the stack (for the return result of the
begin form), save it in RAX, pop the previous frame pointer back to
restore the calling frame, and return.</p>
<div class="highlight"><pre><span></span><span class="w">  </span><span class="n">compileDefine</span><span class="p">(</span><span class="o">[</span><span class="n">name, params, ...body</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="k">scope</span><span class="p">,</span><span class="w"> </span><span class="k">depth</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="k">Add</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">outer</span><span class="w"> </span><span class="k">scope</span>
<span class="w">    </span><span class="n">const</span><span class="w"> </span><span class="n">safe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">scope</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">Copy</span><span class="w"> </span><span class="k">outer</span><span class="w"> </span><span class="k">scope</span><span class="w"> </span><span class="n">so</span><span class="w"> </span><span class="k">parameter</span><span class="w"> </span><span class="n">mappings</span><span class="w"> </span><span class="n">aren</span><span class="s1">&#39;t exposed in outer scope.</span>
<span class="s1">    const childScope = scope.copy();</span>

<span class="s1">    this.emit(0, `${safe}:`);</span>
<span class="s1">    this.emit(depth, `PUSH RBP`);</span>
<span class="s1">    this.emit(depth, `MOV RBP, RSP\n`);</span>

<span class="s1">    // Copy params into local scope</span>
<span class="s1">    params.forEach((param, i) =&gt; {</span>
<span class="s1">      childScope.map[param] = -1 * (params.length - i - 1 + 2);</span>
<span class="s1">    });</span>

<span class="s1">    // Pass childScope in for reference when body is compiled.</span>
<span class="s1">    this.compileBegin(body, childScope, depth);</span>

<span class="s1">    // Save the return value</span>
<span class="s1">    this.emit(0, &#39;&#39;);</span>
<span class="s1">    this.emit(depth, `POP RAX`);</span>
<span class="s1">    this.emit(depth, `POP RBP\n`);</span>

<span class="s1">    this.emit(depth, &#39;</span><span class="n">RET</span><span class="err">\</span><span class="n">n</span><span class="err">&#39;</span><span class="p">);</span>
<span class="w">  </span><span class="err">}</span>
</pre></div>
<p>And now we're ready to compile a simple program!</p>
<h3 id="our-first-program">Our first program</h3><p>Here's a simple one we can support:</p>
<div class="highlight"><pre><span></span><span class="nv">$</span><span class="w"> </span><span class="nv">cat</span><span class="w"> </span><span class="nv">tests/meaning-of-life.lisp</span>
<span class="p">(</span><span class="nv">def</span><span class="w"> </span><span class="nv">main</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">17</span><span class="p">)))</span>
</pre></div>
<p>We'll compile this program without the ulisp kernel (which contains a
lisp library we cannot currently compile):</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>node<span class="w"> </span>src/ulisp.js<span class="w"> </span>tests/meaning-of-life.lisp<span class="w"> </span>--no-kernel<span class="w"> </span>--backend<span class="w"> </span>x86
$<span class="w"> </span>./build/prog
$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="nv">$?</span>
<span class="m">42</span>
</pre></div>
<p>Not bad. Let's finish up with support for
<code>prepareLogicalWrappers</code>,
<code>prepareSyscallWrappers</code>, and <code>compileIf</code>.</p>
<h3 id="preparelogicalwrappers">prepareLogicalWrappers</h3><p>Storing logical results as values is a bit of pain. Most of the
internet wants you to use branching. And a better compiler may
optimize an idiom like <code>(if (> 5 2) ...)</code> into a single
branch.</p>
<p>But we're going to resort to an instruction I just learned about
called <code>CMOV</code>. This allows us to conditionally assign a
value based on flags, similar to how you can conditionally branch.</p>
<p>Otherwise we'll follow a pattern similar to our arithmetic
wrappers. At the end of the procedure we will have a 0 or a 1 on the
top of the stack.</p>
<div class="highlight"><pre><span></span><span class="w">  </span><span class="nx">prepareLogicalWrappers</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">prepareComparison</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">operator</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">[</span><span class="nx">operator</span><span class="p">]</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="nx">depth</span><span class="o">++</span><span class="p">;</span>
<span class="w">          </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`# </span><span class="si">${</span><span class="nx">operator</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>

<span class="w">          </span><span class="c1">// Compile first argument, store in RAX</span>
<span class="w">          </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">arg</span><span class="p">[</span><span class="mf">0</span><span class="p">],</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>

<span class="w">          </span><span class="c1">// Compile second argument</span>
<span class="w">          </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">arg</span><span class="p">[</span><span class="mf">1</span><span class="p">],</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>
<span class="w">          </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`POP RAX`</span><span class="p">);</span>

<span class="w">          </span><span class="c1">// Compile operation</span>
<span class="w">          </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`CMP [RSP], RAX`</span><span class="p">);</span>

<span class="w">          </span><span class="c1">// Reset RAX to serve as CMOV* dest, MOV to keep flags (vs. XOR)</span>
<span class="w">          </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`MOV RAX, 0`</span><span class="p">);</span>

<span class="w">          </span><span class="c1">// Conditional set [RSP]</span>
<span class="w">          </span><span class="kd">const</span><span class="w"> </span><span class="nx">operation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s1">&#39;&gt;&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;CMOVA&#39;</span><span class="p">,</span>
<span class="w">            </span><span class="s1">&#39;&gt;=&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;CMOVAE&#39;</span><span class="p">,</span>
<span class="w">            </span><span class="s1">&#39;&lt;&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;CMOVB&#39;</span><span class="p">,</span>
<span class="w">            </span><span class="s1">&#39;&lt;=&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;CMOVBE&#39;</span><span class="p">,</span>
<span class="w">            </span><span class="s1">&#39;==&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;CMOVE&#39;</span><span class="p">,</span>
<span class="w">            </span><span class="s1">&#39;!=&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;CMOVNE&#39;</span><span class="p">,</span>
<span class="w">          </span><span class="p">}[</span><span class="nx">operator</span><span class="p">];</span>
<span class="w">          </span><span class="c1">// CMOV* requires the source to be memory or register</span>
<span class="w">          </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`MOV DWORD PTR [RSP], 1`</span><span class="p">);</span>
<span class="w">          </span><span class="c1">// CMOV* requires the dest to be a register</span>
<span class="w">          </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">operation</span><span class="si">}</span><span class="sb"> RAX, [RSP]`</span><span class="p">);</span>
<span class="w">          </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`MOV [RSP], RAX`</span><span class="p">);</span>
<span class="w">          </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`# End </span><span class="si">${</span><span class="nx">operator</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">      </span><span class="p">};</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="p">...</span><span class="nx">prepareComparison</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">),</span>
<span class="w">      </span><span class="p">...</span><span class="nx">prepareComparison</span><span class="p">(</span><span class="s1">&#39;&gt;=&#39;</span><span class="p">),</span>
<span class="w">      </span><span class="p">...</span><span class="nx">prepareComparison</span><span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">),</span>
<span class="w">      </span><span class="p">...</span><span class="nx">prepareComparison</span><span class="p">(</span><span class="s1">&#39;&lt;=&#39;</span><span class="p">),</span>
<span class="w">      </span><span class="p">...</span><span class="nx">prepareComparison</span><span class="p">(</span><span class="s1">&#39;==&#39;</span><span class="p">),</span>
<span class="w">      </span><span class="p">...</span><span class="nx">prepareComparison</span><span class="p">(</span><span class="s1">&#39;!=&#39;</span><span class="p">),</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
<h3 id="preparesyscallwrappers">prepareSyscallWrappers</h3><p>This helper is similar to <code>compileCall</code> except for that it
needs to follow the SYS V ABI and use the <code>SYSCALL</code>
instruction rather than <code>CALL</code>.</p>
<div class="highlight"><pre><span></span><span class="w">  </span><span class="nx">prepareSyscallWrappers</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">registers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s1">&#39;RDI&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;RSI&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;RDX&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;R10&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;R8&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;R9&#39;</span><span class="p">];</span>

<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">wrappers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="w">    </span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">SYSCALL_MAP</span><span class="p">).</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">obj</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">wrappers</span><span class="p">[</span><span class="sb">`syscall/</span><span class="si">${</span><span class="nx">key</span><span class="si">}</span><span class="sb">`</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">args</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nx">registers</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="sb">`Too many arguments to syscall/</span><span class="si">${</span><span class="nx">key</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Compile first</span>
<span class="w">        </span><span class="nx">args</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">arg</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">));</span>

<span class="w">        </span><span class="c1">// Then pop to avoid possible register contention</span>
<span class="w">        </span><span class="nx">args</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span>
<span class="w">          </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`POP </span><span class="si">${</span><span class="nx">registers</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span><span class="p">]</span><span class="si">}</span><span class="sb">`</span><span class="p">),</span>
<span class="w">        </span><span class="p">);</span>

<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`MOV RAX, </span><span class="si">${</span><span class="nx">SYSCALL_MAP</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;SYSCALL&#39;</span><span class="p">);</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`PUSH RAX`</span><span class="p">);</span>
<span class="w">      </span><span class="p">};</span>
<span class="w">    </span><span class="p">});</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">wrappers</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
<p>And we're set! Last up is <code>compileIf</code>.</p>
<h3 id="compileif">compileIf</h3><p>This is standard code generation but gets a little tricky due to our
stack commitments. Testing must pop the test value off the stack. And
then/else blocks must <em>push</em> a value onto the stack (even if
there is no else block).</p>
<p>Here is an example we'd like to support:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nv">foo</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nv">do-bar</span><span class="p">))</span>
</pre></div>
<p>We compile the test and branch:</p>
<div class="highlight"><pre><span></span><span class="w">  </span><span class="nx">compileIf</span><span class="p">([</span><span class="nx">test</span><span class="p">,</span><span class="w"> </span><span class="nx">then</span><span class="p">,</span><span class="w"> </span><span class="nx">els</span><span class="p">],</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;# If&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Compile test</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">test</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">branch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sb">`else_branch`</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">GLOBAL_COUNTER</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Must pop/use up argument in test</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`POP RAX`</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`TEST RAX, RAX`</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`JZ .</span><span class="si">${</span><span class="nx">branch</span><span class="si">}</span><span class="sb">\n`</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
<p>Then we compile the then block and jump to after the else block
afterward.</p>
<div class="highlight"><pre><span></span><span class="w">  </span><span class="nx">compileIf</span><span class="p">([</span><span class="nx">test</span><span class="p">,</span><span class="w"> </span><span class="nx">then</span><span class="p">,</span><span class="w"> </span><span class="nx">els</span><span class="p">],</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;# If&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Compile test</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">test</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">branch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sb">`else_branch`</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">GLOBAL_COUNTER</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Must pop/use up argument in test</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`POP RAX`</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`TEST RAX, RAX`</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`JZ .</span><span class="si">${</span><span class="nx">branch</span><span class="si">}</span><span class="sb">\n`</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Compile then section</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`# If then`</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">then</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`JMP .after_</span><span class="si">${</span><span class="nx">branch</span><span class="si">}</span><span class="sb">\n`</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
<p>Finally we compile the else block if it exists, and otherwise we push
a zero onto the stack (possibly to represent null).</p>
<div class="highlight"><pre><span></span><span class="w">  </span><span class="nx">compileIf</span><span class="p">([</span><span class="nx">test</span><span class="p">,</span><span class="w"> </span><span class="nx">then</span><span class="p">,</span><span class="w"> </span><span class="nx">els</span><span class="p">],</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;# If&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Compile test</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">test</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">branch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sb">`else_branch`</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">GLOBAL_COUNTER</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Must pop/use up argument in test</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`POP RAX`</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`TEST RAX, RAX`</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`JZ .</span><span class="si">${</span><span class="nx">branch</span><span class="si">}</span><span class="sb">\n`</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Compile then section</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`# If then`</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">then</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`JMP .after_</span><span class="si">${</span><span class="nx">branch</span><span class="si">}</span><span class="sb">\n`</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Compile else section</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="sb">`# If else`</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="sb">`.</span><span class="si">${</span><span class="nx">branch</span><span class="si">}</span><span class="sb">:`</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">els</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">els</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">,</span><span class="w"> </span><span class="nx">depth</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;PUSH 0 # Null else branch&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="sb">`.after_</span><span class="si">${</span><span class="nx">branch</span><span class="si">}</span><span class="sb">:`</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;# End if&#39;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
<p>And we're ready for an interesting program! Let's print (to stdout)
the result of <code>fib(20)</code>.</p>
<h3 id="fibonacci">Fibonacci</h3><div class="highlight"><pre><span></span><span class="nv">$</span><span class="w"> </span><span class="nv">cat</span><span class="w"> </span><span class="o">.</span><span class="nv">/tests/fib.lisp</span>
<span class="p">(</span><span class="nv">def</span><span class="w"> </span><span class="nv">fib</span><span class="w"> </span><span class="p">(</span><span class="nv">n</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">       </span><span class="nv">n</span>
<span class="w">       </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nv">fib</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nv">fib</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="mi">2</span><span class="p">)))))</span>

<span class="p">(</span><span class="nv">def</span><span class="w"> </span><span class="nv">main</span><span class="w"> </span><span class="p">()</span>
<span class="w">     </span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="p">(</span><span class="nv">fib</span><span class="w"> </span><span class="mi">20</span><span class="p">)))</span>
</pre></div>
<p>And check out the kernel:</p>
<div class="highlight"><pre><span></span><span class="nv">$</span><span class="w"> </span><span class="nv">cat</span><span class="w"> </span><span class="o">.</span><span class="nv">/lib/kernel.lisp</span>
<span class="p">(</span><span class="nv">def</span><span class="w"> </span><span class="nv">print-char</span><span class="w"> </span><span class="p">(</span><span class="nv">c</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="nv">syscall/write</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">&amp;c</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>

<span class="p">(</span><span class="nv">def</span><span class="w"> </span><span class="nb">print</span><span class="w"> </span><span class="p">(</span><span class="nv">n</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="mi">9</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="mi">10</span><span class="p">)))</span>

<span class="w">     </span><span class="p">(</span><span class="nv">print-char</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">48</span><span class="w"> </span><span class="p">(</span><span class="nv">%</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="mi">10</span><span class="p">))))</span>
</pre></div>
<p>Compile and run it:</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>node<span class="w"> </span>src/ulisp.js<span class="w"> </span>tests/fib.lisp<span class="w"> </span>--backend<span class="w"> </span>x86
$<span class="w"> </span>./build/prog
<span class="m">6765</span>
</pre></div>
<p>And we're in business!</p>
<p><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr">Latest post in the compiler basics series: an x86 upgrade. We&#39;ve got basic syscall support, &quot;infinite&quot; locals and parameters, and if/else. More than enough to handle printing integers to stdout and recursive fibonacci. <a href="https://t.co/B3OV0vEX1V">https://t.co/B3OV0vEX1V</a></p>&mdash; Phil Eaton (@phil_eaton) <a href="https://twitter.com/phil_eaton/status/1203816831456284677?ref_src=twsrc%5Etfw">December 8, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>
<style>.feedback{display:initial;}</style>
	<div class="feedback">
	  <h4>Feedback</h4>
	  <p><small>As always,
	      please <a href="mailto:phil@eatonphil.com">email</a>
	      or <a href="https://twitter.com/eatonphil">tweet me</a>
	      with questions, corrections, or ideas!</small></p>

	</div>
      </div>
    </div>
    <footer>
      <div class="container">
	<div>
	  <div class="row">
	    <div class="feedback">
	      <h4>Frequent Topics</h4>
	      <div class="tags"><a href="/tags/javascript.html" class="tag">javascript (24)</a><a href="/tags/parsing.html" class="tag">parsing (21)</a><a href="/tags/databases.html" class="tag">databases (21)</a><a href="/tags/postgres.html" class="tag">postgres (14)</a><a href="/tags/golang.html" class="tag">golang (14)</a><a href="/tags/compilers.html" class="tag">compilers (14)</a><a href="/tags/sql.html" class="tag">sql (11)</a><a href="/tags/interpreters.html" class="tag">interpreters (11)</a><a href="/tags/lisp.html" class="tag">lisp (9)</a><a href="/tags/books.html" class="tag">books (9)</a><a href="/tags/zig.html" class="tag">zig (8)</a><a href="/tags/python.html" class="tag">python (8)</a><a href="/tags/go.html" class="tag">go (8)</a><a href="/tags/management.html" class="tag">management (7)</a><a href="/tags/linux.html" class="tag">linux (7)</a><a href="/tags/json.html" class="tag">json (7)</a><a href="/tags/x86-amd64.html" class="tag">x86/amd64 (6)</a><a href="/tags/scheme.html" class="tag">scheme (6)</a><a href="/tags/learning.html" class="tag">learning (6)</a><a href="/tags/typescript.html" class="tag">typescript (5)</a></div>
	    </div>
	  </div>
	  <div class="row" id="subscribe">
	    <style type="text/css">
  /* LOADER */
  .ml-form-embedSubmitLoad {
      display: inline-block;
      width: 20px;
      height: 20px;
  }
  .g-recaptcha {
      transform: scale(1);
      -webkit-transform: scale(1);
      transform-origin: 0 0;
      -webkit-transform-origin: 0 0;
      height: ;
  }
  .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0,0,0,0);
      border: 0;
  }
  .ml-form-embedSubmitLoad:after {
      content: " ";
      display: block;
      width: 11px;
      height: 11px;
      margin: 1px;
      border-radius: 50%;
      border: 4px solid #fff;
      border-color: #ffffff #ffffff #ffffff transparent;
      animation: ml-form-embedSubmitLoad 1.2s linear infinite;
  }
  @keyframes ml-form-embedSubmitLoad {
      0% {
          transform: rotate(0deg);
      }
      100% {
          transform: rotate(360deg);
      }
  }
  #mlb2-3175296.ml-form-embedContainer {
      box-sizing: border-box;
      display: table;
      margin: 0 auto;
      position: static;
      width: 100% !important;
  }
  #mlb2-3175296.ml-form-embedContainer h3,
  #mlb2-3175296.ml-form-embedContainer p,
  #mlb2-3175296.ml-form-embedContainer span,
  #mlb2-3175296.ml-form-embedContainer button {
      text-transform: none !important;
      letter-spacing: normal !important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper {
      border-width: 0px;
      border-color: transparent;
  border-radius: 4px;
  border-style: solid;
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  position: relative;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-align-left { text-align: left; }
  #mlb2-3175296.ml-form-embedContainer .ml-form-align-center {
  text-align: center;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-align-default { display: table-cell !important; vertical-align: middle !important; text-align: center !important; }
  #mlb2-3175296.ml-form-embedContainer .ml-form-align-right { text-align: right; }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedHeader img {
  border-top-left-radius: 4px;
  border-top-right-radius: 4px;
  height: auto;
  margin: 0 auto !important;
  max-width: 100%;
  width: undefinedpx;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody.ml-form-embedBodyHorizontal {
  padding-bottom: 0;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent {
  text-align: left;
  margin: 0 0 20px 0;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent p,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent p {
  color: #000000;
  font-size: 14px;
  font-weight: 400;
  line-height: 20px;
  margin: 0 0 10px 0;
  text-align: left;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent ul,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent ol,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent ul,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent ol {
  color: #000000;
  font-size: 14px;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent ol ol,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent ol ol {
  list-style-type: lower-alpha;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent ol ol ol,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent ol ol ol {
  list-style-type: lower-roman;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent p a,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent p a {
  color: #000000;
  text-decoration: underline;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-block-form .ml-field-group {
  text-align: left!important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-block-form .ml-field-group label {
  margin-bottom: 5px;
  color: #333333;
  font-size: 14px;
  font-weight: bold; font-style: normal; text-decoration: none;;
  display: inline-block;
  line-height: 20px;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent p:last-child,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent p:last-child {
  margin: 0;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody form {
  margin: 0;
  width: 100%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-formContent,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow {
  margin: 0 0 20px 0;
  width: 100%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow {
  float: left;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-formContent.horozintalForm {
  margin: 0;
  padding: 0 0 20px 0;
  width: 100%;
  height: auto;
  float: left;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow {
  margin: 0 0 10px 0;
  width: 100%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow.ml-last-item {
  margin: 0;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow.ml-formfieldHorizintal {
  margin: 0;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow input {
  background-color: #ffffff !important;
  color: #333333 !important;
  border-color: #cccccc;
  border-radius: 4px !important;
  border-style: solid !important;
  border-width: 1px !important;
  font-size: 14px !important;
  height: auto;
  line-height: 21px !important;
  margin-bottom: 0;
  margin-top: 0;
  margin-left: 0;
  margin-right: 0;
  padding: 10px 10px !important;
  width: 100% !important;
  box-sizing: border-box !important;
  max-width: 100% !important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow input::-webkit-input-placeholder,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow input::-webkit-input-placeholder { color: #333333; }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow input::-moz-placeholder,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow input::-moz-placeholder { color: #333333; }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow input:-ms-input-placeholder,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow input:-ms-input-placeholder { color: #333333; }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow input:-moz-placeholder,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow input:-moz-placeholder { color: #333333; }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow textarea, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow textarea {
  background-color: #ffffff !important;
  color: #333333 !important;
  border-color: #cccccc;
  border-radius: 4px !important;
  border-style: solid !important;
  border-width: 1px !important;
  font-size: 14px !important;
  height: auto;
  line-height: 21px !important;
  margin-bottom: 0;
  margin-top: 0;
  padding: 10px 10px !important;
  width: 100% !important;
  box-sizing: border-box !important;
  max-width: 100% !important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-radio .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::before {
  border-color: #cccccc!important;
  background-color: #ffffff!important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow input.custom-control-input[type="checkbox"]{
  box-sizing: border-box;
  padding: 0;
  position: absolute;
  z-index: -1;
  opacity: 0;
  margin-top: 5px;
  margin-left: -1.5rem;
  overflow: visible;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::before {
  border-radius: 4px!important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow input[type=checkbox]:checked~.label-description::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox input[type=checkbox]:checked~.label-description::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-input:checked~.custom-control-label::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-input:checked~.custom-control-label::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox input[type=checkbox]:checked~.label-description::after {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8'%3e%3cpath fill='%23fff' d='M6.564.75l-3.59 3.612-1.538-1.55L0 4.26 2.974 7.25 8 2.193z'/%3e%3c/svg%3e");
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-input:checked~.custom-control-label::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-input:checked~.custom-control-label::after {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='3' fill='%23fff'/%3e%3c/svg%3e");
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-input:checked~.custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-radio .custom-control-input:checked~.custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-input:checked~.custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-input:checked~.custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox input[type=checkbox]:checked~.label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox input[type=checkbox]:checked~.label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow input[type=checkbox]:checked~.label-description::before  {
  border-color: #000000!important;
  background-color: #000000!important;
  color: #ffffff!important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-radio .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-label::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-radio .custom-control-label::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-label::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-label::after {
  top: 2px;
  box-sizing: border-box;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox .label-description::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::after {
  top: 0px!important;
  box-sizing: border-box!important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::after {
  top: 0px!important;
  box-sizing: border-box!important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox .label-description::after {
  top: 0px!important;
  box-sizing: border-box!important;
  position: absolute;
  left: -1.5rem;
  display: block;
  width: 1rem;
  height: 1rem;
  content: "";
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox .label-description::before {
  top: 0px!important;
  box-sizing: border-box!important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .custom-control-label::before {
  position: absolute;
  top: 4px;
  left: -1.5rem;
  display: block;
  width: 16px;
  height: 16px;
  pointer-events: none;
  content: "";
  background-color: #ffffff;
  border: #adb5bd solid 1px;
  border-radius: 50%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .custom-control-label::after {
  position: absolute;
  top: 2px!important;
  left: -1.5rem;
  display: block;
  width: 1rem;
  height: 1rem;
  content: "";
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::before {
  position: absolute;
  top: 4px;
  left: -1.5rem;
  display: block;
  width: 16px;
  height: 16px;
  pointer-events: none;
  content: "";
  background-color: #ffffff;
  border: #adb5bd solid 1px;
  border-radius: 50%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox .label-description::after {
  position: absolute;
  top: 0px!important;
  left: -1.5rem;
  display: block;
  width: 1rem;
  height: 1rem;
  content: "";
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::after {
  position: absolute;
  top: 0px!important;
  left: -1.5rem;
  display: block;
  width: 1rem;
  height: 1rem;
  content: "";
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .custom-radio .custom-control-label::after {
  background: no-repeat 50%/50% 50%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .custom-checkbox .custom-control-label::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox .label-description::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox .label-description::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::after {
  background: no-repeat 50%/50% 50%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-control, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-control {
  position: relative;
  display: block;
  min-height: 1.5rem;
  padding-left: 1.5rem;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-input, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-radio .custom-control-input, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-input, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-input {
  position: absolute;
  z-index: -1;
  opacity: 0;
  box-sizing: border-box;
  padding: 0;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-label, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-radio .custom-control-label, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-label, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-label {
  color: #000000;
  font-size: 12px!important;
  line-height: 22px;
  margin-bottom: 0;
  position: relative;
  vertical-align: top;
  font-style: normal;
  font-weight: 700;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-select, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-select {
  background-color: #ffffff !important;
  color: #333333 !important;
  border-color: #cccccc;
  border-radius: 4px !important;
  border-style: solid !important;
  border-width: 1px !important;
  font-size: 14px !important;
  line-height: 20px !important;
  margin-bottom: 0;
  margin-top: 0;
  padding: 10px 28px 10px 12px !important;
  width: 100% !important;
  box-sizing: border-box !important;
  max-width: 100% !important;
  height: auto;
  display: inline-block;
  vertical-align: middle;
  background: url('https://assets.mlcdn.com/ml/images/default/dropdown.svg') no-repeat right .75rem center/8px 10px;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow {
  height: auto;
  width: 100%;
  float: left;
  }
  .ml-form-formContent.horozintalForm .ml-form-horizontalRow .ml-input-horizontal { width: 70%; float: left; }
  .ml-form-formContent.horozintalForm .ml-form-horizontalRow .ml-button-horizontal { width: 30%; float: left; }
  .ml-form-formContent.horozintalForm .ml-form-horizontalRow .ml-button-horizontal.labelsOn { padding-top: 25px;  }
  .ml-form-formContent.horozintalForm .ml-form-horizontalRow .horizontal-fields { box-sizing: border-box; float: left; padding-right: 10px;  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow input {
  background-color: #ffffff;
  color: #333333;
  border-color: #cccccc;
  border-radius: 4px;
  border-style: solid;
  border-width: 1px;
  font-size: 14px;
  line-height: 20px;
  margin-bottom: 0;
  margin-top: 0;
  padding: 10px 10px;
  width: 100%;
  box-sizing: border-box;
  overflow-y: initial;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow button {
  background-color: #000000 !important;
  border-color: #000000;
  border-style: solid;
  border-width: 1px;
  border-radius: 4px;
  box-shadow: none;
  color: #ffffff !important;
  cursor: pointer;
  font-size: 14px !important;
  font-weight: 700;
  line-height: 20px;
  margin: 0 !important;
  padding: 10px !important;
  width: 100%;
  height: auto;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow button:hover {
  background-color: #333333 !important;
  border-color: #333333 !important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
  position: absolute;
  z-index: -1;
  opacity: 0;
  margin-top: 5px;
  margin-left: -1.5rem;
  overflow: visible;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description {
  color: #000000;
  display: block;
  font-size: 12px;
  text-align: left;
  margin-bottom: 0;
  position: relative;
  vertical-align: top;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow label {
  font-weight: normal;
  margin: 0;
  padding: 0;
  position: relative;
  display: block;
  min-height: 24px;
  padding-left: 24px;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow label a {
  color: #000000;
  text-decoration: underline;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow label p {
  color: #000000 !important;
  font-size: 12px !important;
  font-weight: normal !important;
  line-height: 18px !important;
  padding: 0 !important;
  margin: 0 5px 0 0 !important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow label p:last-child {
  margin: 0;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedSubmit {
  margin: 0 0 20px 0;
  float: left;
  width: 100%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedSubmit button {
  background-color: #000000 !important;
  border: none !important;
  border-radius: 4px !important;
  box-shadow: none !important;
  color: #ffffff !important;
  cursor: pointer;
  font-size: 14px !important;
  font-weight: 700 !important;
  line-height: 21px !important;
  height: auto;
  padding: 10px !important;
  width: 100% !important;
  box-sizing: border-box !important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedSubmit button.loading {
  display: none;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedSubmit button:hover {
  background-color: #333333 !important;
  }
  .ml-subscribe-close {
  width: 30px;
  height: 30px;
  background: url('https://assets.mlcdn.com/ml/images/default/modal_close.png') no-repeat;
  background-size: 30px;
  cursor: pointer;
  margin-top: -10px;
  margin-right: -10px;
  position: absolute;
  top: 0;
  right: 0;
  }
  .ml-error input, .ml-error textarea, .ml-error select {
  border-color: red!important;
  }
  .ml-error .custom-checkbox-radio-list {
  border: 1px solid red !important;
  border-radius: 4px;
  padding: 10px;
  }
  .ml-error .label-description,
  .ml-error .label-description p,
  .ml-error .label-description p a,
  .ml-error label:first-child {
  color: #ff0000 !important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow.ml-error .label-description p,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow.ml-error .label-description p:first-letter {
  color: #ff0000 !important;
  }
  @media only screen and (max-width: 400px){
  .ml-form-embedWrapper.embedDefault, .ml-form-embedWrapper.embedPopup { width: 100%!important; }
  .ml-form-formContent.horozintalForm { float: left!important; }
  .ml-form-formContent.horozintalForm .ml-form-horizontalRow { height: auto!important; width: 100%!important; float: left!important; }
  .ml-form-formContent.horozintalForm .ml-form-horizontalRow .ml-input-horizontal { width: 100%!important; }
  .ml-form-formContent.horozintalForm .ml-form-horizontalRow .ml-input-horizontal > div { padding-right: 0px!important; padding-bottom: 10px; }
    .ml-form-formContent.horozintalForm .ml-button-horizontal { width: 100%!important; }
    .ml-form-formContent.horozintalForm .ml-button-horizontal.labelsOn { padding-top: 0px!important; }
    }
</style>
<div id="mlb2-3175296" class="ml-form-embedContainer ml-subscribe-form ml-subscribe-form-3175296">
  <hr />
  <div class="ml-form-align-center ">
    <div class="ml-form-embedWrapper embedForm">
      <div class="ml-form-embedBody ml-form-embedBodyDefault row-form">
        <div class="ml-form-embedContent" style=" ">
          <h4>Subscribe</h4>
          <p>Enter your email if you'd like to be kept in the loop about future articles!<br><br>You can expect 2 to 4 messages per month depending on how motivated I'm feeling. :)</p>
	  <p></p>
	  <p>Cheers,<br>Phil</p>
        </div>
        <form class="ml-block-form" action="https://assets.mailerlite.com/jsonp/303114/forms/78235486326359572/subscribe" data-code="" method="post" target="_blank">
          <div class="ml-form-formContent">
            <div class="ml-form-fieldRow ml-last-item">
              <div class="ml-field-group ml-field-email ml-validate-email ml-validate-required">
                <!-- input -->
                <input aria-label="email" aria-required="true" type="email" class="form-control" data-inputmask="" name="fields[email]" placeholder="Email" autocomplete="email">
                <!-- /input -->
                <!-- textarea -->
                <!-- /textarea -->
                <!-- select -->
                <!-- /select -->
                <!-- checkboxes -->
		<!-- /checkboxes -->
                <!-- radio -->
                <!-- /radio -->
                <!-- countries -->
                <!-- /countries -->
              </div>
            </div>
          </div>
          <!-- Privacy policy -->
          <!-- /Privacy policy -->
	  <div class="ml-form-recaptcha ml-validate-required" style="float: left;">
            <style type="text/css">
	      .ml-form-recaptcha {
		  margin-bottom: 20px;
	      }
	      .ml-form-recaptcha.ml-error iframe {
		  border: solid 1px #ff0000;
	      }
	      @media screen and (max-width: 480px) {
		  .ml-form-recaptcha {
		      width: 220px!important
		  }
		  .g-recaptcha {
		      transform: scale(0.78);
		      -webkit-transform: scale(0.78);
		      transform-origin: 0 0;
		      -webkit-transform-origin: 0 0;
		  }
	      }
	    </style>
	    <script src="https://www.google.com/recaptcha/api.js"></script>
	    <div class="g-recaptcha" data-sitekey="6Lf1KHQUAAAAAFNKEX1hdSWCS3mRMv4FlFaNslaD"></div>
	  </div>
          <input type="hidden" name="ml-submit" value="1">
          <div class="ml-form-embedSubmit">
            <button type="submit" class="primary">Subscribe</button>
            <button disabled="disabled" style="display: none;" type="button" class="loading">
              <div class="ml-form-embedSubmitLoad"></div>
              <span class="sr-only">Loading...</span>
            </button>
          </div>
          <input type="hidden" name="anticsrf" value="true">
        </form>
      </div>
      <div class="ml-form-successBody row-success" style="display: none">
        <div class="ml-form-successContent">
          <h3>Thanks :)</h3>
          <p>You're in.</p>
        </div>
      </div>
    </div>
  </div>
</div>
<script>
  function ml_webform_success_3175296() {
      var $ = ml_jQuery || jQuery;
      $('.ml-subscribe-form-3175296 .row-success').show();
      $('.ml-subscribe-form-3175296 .row-form').hide();
  }
</script>
<script src="https://groot.mailerlite.com/js/w/webforms.min.js?v300817f630ad0e957914d0b28a2b6d78" type="text/javascript"></script>

	  </div>
	  <div class="row" style="margin-bottom: 25px">
	    <small>Having trouble subscribing? <a href="mailto:phil@eatonphil.com">Let me know</a>.</small>
	  </div>
	</div>
      </div>
    </footer>
    <script async onload="loadGA()" src="https://www.googletagmanager.com/gtag/js?id=UA-58109156-2"></script>
    <script>
      function loadGA() {
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());
	  gtag('config', 'UA-58109156-2');
      }
    </script>
    <script defer src="https://cdn.usefathom.com/script.js" data-site="CEPUOLOQ"></script>
  </body>
</html>
