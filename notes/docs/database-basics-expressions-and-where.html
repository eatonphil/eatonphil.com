<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="canonical" href="https://notes.eatonphil.com/database-basics-expressions-and-where.html">
    <title>Writing a SQL database from scratch in Go: 2. binary expressions and WHERE filters | notes.eatonphil.com</title>
    <meta name="description" content="Writing a SQL database from scratch in Go: 2. binary expressions and WHERE filters" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
  </head>
  <body>
    <header>
      <div class="container">
        <div>
          <div class="row">
	    <div>
	      <a href="https://eatonphil.com" class="sm-link">
		Home
              </a>
	      <a href="/" class="sm-link">
		Notes
              </a>
	      <a href="/favorites.html" class="sm-link">
		Popular
              </a>
	      <a href="/rss.xml" class="sm-link">
		RSS
              </a>
	    </div>
	    	      
	    <div class="subscribe">                                     
	      <a href="https://notes.eatonphil.com/database-basics-expressions-and-where.html#subscribe">       
		Subscribe          
	      </a>
            </div>
	  </div>
	  <hr />
          <h2>April 12, 2020</h2>
          <h1>Writing a SQL database from scratch in Go: 2. binary expressions and WHERE filters</h1>
          <div class="row" style="padding-bottom: 5px">
            <div class="tags"><a href="/tags/databases.html" class="tag">databases</a><a href="/tags/golang.html" class="tag">golang</a><a href="/tags/parsing.html" class="tag">parsing</a><a href="/tags/sql.html" class="tag">sql</a><a href="/tags/postgres.html" class="tag">postgres</a></div>
          </div>
	</div>
      </div>
    </header>
    <div class="container">
      <div class="col-6">
        <p class="note">
  Previously in database basics:
  <! forgive me, for I have sinned >
  <br />
  <a href="/database-basics.html">1. SELECT, INSERT, CREATE and a REPL</a>
  <br />
  <br />
  Next in database basics:
  <br />
  <a href="/database-basics-indexes.html">3. indexes</a>
  <br />
  <a href="/database-basics-a-database-sql-driver.html">4. a database/sql driver</a>
</p><p>In this post, we'll extend <a href="https://github.com/eatonphil/gosql">gosql</a>
to support binary expressions and very simple filtering on SELECT
results via WHERE. We'll introduce a general mechanism for
interpreting an expression on a row in a table. The expression may be
an identifier (where the result is the value of the cell corresponding
to that column in the row), a numeric literal, a combination via a
binary expression, etc.</p>
<p>The following interactions will be possible:</p>
<div class="highlight"><pre><span></span><span class="o">#</span><span class="w"> </span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="nb">TEXT</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="nb">INT</span><span class="p">);</span>
<span class="n">ok</span>
<span class="o">#</span><span class="w">  </span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;Stephen&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span>
<span class="n">ok</span>
<span class="o">#</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users</span><span class="p">;</span>
<span class="n">name</span><span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="n">age</span>
<span class="c1">----------+------</span>
<span class="n">Stephen</span><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="mi">16</span>
<span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="k">result</span><span class="p">)</span>
<span class="n">ok</span>
<span class="o">#</span><span class="w"> </span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;Adrienne&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">23</span><span class="p">);</span>
<span class="n">ok</span>
<span class="o">#</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">23</span><span class="p">;</span>
<span class="n">age</span><span class="w"> </span><span class="o">|</span><span class="w">   </span><span class="n">name</span>
<span class="c1">------+-----------</span>
<span class="mi">25</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Adrienne</span>
<span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="k">result</span><span class="p">)</span>
<span class="n">ok</span>
<span class="o">#</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users</span><span class="p">;</span>
<span class="n">name</span>
<span class="c1">------------</span>
<span class="n">Stephen</span>
<span class="n">Adrienne</span>
<span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">results</span><span class="p">)</span>
<span class="n">ok</span>
</pre></div>
<p>The changes we'll make in this post are roughly a walk through of
<a href="https://github.com/eatonphil/gosql/commit/bd6a5d0d4a7410699b0d01beaabf91923df34b28">this
commit</a>.</p>
<h3 id="boilerplate-updates">Boilerplate updates</h3><p>There are a few updates to pick up that I won't go into in this
post. Grab the following files from the main repo:</p>
<ul>
<li><a href="https://github.com/eatonphil/gosql/blob/master/lexer.go">lexer.go</a><ul>
<li>The big change here is to use the same keyword matching algorithm
for symbols. This allows us to support symbols that are longer
than one character.</li>
<li>This file also now includes the following keywords and symbols:
<code>and</code>, <code>or</code>, <code>true</code>,
<code>false</code>, <code>=</code>, <code><></code>,
<code>||</code>, and <code>+</code>.</li>
</ul>
</li>
<li><a href="https://github.com/eatonphil/gosql/blob/master/cmd/main.go">cmd/main.go</a><ul>
<li>This file now uses a <a href="https://github.com/olekukonko/tablewriter">third-party table-rendering
library</a> instead of the
hacky, handwritten original one.</li>
<li>This also uses a <a href="https://github.com/chzyer/readline">third-party readline
implementation</a> so you get
history and useful cursor movement in the REPL.</li>
</ul>
</li>
</ul>
<h4 id="parsing-boilerplate">Parsing boilerplate</h4><p>We'll redefine three helper functions in <code>parser.go</code> before
going further:
<code>parseToken</code>, <code>parseTokenKind</code>, and
<code>helpMessage</code>.</p>
<p>The <code>parseToken</code> helper will consume a token if it matches
the one provided as an argument (ignoring location).</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">parseToken</span><span class="p">(</span><span class="nx">tokens</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="nx">t</span><span class="w"> </span><span class="nx">token</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">cursor</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">initialCursor</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">cursor</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">tokens</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">tokens</span><span class="p">[</span><span class="nx">cursor</span><span class="p">];</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">equals</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">p</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="p">}</span>
</pre></div>
<p>The <code>parseTokenKind</code> helper will consume a token if it is
the same kind as an argument provided.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">parseTokenKind</span><span class="p">(</span><span class="nx">tokens</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="nx">kind</span><span class="w"> </span><span class="nx">tokenKind</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">cursor</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">initialCursor</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">cursor</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">tokens</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">current</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">tokens</span><span class="p">[</span><span class="nx">cursor</span><span class="p">]</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">current</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">kind</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">current</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="p">}</span>
</pre></div>
<p>And the <code>helpMessage</code> helper will give an indication of
where in a program something happened.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="nx">msg</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">*</span><span class="nx">token</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">cursor</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">tokens</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">c</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">tokens</span><span class="p">[</span><span class="nx">cursor</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">c</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">tokens</span><span class="p">[</span><span class="nx">cursor</span><span class="p">]</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;[%d,%d]: %s, near: %s\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">.</span><span class="nx">loc</span><span class="p">.</span><span class="nx">line</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">.</span><span class="nx">loc</span><span class="p">.</span><span class="nx">col</span><span class="p">,</span><span class="w"> </span><span class="nx">msg</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<h3 id="parsing-binary-expressions">Parsing binary expressions</h3><p>Next we'll extend the AST structure in <code>ast.go</code> to
support a "binary kind" of expression. The binary expression will have
two sub-expressions and an operator.</p>
<div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="nx">literalKind</span><span class="w"> </span><span class="nx">expressionKind</span>
<span class="w">    </span><span class="nx">binaryKind</span>
<span class="p">)</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">binaryExpression</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">a</span><span class="w">  </span><span class="nx">expression</span>
<span class="w">    </span><span class="nx">b</span><span class="w">  </span><span class="nx">expression</span>
<span class="w">    </span><span class="nx">op</span><span class="w"> </span><span class="nx">token</span>
<span class="p">}</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">expression</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">literal</span><span class="w"> </span><span class="o">*</span><span class="nx">token</span>
<span class="w">    </span><span class="nx">binary</span><span class="w">  </span><span class="o">*</span><span class="nx">binaryExpression</span>
<span class="w">    </span><span class="nx">kind</span><span class="w">    </span><span class="nx">expressionKind</span>
<span class="p">}</span>
</pre></div>
<p>We'll use Pratt parsing to handle operator precedence. There is an
excellent introduction to this technique
<a href="https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html">here</a>.</p>
<p>If at the beginning of parsing we see a left parenthesis, we'll
consume it and parse an expression within it. Then we'll look for a
right parenthesis. Otherwise we'll look for a non-binary expression
first (e.g. symbol, number).</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">parseExpression</span><span class="p">(</span><span class="nx">tokens</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="nx">delimiters</span><span class="w"> </span><span class="p">[]</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">minBp</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">expression</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">cursor</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">initialCursor</span>

<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">exp</span><span class="w"> </span><span class="o">*</span><span class="nx">expression</span>
<span class="w">    </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parseToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">leftParenSymbol</span><span class="p">))</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">cursor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newCursor</span>
<span class="w">        </span><span class="nx">rightParenToken</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">rightParenSymbol</span><span class="p">)</span>

<span class="w">        </span><span class="nx">exp</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">parseExpression</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">delimiters</span><span class="p">,</span><span class="w"> </span><span class="nx">rightParenToken</span><span class="p">),</span><span class="w"> </span><span class="nx">minBp</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected expression after opening paren&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">parseToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">rightParenToken</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected closing paren&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">exp</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">parseLiteralExpression</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="o">...</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">exp</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="p">}</span>
</pre></div>
<p>Then we'll look for a binary operator (e.g. <code>=</code>,
<code>and</code>) or delimiter. If we find an operator and it of
lesser "binding power" than the current minimum (<code>minBp</code>
passed as an argument to the parse function with a default value of
<code>0</code>), we'll return the current expression.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="o">...</span>

<span class="w">    </span><span class="nx">lastCursor</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">cursor</span>
<span class="nx">outer</span><span class="p">:</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">cursor</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">tokens</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">d</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">delimiters</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">parseToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">d</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">break</span><span class="w"> </span><span class="nx">outer</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nx">binOps</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="nx">token</span><span class="p">{</span>
<span class="w">            </span><span class="nx">tokenFromKeyword</span><span class="p">(</span><span class="nx">andKeyword</span><span class="p">),</span>
<span class="w">            </span><span class="nx">tokenFromKeyword</span><span class="p">(</span><span class="nx">orKeyword</span><span class="p">),</span>
<span class="w">            </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">eqSymbol</span><span class="p">),</span>
<span class="w">            </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">neqSymbol</span><span class="p">),</span>
<span class="w">            </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">concatSymbol</span><span class="p">),</span>
<span class="w">            </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">plusSymbol</span><span class="p">),</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kd">var</span><span class="w"> </span><span class="nx">op</span><span class="w"> </span><span class="o">*</span><span class="nx">token</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">bo</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">binOps</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">var</span><span class="w"> </span><span class="nx">t</span><span class="w"> </span><span class="o">*</span><span class="nx">token</span>
<span class="w">            </span><span class="nx">t</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">parseToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">bo</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">op</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">t</span>
<span class="w">                </span><span class="k">break</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">op</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected binary operator&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nx">bp</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">op</span><span class="p">.</span><span class="nx">bindingPower</span><span class="p">()</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">bp</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">minBp</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">cursor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">lastCursor</span>
<span class="w">            </span><span class="k">break</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="o">...</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">exp</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
</pre></div>
<p>The <code>bindingPower</code> function on tokens can be defined for
now such that sum and concatenation have the highest binding power,
followed by equality operations, then boolean operators, and then
everything else at zero.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">t</span><span class="w"> </span><span class="nx">token</span><span class="p">)</span><span class="w"> </span><span class="nx">bindingPower</span><span class="p">()</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nx">keywordKind</span><span class="p">:</span>
<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="nx">keyword</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="nx">andKeyword</span><span class="p">:</span>
<span class="w">            </span><span class="k">fallthrough</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="nx">orKeyword</span><span class="p">:</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nx">symbolKind</span><span class="p">:</span>
<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="nx">symbol</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="nx">eqSymbol</span><span class="p">:</span>
<span class="w">            </span><span class="k">fallthrough</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="nx">neqSymbol</span><span class="p">:</span>
<span class="w">            </span><span class="k">fallthrough</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="nx">concatSymbol</span><span class="p">:</span>
<span class="w">            </span><span class="k">fallthrough</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="nx">plusSymbol</span><span class="p">:</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">3</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span>
<span class="p">}</span>
</pre></div>
<p>Back in <code>parseExpression</code>, if the new operator has greater
binding power we'll parse the next operand expression (a recursive
call, passing the binding power of the new operator as the new
<code>minBp</code>).</p>
<p>Upon completion, the current expression (the return value of the
recursive call) is set to a new binary expression containing the
previously current expression on the left and the just-parsed
expression on the right.</p>
<div class="highlight"><pre><span></span><span class="w">        </span><span class="o">...</span>

<span class="w">        </span><span class="nx">b</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parseExpression</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">delimiters</span><span class="p">,</span><span class="w"> </span><span class="nx">bp</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected right operand&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nx">exp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">expression</span><span class="p">{</span>
<span class="w">            </span><span class="nx">binary</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">binaryExpression</span><span class="p">{</span>
<span class="w">                </span><span class="o">*</span><span class="nx">exp</span><span class="p">,</span>
<span class="w">                </span><span class="o">*</span><span class="nx">b</span><span class="p">,</span>
<span class="w">                </span><span class="o">*</span><span class="nx">op</span><span class="p">,</span>
<span class="w">            </span><span class="p">},</span>
<span class="w">            </span><span class="nx">kind</span><span class="p">:</span><span class="w"> </span><span class="nx">binaryKind</span><span class="p">,</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nx">cursor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newCursor</span>
<span class="w">        </span><span class="nx">lastCursor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">cursor</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">exp</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="p">}</span>
</pre></div>
<p>All together:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">parseExpression</span><span class="p">(</span><span class="nx">tokens</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="nx">delimiters</span><span class="w"> </span><span class="p">[]</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">minBp</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">expression</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">cursor</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">initialCursor</span>

<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">exp</span><span class="w"> </span><span class="o">*</span><span class="nx">expression</span>
<span class="w">    </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parseToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">leftParenSymbol</span><span class="p">))</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">cursor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newCursor</span>
<span class="w">        </span><span class="nx">rightParenToken</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">rightParenSymbol</span><span class="p">)</span>

<span class="w">        </span><span class="nx">exp</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">parseExpression</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">delimiters</span><span class="p">,</span><span class="w"> </span><span class="nx">rightParenToken</span><span class="p">),</span><span class="w"> </span><span class="nx">minBp</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected expression after opening paren&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">parseToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">rightParenToken</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected closing paren&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">exp</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">parseLiteralExpression</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">lastCursor</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">cursor</span>
<span class="nx">outer</span><span class="p">:</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">cursor</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">tokens</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">d</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">delimiters</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">parseToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">d</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">break</span><span class="w"> </span><span class="nx">outer</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nx">binOps</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="nx">token</span><span class="p">{</span>
<span class="w">            </span><span class="nx">tokenFromKeyword</span><span class="p">(</span><span class="nx">andKeyword</span><span class="p">),</span>
<span class="w">            </span><span class="nx">tokenFromKeyword</span><span class="p">(</span><span class="nx">orKeyword</span><span class="p">),</span>
<span class="w">            </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">eqSymbol</span><span class="p">),</span>
<span class="w">            </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">neqSymbol</span><span class="p">),</span>
<span class="w">            </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">concatSymbol</span><span class="p">),</span>
<span class="w">            </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">plusSymbol</span><span class="p">),</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kd">var</span><span class="w"> </span><span class="nx">op</span><span class="w"> </span><span class="o">*</span><span class="nx">token</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">bo</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">binOps</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">var</span><span class="w"> </span><span class="nx">t</span><span class="w"> </span><span class="o">*</span><span class="nx">token</span>
<span class="w">            </span><span class="nx">t</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">parseToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">bo</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">op</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">t</span>
<span class="w">                </span><span class="k">break</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">op</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected binary operator&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nx">bp</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">op</span><span class="p">.</span><span class="nx">bindingPower</span><span class="p">()</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">bp</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">minBp</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">cursor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">lastCursor</span>
<span class="w">            </span><span class="k">break</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nx">b</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parseExpression</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">delimiters</span><span class="p">,</span><span class="w"> </span><span class="nx">bp</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected right operand&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nx">exp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">expression</span><span class="p">{</span>
<span class="w">            </span><span class="nx">binary</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">binaryExpression</span><span class="p">{</span>
<span class="w">                </span><span class="o">*</span><span class="nx">exp</span><span class="p">,</span>
<span class="w">                </span><span class="o">*</span><span class="nx">b</span><span class="p">,</span>
<span class="w">                </span><span class="o">*</span><span class="nx">op</span><span class="p">,</span>
<span class="w">            </span><span class="p">},</span>
<span class="w">            </span><span class="nx">kind</span><span class="p">:</span><span class="w"> </span><span class="nx">binaryKind</span><span class="p">,</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nx">cursor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newCursor</span>
<span class="w">        </span><span class="nx">lastCursor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">cursor</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">exp</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="p">}</span>
</pre></div>
<p>Now that we have this general parse expression helper in place, we can
add support for parsing <code>WHERE</code> in <code>SELECT</code>
statements.</p>
<h3 id="parsing-where">Parsing WHERE</h3><p>This part's pretty easy. We modify the existing
<code>parseSelectStatement</code> to search for an optional
<code>WHERE</code> token followed by an expression.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">parseSelectStatement</span><span class="p">(</span><span class="nx">tokens</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="nx">delimiter</span><span class="w"> </span><span class="nx">token</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">SelectStatement</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="kt">bool</span>
<span class="w">    </span><span class="nx">cursor</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">initialCursor</span>
<span class="w">    </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">parseToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">tokenFromKeyword</span><span class="p">(</span><span class="nx">selectKeyword</span><span class="p">))</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">slct</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">SelectStatement</span><span class="p">{}</span>

<span class="w">    </span><span class="nx">fromToken</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">tokenFromKeyword</span><span class="p">(</span><span class="nx">fromKeyword</span><span class="p">)</span>
<span class="w">    </span><span class="nx">item</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parseSelectItem</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="p">[]</span><span class="nx">token</span><span class="p">{</span><span class="nx">fromToken</span><span class="p">,</span><span class="w"> </span><span class="nx">delimiter</span><span class="p">})</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">slct</span><span class="p">.</span><span class="nx">item</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">item</span>
<span class="w">    </span><span class="nx">cursor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newCursor</span>

<span class="w">    </span><span class="nx">whereToken</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">tokenFromKeyword</span><span class="p">(</span><span class="nx">whereKeyword</span><span class="p">)</span>
<span class="w">    </span><span class="nx">delimiters</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="nx">token</span><span class="p">{</span><span class="nx">delimiter</span><span class="p">,</span><span class="w"> </span><span class="nx">whereToken</span><span class="p">}</span>

<span class="w">    </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">parseToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">fromToken</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">from</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parseFromItem</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">delimiters</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected FROM item&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nx">slct</span><span class="p">.</span><span class="nx">from</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">from</span>
<span class="w">        </span><span class="nx">cursor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newCursor</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">parseToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">whereToken</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">where</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parseExpression</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="p">[]</span><span class="nx">token</span><span class="p">{</span><span class="nx">delimiter</span><span class="p">},</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected WHERE conditionals&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nx">slct</span><span class="p">.</span><span class="nx">where</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">where</span>
<span class="w">        </span><span class="nx">cursor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newCursor</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">slct</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="p">}</span>
</pre></div>
<p>Now we're all done with parsing binary expressions and
<code>WHERE</code> filters! If in doubt, refer to
<a href="https://github.com/eatonphil/gosql/blob/master/parser.go">parser.go</a>
in the project.</p>
<h3 id="re-thinking-query-execution">Re-thinking query execution</h3><p>In the first post in this series, we didn't establish any standard way
for interpreting an expression in any kind of statement. In SQL
though, every expression is always run in the context of a row in a
table. We'll handle cases like <code>SELECT 1</code> and <code>INSERT INTO
users VALUES (1)</code> by creating a table with a single empty row to act
as the context.</p>
<p>This requires a bit of re-architecting. So we'll rewrite the
<code>memory.go</code> implementation in this post from scratch.</p>
<p>We'll also stop <code>panic</code>-ing when things go wrong. Instead
we'll print a message. This allows the REPL loop to keep going.</p>
<h4 id="memory-cells">Memory cells</h4><p>Again the fundamental blocks of memory in the table will be an untyped
array of bytes. We'll provide conversion methods from this memory cell
into integers, strings, and boolean Go values.</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">MemoryCell</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">mc</span><span class="w"> </span><span class="nx">MemoryCell</span><span class="p">)</span><span class="w"> </span><span class="nx">AsInt</span><span class="p">()</span><span class="w"> </span><span class="kt">int32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kt">int32</span>
<span class="w">    </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">binary</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">NewBuffer</span><span class="p">(</span><span class="nx">mc</span><span class="p">),</span><span class="w"> </span><span class="nx">binary</span><span class="p">.</span><span class="nx">BigEndian</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">i</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Corrupted data [%s]: %s\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">mc</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">i</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">mc</span><span class="w"> </span><span class="nx">MemoryCell</span><span class="p">)</span><span class="w"> </span><span class="nx">AsText</span><span class="p">()</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">string</span><span class="p">(</span><span class="nx">mc</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">mc</span><span class="w"> </span><span class="nx">MemoryCell</span><span class="p">)</span><span class="w"> </span><span class="nx">AsBool</span><span class="p">()</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">mc</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">mc</span><span class="w"> </span><span class="nx">MemoryCell</span><span class="p">)</span><span class="w"> </span><span class="nx">equals</span><span class="p">(</span><span class="nx">b</span><span class="w"> </span><span class="nx">MemoryCell</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Seems verbose but need to make sure if one is nil, the</span>
<span class="w">    </span><span class="c1">// comparison still fails quickly</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">mc</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">mc</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Compare</span><span class="p">(</span><span class="nx">mc</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span>
<span class="p">}</span>
</pre></div>
<p>We'll also extend the <code>Cell</code> interface in
<code>backend.go</code> to support the new boolean type.</p>
<div class="highlight"><pre><span></span><span class="kn">package</span><span class="w"> </span><span class="nx">gosql</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">ColumnType</span><span class="w"> </span><span class="kt">uint</span>

<span class="kd">const</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="nx">TextType</span><span class="w"> </span><span class="nx">ColumnType</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">iota</span>
<span class="w">    </span><span class="nx">IntType</span>
<span class="w">    </span><span class="nx">BoolType</span>
<span class="p">)</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">Cell</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">AsText</span><span class="p">()</span><span class="w"> </span><span class="kt">string</span>
<span class="w">    </span><span class="nx">AsInt</span><span class="p">()</span><span class="w"> </span><span class="kt">int32</span>
<span class="w">    </span><span class="nx">AsBool</span><span class="p">()</span><span class="w"> </span><span class="kt">bool</span>
<span class="p">}</span>

<span class="o">...</span>
</pre></div>
<p>Finally, we need a way for mapping a Go value <em>into</em> a memory
cell.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">literalToMemoryCell</span><span class="p">(</span><span class="nx">t</span><span class="w"> </span><span class="o">*</span><span class="nx">token</span><span class="p">)</span><span class="w"> </span><span class="nx">MemoryCell</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">numericKind</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">buf</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
<span class="w">        </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">strconv</span><span class="p">.</span><span class="nx">Atoi</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Corrupted data [%s]: %s\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">MemoryCell</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// TODO: handle bigint</span>
<span class="w">        </span><span class="nx">err</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">binary</span><span class="p">.</span><span class="nx">Write</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span><span class="w"> </span><span class="nx">binary</span><span class="p">.</span><span class="nx">BigEndian</span><span class="p">,</span><span class="w"> </span><span class="nb">int32</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Corrupted data [%s]: %s\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">string</span><span class="p">(</span><span class="nx">buf</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">()),</span><span class="w"> </span><span class="nx">err</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">MemoryCell</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">MemoryCell</span><span class="p">(</span><span class="nx">buf</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">())</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">stringKind</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">MemoryCell</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">boolKind</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">MemoryCell</span><span class="p">([]</span><span class="kt">byte</span><span class="p">{</span><span class="mi">1</span><span class="p">})</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">MemoryCell</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
<p>And we'll provide global <code>true</code> and <code>false</code>
values:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="nx">trueToken</span><span class="w">  </span><span class="p">=</span><span class="w"> </span><span class="nx">token</span><span class="p">{</span><span class="nx">kind</span><span class="p">:</span><span class="w"> </span><span class="nx">boolKind</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;true&quot;</span><span class="p">}</span>
<span class="w">    </span><span class="nx">falseToken</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">token</span><span class="p">{</span><span class="nx">kind</span><span class="p">:</span><span class="w"> </span><span class="nx">boolKind</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;false&quot;</span><span class="p">}</span>

<span class="w">    </span><span class="nx">trueMemoryCell</span><span class="w">  </span><span class="p">=</span><span class="w"> </span><span class="nx">literalToMemoryCell</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">trueToken</span><span class="p">)</span>
<span class="w">    </span><span class="nx">falseMemoryCell</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">literalToMemoryCell</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">falseToken</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
<h4 id="tables">Tables</h4><p>A table has a list of rows (an array of memory cells) and a list of
column names and types.</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">table</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">columns</span><span class="w">     </span><span class="p">[]</span><span class="kt">string</span>
<span class="w">    </span><span class="nx">columnTypes</span><span class="w"> </span><span class="p">[]</span><span class="nx">ColumnType</span>
<span class="w">    </span><span class="nx">rows</span><span class="w">        </span><span class="p">[][]</span><span class="nx">MemoryCell</span>
<span class="p">}</span>
</pre></div>
<p>Finally we'll add a series of methods on <code>table</code> that,
given a row index, interprets an expression AST against that row in
the table.</p>
<h3 id="interpreting-literals">Interpreting literals</h3><p>First we'll implement <code>evaluateLiteralCell</code> that will look
up an identifier or return the value of integers, strings, and
booleans.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">t</span><span class="w"> </span><span class="o">*</span><span class="nx">table</span><span class="p">)</span><span class="w"> </span><span class="nx">evaluateLiteralCell</span><span class="p">(</span><span class="nx">rowIndex</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="nx">exp</span><span class="w"> </span><span class="nx">expression</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">MemoryCell</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">ColumnType</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">exp</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">literalKind</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nx">ErrInvalidCell</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">lit</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">exp</span><span class="p">.</span><span class="nx">literal</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">lit</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">identifierKind</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">tableCol</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">columns</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">tableCol</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">lit</span><span class="p">.</span><span class="nx">value</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">rows</span><span class="p">[</span><span class="nx">rowIndex</span><span class="p">][</span><span class="nx">i</span><span class="p">],</span><span class="w"> </span><span class="nx">tableCol</span><span class="p">,</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">columnTypes</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nx">ErrColumnDoesNotExist</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">columnType</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">IntType</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">lit</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">stringKind</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">columnType</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">TextType</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nx">lit</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">boolKind</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">columnType</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">BoolType</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">literalToMemoryCell</span><span class="p">(</span><span class="nx">lit</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;?column?&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">columnType</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
<h3 id="interpreting-binary-expressions">Interpreting binary expressions</h3><p>Now we can implement <code>evaluateBinaryCell</code> that will
evaluate it's two sub-expressions and combine them together according
to the operator. The SQL operators we have defined so far do no
coercion. So we'll fail immediately if the two sides of the operation
are not of the same type. Additionally, the concatenation and addition
operators require that their arguments are strings and numbers,
respectively.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">t</span><span class="w"> </span><span class="o">*</span><span class="nx">table</span><span class="p">)</span><span class="w"> </span><span class="nx">evaluateBinaryCell</span><span class="p">(</span><span class="nx">rowIndex</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="nx">exp</span><span class="w"> </span><span class="nx">expression</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">MemoryCell</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">ColumnType</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">exp</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">binaryKind</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nx">ErrInvalidCell</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">bexp</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">exp</span><span class="p">.</span><span class="nx">binary</span>

<span class="w">    </span><span class="nx">l</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">lt</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">evaluateCell</span><span class="p">(</span><span class="nx">rowIndex</span><span class="p">,</span><span class="w"> </span><span class="nx">bexp</span><span class="p">.</span><span class="nx">a</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">rt</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">evaluateCell</span><span class="p">(</span><span class="nx">rowIndex</span><span class="p">,</span><span class="w"> </span><span class="nx">bexp</span><span class="p">.</span><span class="nx">b</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="nx">bexp</span><span class="p">.</span><span class="nx">op</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nx">symbolKind</span><span class="p">:</span>
<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="nx">symbol</span><span class="p">(</span><span class="nx">bexp</span><span class="p">.</span><span class="nx">op</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="nx">eqSymbol</span><span class="p">:</span>
<span class="w">            </span><span class="nx">eq</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">l</span><span class="p">.</span><span class="nx">equals</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">lt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">TextType</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">rt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">TextType</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">eq</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nx">trueMemoryCell</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;?column?&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">BoolType</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">lt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">IntType</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">rt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">IntType</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">eq</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nx">trueMemoryCell</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;?column?&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">BoolType</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">lt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">BoolType</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">rt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">BoolType</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">eq</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nx">trueMemoryCell</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;?column?&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">BoolType</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">falseMemoryCell</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;?column?&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">BoolType</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="nx">neqSymbol</span><span class="p">:</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">lt</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">rt</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">!</span><span class="nx">l</span><span class="p">.</span><span class="nx">equals</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nx">trueMemoryCell</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;?column?&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">BoolType</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">falseMemoryCell</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;?column?&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">BoolType</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="nx">concatSymbol</span><span class="p">:</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">lt</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">TextType</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">rt</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">TextType</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nx">ErrInvalidOperands</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">literalToMemoryCell</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">token</span><span class="p">{</span><span class="nx">kind</span><span class="p">:</span><span class="w"> </span><span class="nx">stringKind</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">:</span><span class="w"> </span><span class="nx">l</span><span class="p">.</span><span class="nx">AsText</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">r</span><span class="p">.</span><span class="nx">AsText</span><span class="p">()}),</span><span class="w"> </span><span class="s">&quot;?column?&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">TextType</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="nx">plusSymbol</span><span class="p">:</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">lt</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">IntType</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">rt</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">IntType</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nx">ErrInvalidOperands</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="nx">iValue</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">AsInt</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">r</span><span class="p">.</span><span class="nx">AsInt</span><span class="p">())</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">literalToMemoryCell</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">token</span><span class="p">{</span><span class="nx">kind</span><span class="p">:</span><span class="w"> </span><span class="nx">numericKind</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">:</span><span class="w"> </span><span class="nx">strconv</span><span class="p">.</span><span class="nx">Itoa</span><span class="p">(</span><span class="nx">iValue</span><span class="p">)}),</span><span class="w"> </span><span class="s">&quot;?column?&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">IntType</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">        </span><span class="k">default</span><span class="p">:</span>
<span class="w">            </span><span class="c1">// TODO</span>
<span class="w">            </span><span class="k">break</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nx">keywordKind</span><span class="p">:</span>
<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="nx">keyword</span><span class="p">(</span><span class="nx">bexp</span><span class="p">.</span><span class="nx">op</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="nx">andKeyword</span><span class="p">:</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">lt</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">BoolType</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">rt</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">BoolType</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nx">ErrInvalidOperands</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="nx">res</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">falseMemoryCell</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">l</span><span class="p">.</span><span class="nx">AsBool</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">r</span><span class="p">.</span><span class="nx">AsBool</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">res</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">trueMemoryCell</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">res</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;?column?&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">BoolType</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="nx">orKeyword</span><span class="p">:</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">lt</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">BoolType</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">rt</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">BoolType</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nx">ErrInvalidOperands</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="nx">res</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">falseMemoryCell</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">l</span><span class="p">.</span><span class="nx">AsBool</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">r</span><span class="p">.</span><span class="nx">AsBool</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">res</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">trueMemoryCell</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">res</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;?column?&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">BoolType</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">        </span><span class="k">default</span><span class="p">:</span>
<span class="w">            </span><span class="c1">// TODO</span>
<span class="w">            </span><span class="k">break</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nx">ErrInvalidCell</span>
<span class="p">}</span>
</pre></div>
<p>Then we'll provide a generic <code>evaluateCell</code> method to wrap
these two correctly:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">t</span><span class="w"> </span><span class="o">*</span><span class="nx">table</span><span class="p">)</span><span class="w"> </span><span class="nx">evaluateCell</span><span class="p">(</span><span class="nx">rowIndex</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="nx">exp</span><span class="w"> </span><span class="nx">expression</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">MemoryCell</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">ColumnType</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="nx">exp</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="nx">literalKind</span><span class="p">:</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">evaluateLiteralCell</span><span class="p">(</span><span class="nx">rowIndex</span><span class="p">,</span><span class="w"> </span><span class="nx">exp</span><span class="p">)</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="nx">binaryKind</span><span class="p">:</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">evaluateBinaryCell</span><span class="p">(</span><span class="nx">rowIndex</span><span class="p">,</span><span class="w"> </span><span class="nx">exp</span><span class="p">)</span>
<span class="w">        </span><span class="k">default</span><span class="p">:</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nx">ErrInvalidCell</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h3 id="implementing-select">Implementing SELECT</h3><p>As before, each statement will operate on a backend of tables.</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">MemoryBackend</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">tables</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">table</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">NewMemoryBackend</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="nx">MemoryBackend</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">MemoryBackend</span><span class="p">{</span>
<span class="w">        </span><span class="nx">tables</span><span class="p">:</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">table</span><span class="p">{},</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>When we implement <code>SELECT</code>, we'll iterate over each row in
the table (we only support looking up one table for now).  If the
<code>SELECT</code> statement contains a <code>WHERE</code> block,
we'll evaluate the <code>WHERE</code> expression against the current
row and move on if the result is <code>false</code>.</p>
<p>Otherwise for each expression in the <code>SELECT</code> list of items
we'll evaluate it against the current row in the table.</p>
<p>If there is no table selected, we provide a fake table with a single
empty row.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">mb</span><span class="w"> </span><span class="o">*</span><span class="nx">MemoryBackend</span><span class="p">)</span><span class="w"> </span><span class="nx">Select</span><span class="p">(</span><span class="nx">slct</span><span class="w"> </span><span class="o">*</span><span class="nx">SelectStatement</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">Results</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">table</span><span class="p">{}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">slct</span><span class="p">.</span><span class="nx">from</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">slct</span><span class="p">.</span><span class="nx">from</span><span class="p">.</span><span class="nx">table</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">var</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="kt">bool</span>
<span class="w">        </span><span class="nx">t</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">mb</span><span class="p">.</span><span class="nx">tables</span><span class="p">[</span><span class="nx">slct</span><span class="p">.</span><span class="nx">from</span><span class="p">.</span><span class="nx">table</span><span class="p">.</span><span class="nx">value</span><span class="p">]</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">ErrTableDoesNotExist</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">slct</span><span class="p">.</span><span class="nx">item</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">slct</span><span class="p">.</span><span class="nx">item</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Results</span><span class="p">{},</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">results</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[][]</span><span class="nx">Cell</span><span class="p">{}</span>
<span class="w">    </span><span class="nx">columns</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">Type</span><span class="w"> </span><span class="nx">ColumnType</span>
<span class="w">        </span><span class="nx">Name</span><span class="w"> </span><span class="kt">string</span>
<span class="w">    </span><span class="p">}{}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">slct</span><span class="p">.</span><span class="nx">from</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">t</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">table</span><span class="p">{}</span>
<span class="w">        </span><span class="nx">t</span><span class="p">.</span><span class="nx">rows</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[][]</span><span class="nx">MemoryCell</span><span class="p">{{}}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">rows</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="nx">Cell</span><span class="p">{}</span>
<span class="w">        </span><span class="nx">isFirstRow</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">results</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">slct</span><span class="p">.</span><span class="nx">where</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">val</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">evaluateCell</span><span class="p">(</span><span class="nb">uint</span><span class="p">(</span><span class="nx">i</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="nx">slct</span><span class="p">.</span><span class="nx">where</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">val</span><span class="p">.</span><span class="nx">AsBool</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">continue</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="o">*</span><span class="nx">slct</span><span class="p">.</span><span class="nx">item</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">col</span><span class="p">.</span><span class="nx">asterisk</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// TODO: handle asterisk</span>
<span class="w">                </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Skipping asterisk.&quot;</span><span class="p">)</span>
<span class="w">                </span><span class="k">continue</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="nx">columnName</span><span class="p">,</span><span class="w"> </span><span class="nx">columnType</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">evaluateCell</span><span class="p">(</span><span class="nb">uint</span><span class="p">(</span><span class="nx">i</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="nx">col</span><span class="p">.</span><span class="nx">exp</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">isFirstRow</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">columns</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">columns</span><span class="p">,</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="nx">Type</span><span class="w"> </span><span class="nx">ColumnType</span>
<span class="w">                    </span><span class="nx">Name</span><span class="w"> </span><span class="kt">string</span>
<span class="w">                </span><span class="p">}{</span>
<span class="w">                    </span><span class="nx">Type</span><span class="p">:</span><span class="w"> </span><span class="nx">columnType</span><span class="p">,</span>
<span class="w">                    </span><span class="nx">Name</span><span class="p">:</span><span class="w"> </span><span class="nx">columnName</span><span class="p">,</span>
<span class="w">                </span><span class="p">})</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="nx">result</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nx">results</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">results</span><span class="p">,</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Results</span><span class="p">{</span>
<span class="w">        </span><span class="nx">Columns</span><span class="p">:</span><span class="w"> </span><span class="nx">columns</span><span class="p">,</span>
<span class="w">        </span><span class="nx">Rows</span><span class="p">:</span><span class="w">    </span><span class="nx">results</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span><span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
<h3 id="implementing-insert,-create">Implementing INSERT, CREATE</h3><p>The <code>INSERT</code> and <code>CREATE</code> statements stay mostly
the same except for that we'll use the <code>evaluateCell</code> help
for every expression. Refer back to the first post if the
implementation is otherwise unclear.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">mb</span><span class="w"> </span><span class="o">*</span><span class="nx">MemoryBackend</span><span class="p">)</span><span class="w"> </span><span class="nx">Insert</span><span class="p">(</span><span class="nx">inst</span><span class="w"> </span><span class="o">*</span><span class="nx">InsertStatement</span><span class="p">)</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">t</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">mb</span><span class="p">.</span><span class="nx">tables</span><span class="p">[</span><span class="nx">inst</span><span class="p">.</span><span class="nx">table</span><span class="p">.</span><span class="nx">value</span><span class="p">]</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">ErrTableDoesNotExist</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">inst</span><span class="p">.</span><span class="nx">values</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">row</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="nx">MemoryCell</span><span class="p">{}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">inst</span><span class="p">.</span><span class="nx">values</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">columns</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">ErrMissingValues</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="o">*</span><span class="nx">inst</span><span class="p">.</span><span class="nx">values</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">value</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">literalKind</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Skipping non-literal.&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="k">continue</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nx">emptyTable</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">table</span><span class="p">{}</span>
<span class="w">        </span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">emptyTable</span><span class="p">.</span><span class="nx">evaluateCell</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="nx">value</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">err</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nx">row</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">t</span><span class="p">.</span><span class="nx">rows</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">rows</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">mb</span><span class="w"> </span><span class="o">*</span><span class="nx">MemoryBackend</span><span class="p">)</span><span class="w"> </span><span class="nx">CreateTable</span><span class="p">(</span><span class="nx">crt</span><span class="w"> </span><span class="o">*</span><span class="nx">CreateTableStatement</span><span class="p">)</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">table</span><span class="p">{}</span>
<span class="w">    </span><span class="nx">mb</span><span class="p">.</span><span class="nx">tables</span><span class="p">[</span><span class="nx">crt</span><span class="p">.</span><span class="nx">name</span><span class="p">.</span><span class="nx">value</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">t</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">crt</span><span class="p">.</span><span class="nx">cols</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="o">*</span><span class="nx">crt</span><span class="p">.</span><span class="nx">cols</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">t</span><span class="p">.</span><span class="nx">columns</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">columns</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="p">.</span><span class="nx">name</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>

<span class="w">        </span><span class="kd">var</span><span class="w"> </span><span class="nx">dt</span><span class="w"> </span><span class="nx">ColumnType</span>
<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="nx">col</span><span class="p">.</span><span class="nx">datatype</span><span class="p">.</span><span class="nx">value</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="s">&quot;int&quot;</span><span class="p">:</span>
<span class="w">            </span><span class="nx">dt</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">IntType</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="s">&quot;text&quot;</span><span class="p">:</span>
<span class="w">            </span><span class="nx">dt</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">TextType</span>
<span class="w">        </span><span class="k">default</span><span class="p">:</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">ErrInvalidDatatype</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nx">t</span><span class="p">.</span><span class="nx">columnTypes</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">columnTypes</span><span class="p">,</span><span class="w"> </span><span class="nx">dt</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
<h3 id="back-to-the-repl">Back to the REPL</h3><p>Putting it all together, we run the following session:</p>
<div class="highlight"><pre><span></span><span class="err">#</span><span class="w"> </span><span class="nx">CREATE</span><span class="w"> </span><span class="nx">TABLE</span><span class="w"> </span><span class="nx">users</span><span class="w"> </span><span class="p">(</span><span class="nx">name</span><span class="w"> </span><span class="nx">TEXT</span><span class="p">,</span><span class="w"> </span><span class="nx">age</span><span class="w"> </span><span class="nx">INT</span><span class="p">);</span>
<span class="nx">ok</span>
<span class="err">#</span><span class="w">  </span><span class="nx">INSERT</span><span class="w"> </span><span class="nx">INTO</span><span class="w"> </span><span class="nx">users</span><span class="w"> </span><span class="nx">VALUES</span><span class="w"> </span><span class="p">(</span><span class="err">&#39;</span><span class="nx">Stephen</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span>
<span class="nx">ok</span>
<span class="err">#</span><span class="w"> </span><span class="nx">SELECT</span><span class="w"> </span><span class="nx">name</span><span class="p">,</span><span class="w"> </span><span class="nx">age</span><span class="w"> </span><span class="nx">FROM</span><span class="w"> </span><span class="nx">users</span><span class="p">;</span>
<span class="nx">name</span><span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="nx">age</span>
<span class="o">----------+------</span>
<span class="nx">Stephen</span><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="mi">16</span>
<span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span>
<span class="nx">ok</span>
<span class="err">#</span><span class="w"> </span><span class="nx">INSERT</span><span class="w"> </span><span class="nx">INTO</span><span class="w"> </span><span class="nx">users</span><span class="w"> </span><span class="nx">VALUES</span><span class="w"> </span><span class="p">(</span><span class="err">&#39;</span><span class="nx">Adrienne</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">23</span><span class="p">);</span>
<span class="nx">ok</span>
<span class="err">#</span><span class="w"> </span><span class="nx">SELECT</span><span class="w"> </span><span class="nx">age</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">FROM</span><span class="w"> </span><span class="nx">users</span><span class="w"> </span><span class="nx">WHERE</span><span class="w"> </span><span class="nx">age</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">23</span><span class="p">;</span>
<span class="nx">age</span><span class="w"> </span><span class="o">|</span><span class="w">   </span><span class="nx">name</span>
<span class="o">------+-----------</span>
<span class="mi">25</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">Adrienne</span>
<span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span>
<span class="nx">ok</span>
<span class="err">#</span><span class="w"> </span><span class="nx">SELECT</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">FROM</span><span class="w"> </span><span class="nx">users</span><span class="p">;</span>
<span class="nx">name</span>
<span class="o">------------</span>
<span class="nx">Stephen</span>
<span class="nx">Adrienne</span>
<span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="nx">results</span><span class="p">)</span>
<span class="nx">ok</span>
</pre></div>
<p>And that's it for now! In future posts we'll get into indices, joining
tables, etc.</p>
<p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">Latest post up in the database basics series: adding support for binary expressions and WHERE filtering in SELECTs.<br><br>Much nicer to have a real table rendering library and readline implementation in the REPL too.<a href="https://t.co/GYzn3FUNon">https://t.co/GYzn3FUNon</a></p>&mdash; Phil Eaton (@phil_eaton) <a href="https://twitter.com/phil_eaton/status/1249426633347473408?ref_src=twsrc%5Etfw">April 12, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>
<style>.feedback{display:initial;}</style>
	<div class="feedback">
	  <h4>Feedback</h4>
	  <p><small>As always,
	      please <a href="mailto:phil@eatonphil.com">email</a>
	      or <a href="https://twitter.com/eatonphil">tweet me</a>
	      with questions, corrections, or ideas!</small></p>

	</div>
      </div>
    </div>
    <footer>
      <div class="container">
	<div>
	  <div class="row">
	    <div class="feedback">
	      <h4>Frequent Topics</h4>
	      <div class="tags"><a href="/tags/javascript.html" class="tag">javascript (24)</a><a href="/tags/parsing.html" class="tag">parsing (21)</a><a href="/tags/databases.html" class="tag">databases (19)</a><a href="/tags/golang.html" class="tag">golang (14)</a><a href="/tags/compilers.html" class="tag">compilers (14)</a><a href="/tags/postgres.html" class="tag">postgres (13)</a><a href="/tags/sql.html" class="tag">sql (10)</a><a href="/tags/interpreters.html" class="tag">interpreters (10)</a><a href="/tags/lisp.html" class="tag">lisp (9)</a><a href="/tags/books.html" class="tag">books (9)</a><a href="/tags/python.html" class="tag">python (8)</a><a href="/tags/go.html" class="tag">go (8)</a><a href="/tags/zig.html" class="tag">zig (7)</a><a href="/tags/management.html" class="tag">management (7)</a><a href="/tags/json.html" class="tag">json (7)</a><a href="/tags/linux.html" class="tag">linux (6)</a><a href="/tags/x86-amd64.html" class="tag">x86/amd64 (5)</a><a href="/tags/typescript.html" class="tag">typescript (5)</a><a href="/tags/scheme.html" class="tag">scheme (5)</a><a href="/tags/learning.html" class="tag">learning (5)</a></div>
	    </div>
	  </div>
	  <div class="row" id="subscribe">
	    <style type="text/css">
  /* LOADER */
  .ml-form-embedSubmitLoad {
      display: inline-block;
      width: 20px;
      height: 20px;
  }
  .g-recaptcha {
      transform: scale(1);
      -webkit-transform: scale(1);
      transform-origin: 0 0;
      -webkit-transform-origin: 0 0;
      height: ;
  }
  .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0,0,0,0);
      border: 0;
  }
  .ml-form-embedSubmitLoad:after {
      content: " ";
      display: block;
      width: 11px;
      height: 11px;
      margin: 1px;
      border-radius: 50%;
      border: 4px solid #fff;
      border-color: #ffffff #ffffff #ffffff transparent;
      animation: ml-form-embedSubmitLoad 1.2s linear infinite;
  }
  @keyframes ml-form-embedSubmitLoad {
      0% {
          transform: rotate(0deg);
      }
      100% {
          transform: rotate(360deg);
      }
  }
  #mlb2-3175296.ml-form-embedContainer {
      box-sizing: border-box;
      display: table;
      margin: 0 auto;
      position: static;
      width: 100% !important;
  }
  #mlb2-3175296.ml-form-embedContainer h3,
  #mlb2-3175296.ml-form-embedContainer p,
  #mlb2-3175296.ml-form-embedContainer span,
  #mlb2-3175296.ml-form-embedContainer button {
      text-transform: none !important;
      letter-spacing: normal !important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper {
      border-width: 0px;
      border-color: transparent;
  border-radius: 4px;
  border-style: solid;
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  position: relative;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-align-left { text-align: left; }
  #mlb2-3175296.ml-form-embedContainer .ml-form-align-center {
  text-align: center;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-align-default { display: table-cell !important; vertical-align: middle !important; text-align: center !important; }
  #mlb2-3175296.ml-form-embedContainer .ml-form-align-right { text-align: right; }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedHeader img {
  border-top-left-radius: 4px;
  border-top-right-radius: 4px;
  height: auto;
  margin: 0 auto !important;
  max-width: 100%;
  width: undefinedpx;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody.ml-form-embedBodyHorizontal {
  padding-bottom: 0;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent {
  text-align: left;
  margin: 0 0 20px 0;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent p,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent p {
  color: #000000;
  font-size: 14px;
  font-weight: 400;
  line-height: 20px;
  margin: 0 0 10px 0;
  text-align: left;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent ul,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent ol,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent ul,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent ol {
  color: #000000;
  font-size: 14px;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent ol ol,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent ol ol {
  list-style-type: lower-alpha;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent ol ol ol,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent ol ol ol {
  list-style-type: lower-roman;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent p a,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent p a {
  color: #000000;
  text-decoration: underline;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-block-form .ml-field-group {
  text-align: left!important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-block-form .ml-field-group label {
  margin-bottom: 5px;
  color: #333333;
  font-size: 14px;
  font-weight: bold; font-style: normal; text-decoration: none;;
  display: inline-block;
  line-height: 20px;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent p:last-child,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent p:last-child {
  margin: 0;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody form {
  margin: 0;
  width: 100%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-formContent,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow {
  margin: 0 0 20px 0;
  width: 100%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow {
  float: left;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-formContent.horozintalForm {
  margin: 0;
  padding: 0 0 20px 0;
  width: 100%;
  height: auto;
  float: left;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow {
  margin: 0 0 10px 0;
  width: 100%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow.ml-last-item {
  margin: 0;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow.ml-formfieldHorizintal {
  margin: 0;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow input {
  background-color: #ffffff !important;
  color: #333333 !important;
  border-color: #cccccc;
  border-radius: 4px !important;
  border-style: solid !important;
  border-width: 1px !important;
  font-size: 14px !important;
  height: auto;
  line-height: 21px !important;
  margin-bottom: 0;
  margin-top: 0;
  margin-left: 0;
  margin-right: 0;
  padding: 10px 10px !important;
  width: 100% !important;
  box-sizing: border-box !important;
  max-width: 100% !important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow input::-webkit-input-placeholder,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow input::-webkit-input-placeholder { color: #333333; }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow input::-moz-placeholder,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow input::-moz-placeholder { color: #333333; }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow input:-ms-input-placeholder,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow input:-ms-input-placeholder { color: #333333; }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow input:-moz-placeholder,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow input:-moz-placeholder { color: #333333; }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow textarea, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow textarea {
  background-color: #ffffff !important;
  color: #333333 !important;
  border-color: #cccccc;
  border-radius: 4px !important;
  border-style: solid !important;
  border-width: 1px !important;
  font-size: 14px !important;
  height: auto;
  line-height: 21px !important;
  margin-bottom: 0;
  margin-top: 0;
  padding: 10px 10px !important;
  width: 100% !important;
  box-sizing: border-box !important;
  max-width: 100% !important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-radio .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::before {
  border-color: #cccccc!important;
  background-color: #ffffff!important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow input.custom-control-input[type="checkbox"]{
  box-sizing: border-box;
  padding: 0;
  position: absolute;
  z-index: -1;
  opacity: 0;
  margin-top: 5px;
  margin-left: -1.5rem;
  overflow: visible;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::before {
  border-radius: 4px!important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow input[type=checkbox]:checked~.label-description::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox input[type=checkbox]:checked~.label-description::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-input:checked~.custom-control-label::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-input:checked~.custom-control-label::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox input[type=checkbox]:checked~.label-description::after {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8'%3e%3cpath fill='%23fff' d='M6.564.75l-3.59 3.612-1.538-1.55L0 4.26 2.974 7.25 8 2.193z'/%3e%3c/svg%3e");
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-input:checked~.custom-control-label::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-input:checked~.custom-control-label::after {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='3' fill='%23fff'/%3e%3c/svg%3e");
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-input:checked~.custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-radio .custom-control-input:checked~.custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-input:checked~.custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-input:checked~.custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox input[type=checkbox]:checked~.label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox input[type=checkbox]:checked~.label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow input[type=checkbox]:checked~.label-description::before  {
  border-color: #000000!important;
  background-color: #000000!important;
  color: #ffffff!important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-radio .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-label::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-radio .custom-control-label::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-label::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-label::after {
  top: 2px;
  box-sizing: border-box;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox .label-description::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::after {
  top: 0px!important;
  box-sizing: border-box!important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::after {
  top: 0px!important;
  box-sizing: border-box!important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox .label-description::after {
  top: 0px!important;
  box-sizing: border-box!important;
  position: absolute;
  left: -1.5rem;
  display: block;
  width: 1rem;
  height: 1rem;
  content: "";
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox .label-description::before {
  top: 0px!important;
  box-sizing: border-box!important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .custom-control-label::before {
  position: absolute;
  top: 4px;
  left: -1.5rem;
  display: block;
  width: 16px;
  height: 16px;
  pointer-events: none;
  content: "";
  background-color: #ffffff;
  border: #adb5bd solid 1px;
  border-radius: 50%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .custom-control-label::after {
  position: absolute;
  top: 2px!important;
  left: -1.5rem;
  display: block;
  width: 1rem;
  height: 1rem;
  content: "";
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::before {
  position: absolute;
  top: 4px;
  left: -1.5rem;
  display: block;
  width: 16px;
  height: 16px;
  pointer-events: none;
  content: "";
  background-color: #ffffff;
  border: #adb5bd solid 1px;
  border-radius: 50%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox .label-description::after {
  position: absolute;
  top: 0px!important;
  left: -1.5rem;
  display: block;
  width: 1rem;
  height: 1rem;
  content: "";
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::after {
  position: absolute;
  top: 0px!important;
  left: -1.5rem;
  display: block;
  width: 1rem;
  height: 1rem;
  content: "";
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .custom-radio .custom-control-label::after {
  background: no-repeat 50%/50% 50%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .custom-checkbox .custom-control-label::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox .label-description::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox .label-description::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::after {
  background: no-repeat 50%/50% 50%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-control, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-control {
  position: relative;
  display: block;
  min-height: 1.5rem;
  padding-left: 1.5rem;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-input, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-radio .custom-control-input, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-input, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-input {
  position: absolute;
  z-index: -1;
  opacity: 0;
  box-sizing: border-box;
  padding: 0;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-label, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-radio .custom-control-label, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-label, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-label {
  color: #000000;
  font-size: 12px!important;
  line-height: 22px;
  margin-bottom: 0;
  position: relative;
  vertical-align: top;
  font-style: normal;
  font-weight: 700;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-select, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-select {
  background-color: #ffffff !important;
  color: #333333 !important;
  border-color: #cccccc;
  border-radius: 4px !important;
  border-style: solid !important;
  border-width: 1px !important;
  font-size: 14px !important;
  line-height: 20px !important;
  margin-bottom: 0;
  margin-top: 0;
  padding: 10px 28px 10px 12px !important;
  width: 100% !important;
  box-sizing: border-box !important;
  max-width: 100% !important;
  height: auto;
  display: inline-block;
  vertical-align: middle;
  background: url('https://assets.mlcdn.com/ml/images/default/dropdown.svg') no-repeat right .75rem center/8px 10px;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow {
  height: auto;
  width: 100%;
  float: left;
  }
  .ml-form-formContent.horozintalForm .ml-form-horizontalRow .ml-input-horizontal { width: 70%; float: left; }
  .ml-form-formContent.horozintalForm .ml-form-horizontalRow .ml-button-horizontal { width: 30%; float: left; }
  .ml-form-formContent.horozintalForm .ml-form-horizontalRow .ml-button-horizontal.labelsOn { padding-top: 25px;  }
  .ml-form-formContent.horozintalForm .ml-form-horizontalRow .horizontal-fields { box-sizing: border-box; float: left; padding-right: 10px;  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow input {
  background-color: #ffffff;
  color: #333333;
  border-color: #cccccc;
  border-radius: 4px;
  border-style: solid;
  border-width: 1px;
  font-size: 14px;
  line-height: 20px;
  margin-bottom: 0;
  margin-top: 0;
  padding: 10px 10px;
  width: 100%;
  box-sizing: border-box;
  overflow-y: initial;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow button {
  background-color: #000000 !important;
  border-color: #000000;
  border-style: solid;
  border-width: 1px;
  border-radius: 4px;
  box-shadow: none;
  color: #ffffff !important;
  cursor: pointer;
  font-size: 14px !important;
  font-weight: 700;
  line-height: 20px;
  margin: 0 !important;
  padding: 10px !important;
  width: 100%;
  height: auto;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow button:hover {
  background-color: #333333 !important;
  border-color: #333333 !important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
  position: absolute;
  z-index: -1;
  opacity: 0;
  margin-top: 5px;
  margin-left: -1.5rem;
  overflow: visible;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description {
  color: #000000;
  display: block;
  font-size: 12px;
  text-align: left;
  margin-bottom: 0;
  position: relative;
  vertical-align: top;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow label {
  font-weight: normal;
  margin: 0;
  padding: 0;
  position: relative;
  display: block;
  min-height: 24px;
  padding-left: 24px;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow label a {
  color: #000000;
  text-decoration: underline;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow label p {
  color: #000000 !important;
  font-size: 12px !important;
  font-weight: normal !important;
  line-height: 18px !important;
  padding: 0 !important;
  margin: 0 5px 0 0 !important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow label p:last-child {
  margin: 0;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedSubmit {
  margin: 0 0 20px 0;
  float: left;
  width: 100%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedSubmit button {
  background-color: #000000 !important;
  border: none !important;
  border-radius: 4px !important;
  box-shadow: none !important;
  color: #ffffff !important;
  cursor: pointer;
  font-size: 14px !important;
  font-weight: 700 !important;
  line-height: 21px !important;
  height: auto;
  padding: 10px !important;
  width: 100% !important;
  box-sizing: border-box !important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedSubmit button.loading {
  display: none;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedSubmit button:hover {
  background-color: #333333 !important;
  }
  .ml-subscribe-close {
  width: 30px;
  height: 30px;
  background: url('https://assets.mlcdn.com/ml/images/default/modal_close.png') no-repeat;
  background-size: 30px;
  cursor: pointer;
  margin-top: -10px;
  margin-right: -10px;
  position: absolute;
  top: 0;
  right: 0;
  }
  .ml-error input, .ml-error textarea, .ml-error select {
  border-color: red!important;
  }
  .ml-error .custom-checkbox-radio-list {
  border: 1px solid red !important;
  border-radius: 4px;
  padding: 10px;
  }
  .ml-error .label-description,
  .ml-error .label-description p,
  .ml-error .label-description p a,
  .ml-error label:first-child {
  color: #ff0000 !important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow.ml-error .label-description p,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow.ml-error .label-description p:first-letter {
  color: #ff0000 !important;
  }
  @media only screen and (max-width: 400px){
  .ml-form-embedWrapper.embedDefault, .ml-form-embedWrapper.embedPopup { width: 100%!important; }
  .ml-form-formContent.horozintalForm { float: left!important; }
  .ml-form-formContent.horozintalForm .ml-form-horizontalRow { height: auto!important; width: 100%!important; float: left!important; }
  .ml-form-formContent.horozintalForm .ml-form-horizontalRow .ml-input-horizontal { width: 100%!important; }
  .ml-form-formContent.horozintalForm .ml-form-horizontalRow .ml-input-horizontal > div { padding-right: 0px!important; padding-bottom: 10px; }
    .ml-form-formContent.horozintalForm .ml-button-horizontal { width: 100%!important; }
    .ml-form-formContent.horozintalForm .ml-button-horizontal.labelsOn { padding-top: 0px!important; }
    }
</style>
<div id="mlb2-3175296" class="ml-form-embedContainer ml-subscribe-form ml-subscribe-form-3175296">
  <hr />
  <div class="ml-form-align-center ">
    <div class="ml-form-embedWrapper embedForm">
      <div class="ml-form-embedBody ml-form-embedBodyDefault row-form">
        <div class="ml-form-embedContent" style=" ">
          <h4>Subscribe</h4>
          <p>Enter your email if you'd like to be kept in the loop about future articles!<br><br>You can expect 2 to 4 messages per month depending on how motivated I'm feeling. :)</p>
	  <p></p>
	  <p>Cheers,<br>Phil</p>
        </div>
        <form class="ml-block-form" action="https://assets.mailerlite.com/jsonp/303114/forms/78235486326359572/subscribe" data-code="" method="post" target="_blank">
          <div class="ml-form-formContent">
            <div class="ml-form-fieldRow ml-last-item">
              <div class="ml-field-group ml-field-email ml-validate-email ml-validate-required">
                <!-- input -->
                <input aria-label="email" aria-required="true" type="email" class="form-control" data-inputmask="" name="fields[email]" placeholder="Email" autocomplete="email">
                <!-- /input -->
                <!-- textarea -->
                <!-- /textarea -->
                <!-- select -->
                <!-- /select -->
                <!-- checkboxes -->
		<!-- /checkboxes -->
                <!-- radio -->
                <!-- /radio -->
                <!-- countries -->
                <!-- /countries -->
              </div>
            </div>
          </div>
          <!-- Privacy policy -->
          <!-- /Privacy policy -->
	  <div class="ml-form-recaptcha ml-validate-required" style="float: left;">
            <style type="text/css">
	      .ml-form-recaptcha {
		  margin-bottom: 20px;
	      }
	      .ml-form-recaptcha.ml-error iframe {
		  border: solid 1px #ff0000;
	      }
	      @media screen and (max-width: 480px) {
		  .ml-form-recaptcha {
		      width: 220px!important
		  }
		  .g-recaptcha {
		      transform: scale(0.78);
		      -webkit-transform: scale(0.78);
		      transform-origin: 0 0;
		      -webkit-transform-origin: 0 0;
		  }
	      }
	    </style>
	    <script src="https://www.google.com/recaptcha/api.js"></script>
	    <div class="g-recaptcha" data-sitekey="6Lf1KHQUAAAAAFNKEX1hdSWCS3mRMv4FlFaNslaD"></div>
	  </div>
          <input type="hidden" name="ml-submit" value="1">
          <div class="ml-form-embedSubmit">
            <button type="submit" class="primary">Subscribe</button>
            <button disabled="disabled" style="display: none;" type="button" class="loading">
              <div class="ml-form-embedSubmitLoad"></div>
              <span class="sr-only">Loading...</span>
            </button>
          </div>
          <input type="hidden" name="anticsrf" value="true">
        </form>
      </div>
      <div class="ml-form-successBody row-success" style="display: none">
        <div class="ml-form-successContent">
          <h3>Thanks :)</h3>
          <p>You're in.</p>
        </div>
      </div>
    </div>
  </div>
</div>
<script>
  function ml_webform_success_3175296() {
      var $ = ml_jQuery || jQuery;
      $('.ml-subscribe-form-3175296 .row-success').show();
      $('.ml-subscribe-form-3175296 .row-form').hide();
  }
</script>
<script src="https://groot.mailerlite.com/js/w/webforms.min.js?v300817f630ad0e957914d0b28a2b6d78" type="text/javascript"></script>

	  </div>
	  <div class="row" style="margin-bottom: 25px">
	    <small>Having trouble subscribing? <a href="mailto:phil@eatonphil.com">Let me know</a>.</small>
	  </div>
	</div>
      </div>
    </footer>
    <script async onload="loadGA()" src="https://www.googletagmanager.com/gtag/js?id=UA-58109156-2"></script>
    <script>
      function loadGA() {
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());
	  gtag('config', 'UA-58109156-2');
      }
    </script>
    <script defer src="https://cdn.usefathom.com/script.js" data-site="CEPUOLOQ"></script>
  </body>
</html>
