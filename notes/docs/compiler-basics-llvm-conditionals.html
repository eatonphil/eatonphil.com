<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="canonical" href="https://notes.eatonphil.com/compiler-basics-llvm-conditionals.html">
    <title>Writing a lisp compiler from scratch in JavaScript: 4. LLVM conditionals and compiling fibonacci | notes.eatonphil.com</title>
    <meta name="description" content="Writing a lisp compiler from scratch in JavaScript: 4. LLVM conditionals and compiling fibonacci" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono">
  </head>
  <body>
    <header>
      <div class="lfw">
	<div class="container">
	  <div class="row">
	    <a href="https://eatonphil.com/30.html">Turning 30, a little fundraiser ðŸŽ‰</a>
	  </div>
	</div>
      </div>
      <div class="container">
        <div>
          <div class="row">
	    <div>
	      <a href="https://eatonphil.com" class="sm-link">
		Home
              </a>
	      <a href="/" class="sm-link">
		Blog
              </a>
	      <a href="/rss.xml" class="sm-link">
		RSS
              </a>
	    </div>

	    <div class="subscribe">
	      <!-- <a href="https://eatonphil.com/hire-me.html">Hire me</a> -->
	      <!--
		  Hardcode link to home page because some pages don't
		  have a subscribe box. Some pages hide the subscribe.
		-->
	      <a href="https://eatonphil.com/subscribe.html">
		Subscribe
	      </a>
            </div>
	  </div>
	  <hr />
	  <div class="">
            <h2>May 4, 2019</h2>
            <h1>Writing a lisp compiler from scratch in JavaScript: 4. LLVM conditionals and compiling fibonacci</h1>
	    
            <div class="row" style="padding-bottom: 5px">
              <div class="tags"><a href="/tags/javascript.html" class="tag">javascript</a><a href="/tags/compilers.html" class="tag">compilers</a><a href="/tags/llvm.html" class="tag">llvm</a><a href="/tags/lisp.html" class="tag">lisp</a></div>
            </div>
	  </div>
	</div>
      </div>
    </header>
    <div class="container">
      <div class="col-6">
	<div class="post">
          <p class="note">
  Previously in compiler basics:
  <! forgive me, for I have sinned >
  <br />
  <a href="/compiler-basics-lisp-to-assembly.html">1. lisp to assembly</a>
  <br />
  <a href="/compiler-basics-functions.html">2. user-defined functions and variables</a>
  <br />
  <a href="/compiler-basics-llvm.html">3. LLVM</a>
  <br />
  Next in compiler basics:
  <br />
  <a href="/compiler-basics-llvm-system-calls.html">5. LLVM system calls</a>
  <br />
  <a href="/compiler-basics-an-x86-upgrade.html">6. an x86 upgrade</a>
</p><p>In this post we'll extend the
<a href="https://github.com/eatonphil/ulisp">compiler</a>'s LLVM backend to
support compiling conditionals such that we can support an
implementation of the fibonacci algorithm.</p>
<p>Specifically we're aiming for the following:</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>cat<span class="w"> </span>tests/fib.lisp
<span class="o">(</span>def<span class="w"> </span>fib<span class="w"> </span><span class="o">(</span>n<span class="o">)</span>
<span class="w">     </span><span class="o">(</span><span class="k">if</span><span class="w"> </span><span class="o">(</span>&lt;<span class="w"> </span>n<span class="w"> </span><span class="m">2</span><span class="o">)</span>
<span class="w">         </span>n
<span class="w">       </span><span class="o">(</span>+<span class="w"> </span><span class="o">(</span>fib<span class="w"> </span><span class="o">(</span>-<span class="w"> </span>n<span class="w"> </span><span class="m">1</span><span class="o">))</span><span class="w"> </span><span class="o">(</span>fib<span class="w"> </span><span class="o">(</span>-<span class="w"> </span>n<span class="w"> </span><span class="m">2</span><span class="o">)))))</span>

<span class="o">(</span>def<span class="w"> </span>main<span class="w"> </span><span class="o">()</span>
<span class="w">     </span><span class="o">(</span>fib<span class="w"> </span><span class="m">8</span><span class="o">))</span>
$<span class="w"> </span>node<span class="w"> </span>src/ulisp.js<span class="w"> </span>tests/fib.lisp
$<span class="w"> </span>./build/prog
$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="nv">$?</span>
<span class="m">21</span>
</pre></div>
<p>To do this we'll have to add the <code><</code>, <code>-</code> and
<code>if</code> built-ins.</p>
<p><a href="https://github.com/eatonphil/ulisp">All source code is available on Github</a>.</p>
<h3 id="subtraction">Subtraction</h3><p>This is the easiest to add since we already support addition. They are
both arithmetic operations that produce an integer. We simply add a
mapping of <code>-</code> to the LLVM instruction <code>sub</code> so
our LLVM backend constructor (<code>src/backends/llvm.js</code>) looks
like this:</p>
<div class="highlight"><pre><span></span><span class="p">...</span>

<span class="kd">class</span><span class="w"> </span><span class="nx">Compiler</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kr">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">outBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">primitiveFunctions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">def</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileDefine</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
<span class="w">      </span><span class="nx">begin</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileBegin</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
<span class="w">      </span><span class="s1">&#39;if&#39;</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileIf</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
<span class="w">      </span><span class="s1">&#39;+&#39;</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileOp</span><span class="p">(</span><span class="s1">&#39;add&#39;</span><span class="p">),</span>
<span class="w">      </span><span class="s1">&#39;-&#39;</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileOp</span><span class="p">(</span><span class="s1">&#39;sub&#39;</span><span class="p">),</span>

<span class="p">...</span>
</pre></div>
<h3 id="less-than">Less than</h3><p>The <code><</code> builtin is a logical operation. These are handled
differently from arithmetic operations in LLVM IR. A logical operation
looks like this:</p>
<div class="highlight"><pre><span></span><span class="nv nv-Anonymous">%3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">slt</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%1</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">%2</span>
</pre></div>
<p>This says that we're doing an integer comparison, <code>icmp</code>,
(with signed less than, <code>slt</code>) on the <code>i32</code>
integers in variables <code>%1</code> and <code>%2</code>.</p>
<p>We can shim this into our existing <code>compileOp</code> helper like
so:</p>
<div class="highlight"><pre><span></span><span class="p">...</span>

<span class="kd">class</span><span class="w"> </span><span class="nx">Compiler</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kr">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">outBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">primitiveFunctions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">def</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileDefine</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
<span class="w">      </span><span class="nx">begin</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileBegin</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
<span class="w">      </span><span class="s1">&#39;if&#39;</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileIf</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
<span class="w">      </span><span class="s1">&#39;+&#39;</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileOp</span><span class="p">(</span><span class="s1">&#39;add&#39;</span><span class="p">),</span>
<span class="w">      </span><span class="s1">&#39;-&#39;</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileOp</span><span class="p">(</span><span class="s1">&#39;sub&#39;</span><span class="p">),</span>
<span class="w">      </span><span class="s1">&#39;&lt;&#39;</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileOp</span><span class="p">(</span><span class="s1">&#39;icmp slt&#39;</span><span class="p">),</span>

<span class="p">...</span>
</pre></div>
<h3 id="conditionals">Conditionals</h3><p>The last part we need to add is support for conditional execution of
code at runtime. Assembly-like languages handle this with "jumps" and
"labels". Jumping causes execution to continue at the address being
jumped to (instead of just the line following the jump
instruction). Labels give you a way of naming an address instead of
having to calculate it yourself. Our code will look vaguely like this:</p>
<div class="highlight"><pre><span></span><span class="w">  </span><span class="nv">%test</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">slt</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">%1</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%test</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%iftrue</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%iffalse</span>
<span class="nl">iftrue:</span>
<span class="w">  </span><span class="c">; do true stuff</span>
<span class="nl">iffalse:</span>
<span class="w">  </span><span class="c">; do false stuff</span>

<span class="w">  </span><span class="c">; do next stuff</span>
</pre></div>
<p>The <code>br</code> instruction can jump (or branch) conditionally or
unconditionally. This snippet demonstrates a conditional jump.</p>
<p>But there are a few things wrong with this pseudo-code. First off if
the condition is true, execution will just continue on into the false
section once finished. Second, LLVM IR actually requires all labels to
end with a branch instruction. So we'll add a new label after the true
and false section called <code>ifresult</code> and jump to it
unconditionally after both.</p>
<div class="highlight"><pre><span></span><span class="w">  </span><span class="nv">%test</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">slt</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">%1</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%test</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%iftrue</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%iffalse</span>
<span class="nl">iftrue:</span>
<span class="w">  </span><span class="c">; do true stuff</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%ifresult</span>
<span class="nl">iffalse:</span>
<span class="w">  </span><span class="c">; do false stuff</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%ifresult</span>
<span class="nl">ifresult:</span>
<span class="w">  </span><span class="c">; do next stuff</span>
</pre></div>
<h3 id="scope">Scope</h3><p>One last thing we'll need to do before implementing the code
generation for this is to update our <code>Scope</code> class to
accept symbol prefixes so we can pass our labels through Scope to make
sure they are unique but still have useful names.</p>
<div class="highlight"><pre><span></span><span class="p">...</span>

<span class="kd">class</span><span class="w"> </span><span class="nx">Scope</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="p">...</span>

<span class="w">  </span><span class="nx">symbol</span><span class="p">(</span><span class="nx">prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;sym&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">nth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">locals</span><span class="p">).</span><span class="nx">length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">register</span><span class="p">(</span><span class="nx">prefix</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">nth</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="p">...</span>
</pre></div>
<h3 id="compileif">compileIf</h3><p>Now we can add a primitive function mapping <code>if</code> to a new
<code>compileIf</code> helper and implement the helper.</p>
<div class="highlight"><pre><span></span><span class="p">...</span>

<span class="kd">class</span><span class="w"> </span><span class="nx">Compiler</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kr">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">outBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">primitiveFunctions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">def</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileDefine</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
<span class="w">      </span><span class="nx">begin</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileBegin</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
<span class="w">      </span><span class="s1">&#39;+&#39;</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileOp</span><span class="p">(</span><span class="s1">&#39;add&#39;</span><span class="p">),</span>
<span class="w">      </span><span class="s1">&#39;-&#39;</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileOp</span><span class="p">(</span><span class="s1">&#39;sub&#39;</span><span class="p">),</span>
<span class="w">      </span><span class="s1">&#39;&lt;&#39;</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileOp</span><span class="p">(</span><span class="s1">&#39;icmp slt&#39;</span><span class="p">),</span>
<span class="w">      </span><span class="s1">&#39;if&#39;</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">compileIf</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>

<span class="p">...</span>

<span class="w">  </span><span class="nx">compileIf</span><span class="p">([</span><span class="nx">test</span><span class="p">,</span><span class="w"> </span><span class="nx">thenBlock</span><span class="p">,</span><span class="w"> </span><span class="nx">elseBlock</span><span class="p">],</span><span class="w"> </span><span class="nx">destination</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">testVariable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">scope</span><span class="p">.</span><span class="nx">symbol</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Compile expression and branch</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">test</span><span class="p">,</span><span class="w"> </span><span class="nx">testVariable</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">);</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">trueLabel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">scope</span><span class="p">.</span><span class="nx">symbol</span><span class="p">(</span><span class="s1">&#39;iftrue&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">falseLabel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">scope</span><span class="p">.</span><span class="nx">symbol</span><span class="p">(</span><span class="s1">&#39;iffalse&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="sb">`br i1 %</span><span class="si">${</span><span class="nx">testVariable</span><span class="si">}</span><span class="sb">, label %</span><span class="si">${</span><span class="nx">trueLabel</span><span class="si">}</span><span class="sb">, label %</span><span class="si">${</span><span class="nx">falseLabel</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Compile true section</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">trueLabel</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39;:&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">thenBlock</span><span class="p">,</span><span class="w"> </span><span class="nx">destination</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">);</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">endLabel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">scope</span><span class="p">.</span><span class="nx">symbol</span><span class="p">(</span><span class="s1">&#39;ifend&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;br label %&#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">endLabel</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">falseLabel</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39;:&#39;</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Compile false section</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">elseBlock</span><span class="p">,</span><span class="w"> </span><span class="nx">destination</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;br label %&#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">endLabel</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Compile cleanup</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">endLabel</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39;:&#39;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">...</span>
</pre></div>
<p>Note that this code generation sends the <code>destination<code>
variable into both the true and false sections. Let's try it out.</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>node<span class="w"> </span>src/ulisp.js<span class="w"> </span>tests/fib.lisp
llc:<span class="w"> </span>error:<span class="w"> </span>llc:<span class="w"> </span>build/prog.ll:19:3:<span class="w"> </span>error:<span class="w"> </span>multiple<span class="w"> </span>definition<span class="w"> </span>of<span class="w"> </span><span class="nb">local</span><span class="w"> </span>value<span class="w"> </span>named<span class="w"> </span><span class="s1">&#39;sym5&#39;</span>
<span class="w">  </span>%sym5<span class="w"> </span><span class="o">=</span><span class="w"> </span>add<span class="w"> </span>i32<span class="w"> </span>%sym15,<span class="w"> </span>%sym16
<span class="w">  </span>^
child_process.js:665
<span class="w">    </span>throw<span class="w"> </span>err<span class="p">;</span>
<span class="w">    </span>^

Error:<span class="w"> </span>Command<span class="w"> </span>failed:<span class="w"> </span>llc<span class="w"> </span>-o<span class="w"> </span>build/prog.s<span class="w"> </span>build/prog.ll
llc:<span class="w"> </span>error:<span class="w"> </span>llc:<span class="w"> </span>build/prog.ll:19:3:<span class="w"> </span>error:<span class="w"> </span>multiple<span class="w"> </span>definition<span class="w"> </span>of<span class="w"> </span><span class="nb">local</span><span class="w"> </span>value<span class="w"> </span>named<span class="w"> </span><span class="s1">&#39;sym5&#39;</span>
<span class="w">  </span>%sym5<span class="w"> </span><span class="o">=</span><span class="w"> </span>add<span class="w"> </span>i32<span class="w"> </span>%sym15,<span class="w"> </span>%sym16
</pre></div>
<p>That's annoying. An unfortunate aspect of LLVM's required
single-static assignment form is that you cannot reuse variable names
within a function even if it is not possible for the variable to be
actually reused.</p>
<p>To work around this we need to allocate memory on the stack, store the
result in each true/false section in this location, and read from this
location afterward to store it in the destination variable.</p>
<h3 id="stack-memory-instructions">Stack memory instructions</h3><p>LLVM IR gives us <code>alloca</code> to allocate memory on the stack,
<code>store</code> to store memory at a stack address, and
<code>load</code> to read the value at a stack address into a
variable. Here's a simple example:</p>
<div class="highlight"><pre><span></span><span class="nv">%myvar</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">42</span><span class="p">,</span><span class="w"> </span><span class="m">0</span>
<span class="nv">%stackaddress</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%myvar</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%stackaddress</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="nv">%newvar</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%stackaddress</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
</pre></div>
<p>Such that <code>newvar</code> is now 42.</p>
<h3 id="compileif-again">compileIf again</h3><p>Applying this back to our <code>compileIf</code> helper gives us:</p>
<div class="highlight"><pre><span></span><span class="p">...</span>

<span class="w">  </span><span class="nx">compileIf</span><span class="p">([</span><span class="nx">test</span><span class="p">,</span><span class="w"> </span><span class="nx">thenBlock</span><span class="p">,</span><span class="w"> </span><span class="nx">elseBlock</span><span class="p">],</span><span class="w"> </span><span class="nx">destination</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">testVariable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">scope</span><span class="p">.</span><span class="nx">symbol</span><span class="p">();</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">scope</span><span class="p">.</span><span class="nx">symbol</span><span class="p">(</span><span class="s1">&#39;ifresult&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Space for result</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="sb">`%</span><span class="si">${</span><span class="nx">result</span><span class="si">}</span><span class="sb"> = alloca i32, align 4`</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Compile expression and branch</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">test</span><span class="p">,</span><span class="w"> </span><span class="nx">testVariable</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">);</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">trueLabel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">scope</span><span class="p">.</span><span class="nx">symbol</span><span class="p">(</span><span class="s1">&#39;iftrue&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">falseLabel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">scope</span><span class="p">.</span><span class="nx">symbol</span><span class="p">(</span><span class="s1">&#39;iffalse&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="sb">`br i1 %</span><span class="si">${</span><span class="nx">testVariable</span><span class="si">}</span><span class="sb">, label %</span><span class="si">${</span><span class="nx">trueLabel</span><span class="si">}</span><span class="sb">, label %</span><span class="si">${</span><span class="nx">falseLabel</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Compile true section</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">trueLabel</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39;:&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">tmp1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">scope</span><span class="p">.</span><span class="nx">symbol</span><span class="p">();</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">thenBlock</span><span class="p">,</span><span class="w"> </span><span class="nx">tmp1</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="sb">`store i32 %</span><span class="si">${</span><span class="nx">tmp1</span><span class="si">}</span><span class="sb">, i32* %</span><span class="si">${</span><span class="nx">result</span><span class="si">}</span><span class="sb">, align 4`</span><span class="p">);</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">endLabel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">scope</span><span class="p">.</span><span class="nx">symbol</span><span class="p">(</span><span class="s1">&#39;ifend&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;br label %&#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">endLabel</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">falseLabel</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39;:&#39;</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Compile false section</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">tmp2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">scope</span><span class="p">.</span><span class="nx">symbol</span><span class="p">();</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">compileExpression</span><span class="p">(</span><span class="nx">elseBlock</span><span class="p">,</span><span class="w"> </span><span class="nx">tmp2</span><span class="p">,</span><span class="w"> </span><span class="nx">scope</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="sb">`store i32 %</span><span class="si">${</span><span class="nx">tmp2</span><span class="si">}</span><span class="sb">, i32* %</span><span class="si">${</span><span class="nx">result</span><span class="si">}</span><span class="sb">, align 4`</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;br label %&#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">endLabel</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Compile cleanup</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">endLabel</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39;:&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="sb">`%</span><span class="si">${</span><span class="nx">destination</span><span class="si">}</span><span class="sb"> = load i32, i32* %</span><span class="si">${</span><span class="nx">result</span><span class="si">}</span><span class="sb">, align 4`</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="p">...</span>
</pre></div>
<h3 id="trying-it-out">Trying it out</h3><p>We run our compiler one more time:</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>node<span class="w"> </span>src/ulisp.js<span class="w"> </span>tests/fib.lisp
$<span class="w"> </span>./build/prog
$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="nv">$?</span>
<span class="m">21</span>
</pre></div>
<p>And get what we expect!</p>
<h3 id="next-up">Next up</h3><ul>
<li>Tail call optimization</li>
<li>Lists and dynamic memory</li>
<li>Strings?</li>
<li>Foreign function calls?</li>
<li>Self-hosting?</li>
</ul>
<p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">Latest post in the compiler basics series: using LLVM conditionals in compiling a fibonacci program <a href="https://t.co/A72yEDQ8sd">https://t.co/A72yEDQ8sd</a></p>&mdash; Phil Eaton (@phil_eaton) <a href="https://twitter.com/phil_eaton/status/1125072731408666624?ref_src=twsrc%5Etfw">May 5, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>
<style>.feedback{display:initial;}</style>
	</div>
	<div class="feedback">
	  <h4>Feedback</h4>
	  <p>As always,
	      please <a href="mailto:phil@eatonphil.com">email</a>
	      or <a href="https://twitter.com/eatonphil">tweet me</a>
	      with questions, corrections, or ideas!</p>

	</div>
      </div>
    </div>
    <footer>
      <div class="container">
	<div>
	  <div id="subscribe">
	    <iframe src="https://cdn.forms-content-1.sg-form.com/e8ed4c3b-dd46-11f0-b6e6-ce075f2c5f80"/>

	  </div>
	</div>
      </div>
    </footer>
    <script async onload="loadGA()" src="https://www.googletagmanager.com/gtag/js?id=UA-58109156-2"></script>
    <script>
      function loadGA() {
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());
	  gtag('config', 'UA-58109156-2');
      }
    </script>
    <script defer src="https://cdn.usefathom.com/script.js" data-site="CEPUOLOQ"></script>
  </body>
</html>
