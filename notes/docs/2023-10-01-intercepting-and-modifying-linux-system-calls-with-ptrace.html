<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="canonical" href="https://notes.eatonphil.com/2023-10-01-intercepting-and-modifying-linux-system-calls-with-ptrace.html">
    <title>Intercepting and modifying Linux system calls with ptrace | notes.eatonphil.com</title>
    <meta name="description" content="Intercepting and modifying Linux system calls with ptrace" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono">
  </head>
  <body>
    <header>
      <div class="lfw">
	<div class="container">
	  <div class="row">
	    <a href="https://eatonphil.com/30.html">Turning 30, a little fundraiser ðŸŽ‰</a>
	  </div>
	</div>
      </div>
      <div class="container">
        <div>
          <div class="row">
	    <div>
	      <a href="https://eatonphil.com" class="sm-link">
		Home
              </a>
	      <a href="/" class="sm-link">
		Blog
              </a>
	      <a href="/rss.xml" class="sm-link">
		RSS
              </a>
	    </div>

	    <div class="subscribe">
	      <!-- <a href="https://eatonphil.com/hire-me.html">Hire me</a> -->
	      <!--
		  Hardcode link to home page because some pages don't
		  have a subscribe box. Some pages hide the subscribe.
		-->
	      <a href="https://eatonphil.com/subscribe.html">
		Subscribe
	      </a>
            </div>
	  </div>
	  <hr />
	  <div class="">
            <h2>October 1, 2023</h2>
            <h1>Intercepting and modifying Linux system calls with ptrace</h1>
	    
            <div class="row" style="padding-bottom: 5px">
              <div class="tags"><a href="/tags/linux.html" class="tag">linux</a><a href="/tags/x86-amd64.html" class="tag">x86/amd64</a><a href="/tags/databases.html" class="tag">databases</a><a href="/tags/zig.html" class="tag">zig</a><a href="/tags/fault-injection.html" class="tag">fault-injection</a><a href="/tags/ptrace.html" class="tag">ptrace</a></div>
            </div>
	  </div>
	</div>
      </div>
    </header>
    <div class="container">
      <div class="col-6">
	<div class="post">
          <p>How software fails is interesting. But real-world errors can be
infrequent to manifest. <a href="https://course.ece.cmu.edu/~ece749/docs/faultInjectionSurvey.pdf">Fault
injection</a>
is a formal-sounding term that just means: trying to explicitly
trigger errors in the hopes of discovering bad logic, typically
during automated tests.</p>
<p><a href="https://github.com/jepsen-io/jepsen">Jepsen</a>
and <a href="https://github.com/Netflix/chaosmonkey">ChaosMonkey</a> are two
famous examples that help to trigger process and network failure. But
what about disk and filesystem errors?</p>
<p>A few avenues seem worth investigating:</p>
<ul>
<li>A custom FUSE filesystem</li>
<li>An LD_PRELOAD interception layer</li>
<li>A ptrace system call interception layer</li>
<li>A <code>SECCOMP_RET_TRAP</code> interception layer</li>
<li>Or, symbolic analysis a la <a href="https://research.cs.wisc.edu/adsl/Publications/alice-osdi14.html">Alice from University of
Wisconsin-Madison</a></li>
</ul>
<p>I would like to try out FUSE sometime. But LD_PRELOAD layer only works
if IO goes through libc, which won't be the case for all
programs. ptrace is something I've wanted to dig into for years since
learning about
<a href="https://www.usenix.org/system/files/hotcloud19-paper-young.pdf">gvisor</a>.</p>
<p><code>SECCOMP_RET_TRAP</code> doesn't have the same high-level guides that ptrace
does so maybe I'll dig into it later. And symbolic analysis might be
able to detect bad workloads but it also isn't fault injection. Maybe
it's the better idea but fault injection just sounds more fun.</p>
<p>So this particular post will cover intercepting system calls
(syscalls) using ptrace with code written in Zig. Not because readers
will likely write their own code in Zig but because hopefully the Zig
code will be easier for you to read and adapt to your language
compared to if we had to deal with the verbosity and inconvenience of
C.</p>
<p>In the end, we'll be able to intercept and force short (incomplete)
writes in a Go, Python, and C program. Emulating a disk that is having
an issue completing the write. This is a case that isn't common, but
should probably be handled with retries in production code.</p>
<p>This post corresponds roughly to <a href="https://github.com/eatonphil/badio/tree/720c3ee0482e6dcb1dd49d1789bccf86747b7776">this
commit</a>
on GitHub.</p>
<h3 id="a-bad-program">A bad program</h3><p>First off, let's write some code for a program that would exhibit a
short write. Basically, we write to a file and don't check how many
bytes we wrote. This is extremely common code; or at least I've
written it often.</p>
<div class="highlight"><pre><span></span><span class="err">$</span><span class="w"> </span><span class="nx">cat</span><span class="w"> </span><span class="nx">test</span><span class="o">/</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span>
<span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">        </span><span class="s">&quot;os&quot;</span>
<span class="p">)</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">f</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">os</span><span class="p">.</span><span class="nx">OpenFile</span><span class="p">(</span><span class="s">&quot;test.txt&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">os</span><span class="p">.</span><span class="nx">O_RDWR</span><span class="o">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_CREATE</span><span class="o">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_TRUNC</span><span class="p">,</span><span class="w"> </span><span class="mo">0755</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nx">text</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s">&quot;some great stuff&quot;</span>
<span class="w">        </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">f</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">text</span><span class="p">))</span>

<span class="w">        </span><span class="nx">_</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
<p>With this code, if the <code>Write()</code> call doesn't actually succeed in
writing everything, we won't know that. And the file will contain less
than all of <code>some great stuff</code>.</p>
<p>This logical mistake will happen rarely, if ever, on a normal
disk. But it is possible.</p>
<p>Now that we've got an example program in mind, let's see if we can
trigger the logic error.</p>
<h3 id="ptrace">ptrace</h3><p>ptrace is a somewhat cross-platform layer that allows you to intercept
syscalls in a process. You can read and modify memory and registers in
the process, when the syscalls starts and before it finishes.</p>
<p>gdb and strace both use ptrace for their magic.</p>
<p>Google's gvisor that <a href="https://cloud.google.com/run/docs/container-contract">powers various serverless runtimes in Google
Cloud</a> was also
historically based on ptrace (<code>PTRACE_SYSEMU</code> specifically, which we
won't explore much in this post).</p>
<p class="note">
  Interestingly though,
  gvisor <a href="https://gvisor.dev/blog/2023/04/28/systrap-release/">switched
  only this year </a> (2023) to a different default backend for
  trapping system calls. Based
  on <a href="https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt"><code>SECCOMP_RET_TRAP</code></a>.
  <br />
  <br />
  You can get similar vibes
  from <a href="https://www.brendangregg.com/blog/2014-05-11/strace-wow-much-syscall.html">this
  Brendan Gregg post</a> on the dangers of using strace (that is based
  on ptrace) in production.
</p><p>Although ptrace is cross-platform, actually writing
cross-platform-aware code with ptrace can be complex. So this post
assumes amd64/linux.</p>
<h3 id="protocol">Protocol</h3><p>The ptrace protocol is described in the <a href="https://man7.org/linux/man-pages/man2/ptrace.2.html">ptrace
manpage</a>, but
<a href="https://nullprogram.com/blog/2018/06/23/">Chris Wellons</a> and <a href="https://webdocs.cs.ualberta.ca/~paullu/C498/meng.ptrace.slides.pdf">a
University of Alberta
group</a>
also wrote nice introductions. I referenced these three pages
heavily.</p>
<p>Here's what the UAlberta page has to say:</p>
<p><img src="/assets/ptraceprotocol.webp" alt="ptrace&#39;s syscall tracing protocol"></p>
<p>We fork and have the child call <code>PTRACE_TRACEME</code>. Then we handle each
syscall entrance by calling <code>PTRACE_SYSCALL</code> and waiting with <code>wait</code>
until the child has entered the syscall. It is in this moment we can
mess with things.</p>
<h3 id="implementation">Implementation</h3><p>Let's turn that graphic into Zig code.</p>
<div class="highlight"><pre><span></span><span class="kr">const</span><span class="w"> </span><span class="n">std</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@import</span><span class="p">(</span><span class="s">&quot;std&quot;</span><span class="p">);</span>
<span class="kr">const</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@cImport</span><span class="p">({</span>
<span class="w">    </span><span class="nb">@cInclude</span><span class="p">(</span><span class="s">&quot;sys/ptrace.h&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="nb">@cInclude</span><span class="p">(</span><span class="s">&quot;sys/user.h&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="nb">@cInclude</span><span class="p">(</span><span class="s">&quot;sys/wait.h&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="nb">@cInclude</span><span class="p">(</span><span class="s">&quot;errno.h&quot;</span><span class="p">);</span>
<span class="p">});</span>

<span class="kr">const</span><span class="w"> </span><span class="n">cNullPtr</span><span class="o">:</span><span class="w"> </span><span class="o">?*</span><span class="n">anyopaque</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>

<span class="c1">// TODO //</span>

<span class="kr">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">arena</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">heap</span><span class="p">.</span><span class="n">ArenaAllocator</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">std</span><span class="p">.</span><span class="n">heap</span><span class="p">.</span><span class="n">page_allocator</span><span class="p">);</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">arena</span><span class="p">.</span><span class="n">deinit</span><span class="p">();</span>

<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">process</span><span class="p">.</span><span class="n">argsAlloc</span><span class="p">(</span><span class="n">arena</span><span class="p">.</span><span class="n">allocator</span><span class="p">());</span>
<span class="w">    </span><span class="n">std</span><span class="p">.</span><span class="n">debug</span><span class="p">.</span><span class="n">assert</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>

<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">os</span><span class="p">.</span><span class="n">fork</span><span class="p">();</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="p">.</span><span class="n">debug</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;Fork failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{});</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Child process</span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">ptrace</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">PTRACE_TRACEME</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="n">cNullPtr</span><span class="p">,</span><span class="w"> </span><span class="n">cNullPtr</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">process</span><span class="p">.</span><span class="n">execv</span><span class="p">(</span>
<span class="w">            </span><span class="n">arena</span><span class="p">.</span><span class="n">allocator</span><span class="p">(),</span>
<span class="w">            </span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">..],</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Parent process</span>
<span class="w">        </span><span class="kr">const</span><span class="w"> </span><span class="n">childPid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">waitpid</span><span class="p">(</span><span class="n">childPid</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="kr">var</span><span class="w"> </span><span class="n">cm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ChildManager</span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">arena</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arena</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">childPid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">childPid</span><span class="w"> </span><span class="p">};</span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="n">cm</span><span class="p">.</span><span class="n">childInterceptSyscalls</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>So like the graphic suggested, we fork and start a child process. That
means this Zig program should be called like:</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>zig<span class="w"> </span>build-exe<span class="w"> </span>--library<span class="w"> </span>c<span class="w"> </span>main.zig
$<span class="w"> </span>./main<span class="w"> </span>/actual/program/to/intercept<span class="w"> </span>--and<span class="w"> </span>--its<span class="w"> </span>args
</pre></div>
<p>Presumably, as with strace or gdb, we could instead attach to an
already running process with <code>PTRACE_ATTACH</code> or <code>PTRACE_SEIZE</code> (based
on the <a href="https://man7.org/linux/man-pages/man2/ptrace.2.html">ptrace
manpage</a>) rather
than going the <code>PTRACE_TRACEME</code> route. But I haven't tried that out
yet.</p>
<p>With the child ready to be intercepted, we can implement the
<code>ChildManager</code> that actually does the interception.</p>
<h4 id="childmanager">ChildManager</h4><p>The core of the <code>ChildManager</code> is an infinite loop (at least as long
as the child process lives) that waits for the next syscall and then
calls a hook for the sytem call if it exists.</p>
<div class="highlight"><pre><span></span><span class="kr">const</span><span class="w"> </span><span class="n">ChildManager</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">arena</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">std</span><span class="p">.</span><span class="n">heap</span><span class="p">.</span><span class="n">ArenaAllocator</span><span class="p">,</span>
<span class="w">    </span><span class="n">childPid</span><span class="o">:</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">os</span><span class="p">.</span><span class="n">pid_t</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// TODO //</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">childInterceptSyscalls</span><span class="p">(</span>
<span class="w">        </span><span class="n">cm</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">ChildManager</span><span class="p">,</span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Handle syscall entrance</span>
<span class="w">            </span><span class="kr">const</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cm</span><span class="p">.</span><span class="n">childWaitForSyscall</span><span class="p">();</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="p">.</span><span class="n">os</span><span class="p">.</span><span class="n">W</span><span class="p">.</span><span class="n">IFEXITED</span><span class="p">(</span><span class="n">status</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="kr">var</span><span class="w"> </span><span class="n">args</span><span class="o">:</span><span class="w"> </span><span class="n">ABIArguments</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cm</span><span class="p">.</span><span class="n">getABIArguments</span><span class="p">();</span>
<span class="w">            </span><span class="kr">const</span><span class="w"> </span><span class="n">syscall</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">syscall</span><span class="p">();</span>

<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">hooks</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">hook</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">syscall</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">hook</span><span class="p">.</span><span class="n">syscall</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="k">try</span><span class="w"> </span><span class="n">hook</span><span class="p">.</span><span class="n">hook</span><span class="p">(</span><span class="n">cm</span><span class="p">.</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
<p>Later we'll write a hook for the <code>sys_write</code> syscall that
will force an incomplete write.</p>
<p>Back to the protocol, <code>childWaitForSyscall</code> will call <code>PTRACE_SYSCALL</code>
to allow the child process to start up again and continue until the
next syscall. We'll follow that by <code>wait</code>-ing for the child
process to be stopped again so we can handle the syscall entrance.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">childWaitForSyscall</span><span class="p">(</span><span class="n">cm</span><span class="o">:</span><span class="w"> </span><span class="n">ChildManager</span><span class="p">)</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kr">var</span><span class="w"> </span><span class="n">status</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">ptrace</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">PTRACE_SYSCALL</span><span class="p">,</span><span class="w"> </span><span class="n">cm</span><span class="p">.</span><span class="n">childPid</span><span class="p">,</span><span class="w"> </span><span class="n">cNullPtr</span><span class="p">,</span><span class="w"> </span><span class="n">cNullPtr</span><span class="p">);</span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">waitpid</span><span class="p">(</span><span class="n">cm</span><span class="p">.</span><span class="n">childPid</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">status</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">@bitCast</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
<p>Now that we've intercepted a syscall (after <code>waitpid</code> finishes
blocking), we need to figure out what syscall it was. We do this by
calling <code>PTRACE_GETREGS</code> and reading the <code>rax</code> register which
according to <a href="https://stackoverflow.com/a/54957101/1507139">amd64/linux calling
convention</a> is the
syscall called.</p>
<h4 id="registers">Registers</h4><p><code>PTRACE_GETREGS</code> fills out the <a href="https://sites.uclouvain.be/SystInfo/usr/include/sys/user.h.html">following
struct</a>:</p>
<div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">user_regs_struct</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">r15</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">r14</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">r13</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">r12</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">rbp</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">rbx</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">r11</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">r10</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">r9</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">r8</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">rax</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">rcx</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">rdx</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">rsi</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">rdi</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">orig_rax</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">rip</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">cs</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">eflags</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">rsp</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">ss</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">fs_base</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">gs_base</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">ds</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">es</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">fs</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">gs</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>Let's write a little amd64/linux-specific wrapper for accessing
meaningful fields.</p>
<div class="highlight"><pre><span></span><span class="kr">const</span><span class="w"> </span><span class="n">ABIArguments</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">regs</span><span class="o">:</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">user_regs_struct</span><span class="p">,</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">nth</span><span class="p">(</span><span class="n">aa</span><span class="o">:</span><span class="w"> </span><span class="n">ABIArguments</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="kt">c_ulong</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="p">.</span><span class="n">debug</span><span class="p">.</span><span class="n">assert</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="mi">0</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">aa</span><span class="p">.</span><span class="n">regs</span><span class="p">.</span><span class="n">rdi</span><span class="p">,</span>
<span class="w">            </span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">aa</span><span class="p">.</span><span class="n">regs</span><span class="p">.</span><span class="n">rsi</span><span class="p">,</span>
<span class="w">            </span><span class="mi">2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">aa</span><span class="p">.</span><span class="n">regs</span><span class="p">.</span><span class="n">rdx</span><span class="p">,</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">unreachable</span><span class="p">,</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">setNth</span><span class="p">(</span><span class="n">aa</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">ABIArguments</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="o">:</span><span class="w"> </span><span class="kt">c_ulong</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="p">.</span><span class="n">debug</span><span class="p">.</span><span class="n">assert</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>

<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="mi">0</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">aa</span><span class="p">.</span><span class="n">regs</span><span class="p">.</span><span class="n">rdi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">            </span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">aa</span><span class="p">.</span><span class="n">regs</span><span class="p">.</span><span class="n">rsi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">            </span><span class="mi">2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">aa</span><span class="p">.</span><span class="n">regs</span><span class="p">.</span><span class="n">rdx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">unreachable</span><span class="p">,</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">result</span><span class="p">(</span><span class="n">aa</span><span class="o">:</span><span class="w"> </span><span class="n">ABIArguments</span><span class="p">)</span><span class="w"> </span><span class="kt">c_ulong</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">aa</span><span class="p">.</span><span class="n">regs</span><span class="p">.</span><span class="n">rax</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">setResult</span><span class="p">(</span><span class="n">aa</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">ABIArguments</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="o">:</span><span class="w"> </span><span class="kt">c_ulong</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">aa</span><span class="p">.</span><span class="n">regs</span><span class="p">.</span><span class="n">rax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">syscall</span><span class="p">(</span><span class="n">aa</span><span class="o">:</span><span class="w"> </span><span class="n">ABIArguments</span><span class="p">)</span><span class="w"> </span><span class="kt">c_ulong</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">aa</span><span class="p">.</span><span class="n">regs</span><span class="p">.</span><span class="n">orig_rax</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
<p>One thing to note is that the field we read to get <code>rax</code> is not
<code>aa.regs.rax</code> but <code>aa.regs.orig_rax</code>. This is because <code>rax</code> is also
the return value and <code>PTRACE_SYSCALL</code> gets called twice for some
syscalls on entrance and exit. The <code>orig_rax</code> field preserves the
original <code>rax</code> value on syscall entrance. You can read more about this
<a href="https://stackoverflow.com/questions/6468896/why-is-orig-eax-provided-in-addition-to-eax/6469069#6469069">here</a>.</p>
<h4 id="getting-and-setting-registers">Getting and setting registers</h4><p>Now let's write the <code>ChildManager</code> code that actually calls
<code>PTRACE_GETREGS</code> to fill out one of these structs.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">getABIArguments</span><span class="p">(</span><span class="n">cm</span><span class="o">:</span><span class="w"> </span><span class="n">ChildManager</span><span class="p">)</span><span class="w"> </span><span class="n">ABIArguments</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kr">var</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ABIArguments</span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">regs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span><span class="w"> </span><span class="p">};</span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">ptrace</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">PTRACE_GETREGS</span><span class="p">,</span><span class="w"> </span><span class="n">cm</span><span class="p">.</span><span class="n">childPid</span><span class="p">,</span><span class="w"> </span><span class="n">cNullPtr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">args</span><span class="p">.</span><span class="n">regs</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">args</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
<p>Setting registers is similar, we just pass the struct back and call
<code>PTRACE_SETREGS</code> instead:</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">setABIArguments</span><span class="p">(</span><span class="n">cm</span><span class="o">:</span><span class="w"> </span><span class="n">ChildManager</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">ABIArguments</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">ptrace</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span><span class="w"> </span><span class="n">cm</span><span class="p">.</span><span class="n">childPid</span><span class="p">,</span><span class="w"> </span><span class="n">cNullPtr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">args</span><span class="p">.</span><span class="n">regs</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
<h4 id="a-hook">A hook</h4><p>Now we finally have enough code to write a hook that can get and set
registers; i.e. manipulate a system call!</p>
<p>We'll start by registering a <code>sys_write</code> hook in the <code>hooks</code> field we
check in <code>childInterceptSyscalls</code> above.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">hooks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">syscall</span><span class="o">:</span><span class="w"> </span><span class="kt">c_ulong</span><span class="p">,</span>
<span class="w">        </span><span class="n">hook</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="p">(</span><span class="n">ChildManager</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">ABIArguments</span><span class="p">)</span><span class="w"> </span><span class="kt">anyerror</span><span class="o">!</span><span class="kt">void</span><span class="p">,</span>
<span class="w">    </span><span class="p">}{.{</span>
<span class="w">        </span><span class="p">.</span><span class="n">syscall</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@intFromEnum</span><span class="p">(</span><span class="n">std</span><span class="p">.</span><span class="n">os</span><span class="p">.</span><span class="n">linux</span><span class="p">.</span><span class="n">syscalls</span><span class="p">.</span><span class="n">X64</span><span class="p">.</span><span class="n">write</span><span class="p">),</span>
<span class="w">        </span><span class="p">.</span><span class="n">hook</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">writeHandler</span><span class="p">,</span>
<span class="w">    </span><span class="p">}};</span>
</pre></div>
<p>If we look at the <a href="https://man7.org/linux/man-pages/man2/write.2.html">manpage for
<code>write</code></a> we see it
takes three arguments</p>
<ol>
<li>The file descriptor (fd) to write to</li>
<li>The address to start writing data from</li>
<li>And the number of bytes to write</li>
</ol>
<p>Going back to the <a href="https://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-and-user-space-f">calling
convention</a>
that means the fd will be in <code>rdi</code>, the data address in <code>rsi</code>, and the
data length in <code>rdx</code>.</p>
<p>So if we shorten the data length, we should be creating a short
(incomplete) write.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">writeHandler</span><span class="p">(</span><span class="n">cm</span><span class="o">:</span><span class="w"> </span><span class="n">ChildManager</span><span class="p">,</span><span class="w"> </span><span class="n">entryArgs</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">ABIArguments</span><span class="p">)</span><span class="w"> </span><span class="kt">anyerror</span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kr">const</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entryArgs</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="kr">const</span><span class="w"> </span><span class="n">dataAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entryArgs</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="kr">var</span><span class="w"> </span><span class="n">dataLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entryArgs</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Truncate some bytes</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dataLength</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">dataLength</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">            </span><span class="n">entryArgs</span><span class="p">.</span><span class="n">setNth</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">dataLength</span><span class="p">);</span>
<span class="w">            </span><span class="n">cm</span><span class="p">.</span><span class="n">setABIArguments</span><span class="p">(</span><span class="n">entryArgs</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
<p>In a more sophisticated version of this program, we could randomly
decide when to truncate data and randomly decide how much data to
truncate. However, for our purposes this is sufficient.</p>
<p>But there are some real problems with this code. When I ran this
program against a basic Go program, I saw duplicate requests.</p>
<p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">Ah ok, PTRACE_SYSCALL gets hit when you both enter and exit a syscall.<br><br>So each time you call PTRACE_SYSCALL and you do stuff, you just call it again afterwards to handle/wait for the exit. <a href="https://t.co/PjmNwcMepG">pic.twitter.com/PjmNwcMepG</a></p>&mdash; Phil Eaton (@eatonphil) <a href="https://twitter.com/eatonphil/status/1707846783035183267?ref_src=twsrc%5Etfw">September 29, 2023</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>
<p>So the deal with <code>PTRACE_SYSCALL</code> is that for (most?) syscalls, you
get to modify data before the data actually is handled by the
kernel. And you get to modify data after the kernel has finished the
syscall too.</p>
<p>This makes sense because <code>PTRACE_SYSCALL</code> (unlike <code>PTRACE_SYSEMU</code>)
allows the syscall to actually happen. And if we wanted to, for
example, modify the syscall exit code, we'd have to do that after the
syscall was done not before it started. We are modifying registers
directly after all.</p>
<p>All this means for our Zig code is that when we handle <code>sys_write</code>, we
need to call <code>PTRACE_SYSCALL</code> again to process the syscall
exit. Otherwise we'd reach this <code>writeHandler</code> for both entries and
exits, which would require some additional way of disambiguating
entrances from exits.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">writeHandler</span><span class="p">(</span><span class="n">cm</span><span class="o">:</span><span class="w"> </span><span class="n">ChildManager</span><span class="p">,</span><span class="w"> </span><span class="n">entryArgs</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">ABIArguments</span><span class="p">)</span><span class="w"> </span><span class="kt">anyerror</span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kr">const</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entryArgs</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="kr">const</span><span class="w"> </span><span class="n">dataAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entryArgs</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="kr">var</span><span class="w"> </span><span class="n">dataLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entryArgs</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Truncate some bytes</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dataLength</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">dataLength</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">            </span><span class="n">entryArgs</span><span class="p">.</span><span class="n">setNth</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">dataLength</span><span class="p">);</span>
<span class="w">            </span><span class="n">cm</span><span class="p">.</span><span class="n">setABIArguments</span><span class="p">(</span><span class="n">entryArgs</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kr">const</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">cm</span><span class="p">.</span><span class="n">childReadData</span><span class="p">(</span><span class="n">dataAddress</span><span class="p">,</span><span class="w"> </span><span class="n">dataLength</span><span class="p">);</span>
<span class="w">        </span><span class="k">defer</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">deinit</span><span class="p">();</span>
<span class="w">        </span><span class="n">std</span><span class="p">.</span><span class="n">debug</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;Got a write on {}: {s}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">items</span><span class="w"> </span><span class="p">});</span>

<span class="w">        </span><span class="c1">// Handle syscall exit</span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cm</span><span class="p">.</span><span class="n">childWaitForSyscall</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
<p class="note">
  We could put the <code>cm.childWaitForSyscall()</code> waiting for
  the syscall exit in the main loop and I did try that at
  first. However, not all syscalls seemed to have the same entry and
  exit hook and this resulted in the hooks sometimes starting with a
  syscall exit rather than a syscall entry. So rather than making the
  code more complicated, I decided to only wait for the exit on
  syscalls I knew had an exit (by observation at least), like
  <code>sys_write</code>.
</p><h3 id="multiple-writes?-no-bad-logic?">Multiple writes? No bad logic?</h3><p>So I had this code as is, correctly handling syscall entrances and
exits, but I was seeing multiple write calls. And the text file I was
writing to had the complete text I wanted to write. There was no short
write even though I truncated the data length.</p>
<p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">Ok so what happens in this Go program if I truncate the amount of data?<br><br>I assumed Go would do nothing since all I did was call `f.Write()` once and `f.Write()` returns a number of bytes written.<br><br>But actually, it still writes everything! <a href="https://t.co/OSalKEbERM">pic.twitter.com/OSalKEbERM</a></p>&mdash; Phil Eaton (@eatonphil) <a href="https://twitter.com/eatonphil/status/1707854642250408119?ref_src=twsrc%5Etfw">September 29, 2023</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>
<p>This took some digging into Go source code to understand. If you trace
what <code>os.File.Write()</code> does on Linux you eventually get to
<a href="https://cs.opensource.google/go/go/+/refs/tags/go1.21.1:src/internal/poll/fd_unix.go">src/internal/poll/fd_unix.go</a>:</p>
<div class="highlight"><pre><span></span><span class="c1">// Write implements io.Writer.</span>
<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">fd</span><span class="w"> </span><span class="o">*</span><span class="nx">FD</span><span class="p">)</span><span class="w"> </span><span class="nx">Write</span><span class="p">(</span><span class="nx">p</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">fd</span><span class="p">.</span><span class="nx">writeLock</span><span class="p">();</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">defer</span><span class="w"> </span><span class="nx">fd</span><span class="p">.</span><span class="nx">writeUnlock</span><span class="p">()</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">fd</span><span class="p">.</span><span class="nx">pd</span><span class="p">.</span><span class="nx">prepareWrite</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">isFile</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="kd">var</span><span class="w"> </span><span class="nx">nn</span><span class="w"> </span><span class="kt">int</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">max</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="nx">fd</span><span class="p">.</span><span class="nx">IsStream</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">max</span><span class="o">-</span><span class="nx">nn</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">maxRW</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="nx">max</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">nn</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">maxRW</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="nx">n</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ignoringEINTRIO</span><span class="p">(</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">Write</span><span class="p">,</span><span class="w"> </span><span class="nx">fd</span><span class="p">.</span><span class="nx">Sysfd</span><span class="p">,</span><span class="w"> </span><span class="nx">p</span><span class="p">[</span><span class="nx">nn</span><span class="p">:</span><span class="nx">max</span><span class="p">])</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="nx">nn</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">n</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="nx">nn</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="k">return</span><span class="w"> </span><span class="nx">nn</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">syscall</span><span class="p">.</span><span class="nx">EAGAIN</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">fd</span><span class="p">.</span><span class="nx">pd</span><span class="p">.</span><span class="nx">pollable</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">fd</span><span class="p">.</span><span class="nx">pd</span><span class="p">.</span><span class="nx">waitWrite</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">isFile</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">                                </span><span class="k">continue</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="k">return</span><span class="w"> </span><span class="nx">nn</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="k">return</span><span class="w"> </span><span class="nx">nn</span><span class="p">,</span><span class="w"> </span><span class="nx">io</span><span class="p">.</span><span class="nx">ErrUnexpectedEOF</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>This might be common knowledge but I didn't realize Go did this. And
when I tried out the same basic program in Python and even C, the
behavior was the same. The builtin <code>write()</code> behavior on a file (in
many languages apparantly) is to retry until all data is written, with
some exceptions.</p>
<p>This makes sense since files on disk, unlike file descriptors backed
by network sockets, are generally always available. Compared to a
network connection, disks are physically close and almost always
stay connected. (With some obvious exceptions like
network-attached storage and thumb drives.)</p>
<p>So to trigger the short write, the easiest way seems to have the
<code>sys_write</code> call return an error that is NOT <code>EAGAIN</code> since the code
will retry if that is the error.</p>
<p>After looking through the <a href="https://man7.org/linux/man-pages/man2/write.2.html#ERRORS">list of errors that sys_write can
return</a>,
<code>EIO</code> seems like a nice one.</p>
<p>So let's do our final version of <code>writeHandler</code> and on the syscall
exit, we'll modify the return value (<code>rax</code> in amd64/linux) to be
<code>EIO</code>.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">writeHandler</span><span class="p">(</span><span class="n">cm</span><span class="o">:</span><span class="w"> </span><span class="n">ChildManager</span><span class="p">,</span><span class="w"> </span><span class="n">entryArgs</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">ABIArguments</span><span class="p">)</span><span class="w"> </span><span class="kt">anyerror</span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kr">const</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entryArgs</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="kr">const</span><span class="w"> </span><span class="n">dataAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entryArgs</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="kr">var</span><span class="w"> </span><span class="n">dataLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entryArgs</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Truncate some bytes</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dataLength</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">dataLength</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">            </span><span class="n">entryArgs</span><span class="p">.</span><span class="n">setNth</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">dataLength</span><span class="p">);</span>
<span class="w">            </span><span class="n">cm</span><span class="p">.</span><span class="n">setABIArguments</span><span class="p">(</span><span class="n">entryArgs</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Handle syscall exit</span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cm</span><span class="p">.</span><span class="n">childWaitForSyscall</span><span class="p">();</span>

<span class="w">        </span><span class="kr">var</span><span class="w"> </span><span class="n">exitArgs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cm</span><span class="p">.</span><span class="n">getABIArguments</span><span class="p">();</span>
<span class="w">        </span><span class="n">dataLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">exitArgs</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dataLength</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Force the writes to stop after the first one by returning EIO.</span>
<span class="w">            </span><span class="kr">var</span><span class="w"> </span><span class="n">result</span><span class="o">:</span><span class="w"> </span><span class="kt">c_ulong</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">-%</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">EIO</span><span class="p">;</span>
<span class="w">            </span><span class="n">exitArgs</span><span class="p">.</span><span class="n">setResult</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="w">            </span><span class="n">cm</span><span class="p">.</span><span class="n">setABIArguments</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exitArgs</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
<p>Let's give it a whirl!</p>
<h3 id="all-together">All together</h3><p>Build the Zig fault injector and the Go test code:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>zig<span class="w"> </span>build-exe<span class="w"> </span>--library<span class="w"> </span>c<span class="w"> </span>main.zig
<span class="gp">$ </span><span class="o">(</span><span class="w"> </span><span class="nb">cd</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>go<span class="w"> </span>build<span class="w"> </span>main.go<span class="w"> </span><span class="o">)</span>
</pre></div>
<p>And run:</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>./main<span class="w"> </span>test/main
</pre></div>
<p>And check <code>test.txt</code>:</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>cat<span class="w"> </span>test.txt
some<span class="w"> </span>great<span class="w"> </span>stu
</pre></div>
<p>Hey, that's a short write! :)</p>
<h3 id="sidenote:-reading-data-from-the-child">Sidenote: Reading data from the child</h3><p>We accomplished everything we set out to, but there's one other useful
thing we can do: reading the actual data passed to the write syscall.</p>
<p>Just like how we can get the child process registers with
<code>PTRACE_GETREGS</code>, we can read child memory with
<code>PTRACE_PEEKDATA</code>. <code>PTRACE_PEEKDATA</code> takes the child process id and
the memory address in the child to read from. It returns a word of
data (which on amd64/linux is 8 bytes).</p>
<p>We can use the syscall arguments (data address and length) to keep
calling <code>PTRACE_PEEKDATA</code> on the child until we've read all bytes of
the data the child process wanted to write:</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">childReadData</span><span class="p">(</span>
<span class="w">        </span><span class="n">cm</span><span class="o">:</span><span class="w"> </span><span class="n">ChildManager</span><span class="p">,</span>
<span class="w">        </span><span class="n">address</span><span class="o">:</span><span class="w"> </span><span class="kt">c_ulong</span><span class="p">,</span>
<span class="w">        </span><span class="n">length</span><span class="o">:</span><span class="w"> </span><span class="kt">c_ulong</span><span class="p">,</span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="o">!</span><span class="n">std</span><span class="p">.</span><span class="n">ArrayList</span><span class="p">(</span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kr">var</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">ArrayList</span><span class="p">(</span><span class="kt">u8</span><span class="p">).</span><span class="n">init</span><span class="p">(</span><span class="n">cm</span><span class="p">.</span><span class="n">arena</span><span class="p">.</span><span class="n">allocator</span><span class="p">());</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="n">len</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kr">var</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">ptrace</span><span class="p">(</span>
<span class="w">                </span><span class="n">c</span><span class="p">.</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span>
<span class="w">                </span><span class="n">cm</span><span class="p">.</span><span class="n">childPid</span><span class="p">,</span>
<span class="w">                </span><span class="n">address</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
<span class="w">                </span><span class="n">cNullPtr</span><span class="p">,</span>
<span class="w">            </span><span class="p">);</span>

<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="p">.</span><span class="n">mem</span><span class="p">.</span><span class="n">asBytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">word</span><span class="p">))</span><span class="w"> </span><span class="o">|</span><span class="n">byte</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="n">len</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">try</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">byte</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
<p>And we could modify <code>writeHandler</code> to print out the entirety of the write message each time (for debugging):</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">writeHandler</span><span class="p">(</span><span class="n">cm</span><span class="o">:</span><span class="w"> </span><span class="n">ChildManager</span><span class="p">,</span><span class="w"> </span><span class="n">entryArgs</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">ABIArguments</span><span class="p">)</span><span class="w"> </span><span class="kt">anyerror</span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kr">const</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entryArgs</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="kr">const</span><span class="w"> </span><span class="n">dataAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entryArgs</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="kr">var</span><span class="w"> </span><span class="n">dataLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entryArgs</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Truncate some bytes</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dataLength</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">dataLength</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">            </span><span class="n">entryArgs</span><span class="p">.</span><span class="n">setNth</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">dataLength</span><span class="p">);</span>
<span class="w">            </span><span class="n">cm</span><span class="p">.</span><span class="n">setABIArguments</span><span class="p">(</span><span class="n">entryArgs</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kr">const</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">cm</span><span class="p">.</span><span class="n">childReadData</span><span class="p">(</span><span class="n">dataAddress</span><span class="p">,</span><span class="w"> </span><span class="n">dataLength</span><span class="p">);</span>
<span class="w">        </span><span class="k">defer</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">deinit</span><span class="p">();</span>
<span class="w">        </span><span class="n">std</span><span class="p">.</span><span class="n">debug</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;Got a write on {}: {s}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">items</span><span class="w"> </span><span class="p">});</span>

<span class="w">        </span><span class="c1">// Handle syscall exit</span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cm</span><span class="p">.</span><span class="n">childWaitForSyscall</span><span class="p">();</span>

<span class="w">        </span><span class="kr">var</span><span class="w"> </span><span class="n">exitArgs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cm</span><span class="p">.</span><span class="n">getABIArguments</span><span class="p">();</span>
<span class="w">        </span><span class="n">dataLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">exitArgs</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dataLength</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Force the writes to stop after the first one by returning EIO.</span>
<span class="w">            </span><span class="kr">var</span><span class="w"> </span><span class="n">result</span><span class="o">:</span><span class="w"> </span><span class="kt">c_ulong</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">-%</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">EIO</span><span class="p">;</span>
<span class="w">            </span><span class="n">exitArgs</span><span class="p">.</span><span class="n">setResult</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="w">            </span><span class="n">cm</span><span class="p">.</span><span class="n">setABIArguments</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exitArgs</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
<p>That's pretty neat!</p>
<h3 id="next-steps">Next steps</h3><p>Short writes are just one of many bad IO interactions. Another fun one
would be to completely buffer all writes on a file descriptor (not
allowing anything to be written to disk at all) until fsync is called
on the file descriptor. Or <a href="https://www.usenix.org/conference/atc20/presentation/rebello">forcing fsyncs to
fail</a>.</p>
<p>An interesting optimization would be to apply <a href="https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt">seccomp
filters</a>
so that rather than paying a penalty for watching every syscall, I
only get notified about the ones I have hooks for like
<code>sys_write</code>. <a href="https://www.alfonsobeato.net/c/filter-and-modify-system-calls-with-seccomp-and-ptrace/">Here's another
post</a>
that explores ptrace with seccomp filters.</p>
<p>Credits: Thank you Charlie Cummings and Paul Khuong for reviewing a draft
of this post!</p>
<h3 id="selected-responses-after-publication">Selected responses after publication</h3><ul>
<li>oscooter on Reddit <a href="https://www.reddit.com/r/linux/comments/16x32l3/comment/k380m9q/?utm_source=reddit&amp;utm_medium=web2x&amp;context=3">gave some
tips</a>
on using ptrace, including using <code>process_vm_readv</code> instead of
<code>PTRACE_PEEKDATA</code> to read memory from the tracee process.</li>
</ul>
<p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fault injection is a scary-sounding term. Intercepting and modifying Linux system calls sounds scary too.<br><br>But it&#39;s a neat way to trigger logical errors in programs, to build confidence we wrote code correctly.<br><br>Let&#39;s trigger short writes to disk in Zig!<a href="https://t.co/0C3tWt3vtT">https://t.co/0C3tWt3vtT</a> <a href="https://t.co/OS7auDe8jR">pic.twitter.com/OS7auDe8jR</a></p>&mdash; Phil Eaton (@eatonphil) <a href="https://twitter.com/eatonphil/status/1708482934863180004?ref_src=twsrc%5Etfw">October 1, 2023</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>
<style>.feedback{display:initial;}</style>
	</div>
	<div class="feedback">
	  <h4>Feedback</h4>
	  <p>As always,
	      please <a href="mailto:phil@eatonphil.com">email</a>
	      or <a href="https://twitter.com/eatonphil">tweet me</a>
	      with questions, corrections, or ideas!</p>

	</div>
      </div>
    </div>
    <footer>
      <div class="container">
	<div>
	  <div id="subscribe">
	    <iframe src="https://cdn.forms-content-1.sg-form.com/e8ed4c3b-dd46-11f0-b6e6-ce075f2c5f80"/>

	  </div>
	</div>
      </div>
    </footer>
    <script async onload="loadGA()" src="https://www.googletagmanager.com/gtag/js?id=UA-58109156-2"></script>
    <script>
      function loadGA() {
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());
	  gtag('config', 'UA-58109156-2');
      }
    </script>
    <script defer src="https://cdn.usefathom.com/script.js" data-site="CEPUOLOQ"></script>
  </body>
</html>
