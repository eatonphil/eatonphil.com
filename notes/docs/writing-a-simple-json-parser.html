<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="canonical" href="https://notes.eatonphil.com/writing-a-simple-json-parser.html">
    <title>Writing a simple JSON parser | notes.eatonphil.com</title>
    <meta name="description" content="Writing a simple JSON parser" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono">

    <script async onload="loadGA()" src="https://www.googletagmanager.com/gtag/js?id=UA-58109156-2"></script>
    <script>
      function loadGA() {
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());
	  gtag('config', 'UA-58109156-2');
      }
    </script>
    <script defer src="https://cdn.usefathom.com/script.js" data-site="CEPUOLOQ"></script>
  </head>
  <body>
    <header>
      <div class="lfw">
	<div class="container">
	  <div class="row">
	    <a href="https://eatonphil.com/2025-holiday-fundraiser.html">2025 Holiday Fundraiser</a>
	  </div>
	</div>
      </div>
      <div class="container">
        <div>
          <div class="row">
	    <div>
	      <a href="https://eatonphil.com" class="sm-link">
		Home
              </a>
	      <a href="/" class="sm-link">
		Blog
              </a>
	      <a href="/rss.xml" class="sm-link">
		RSS
              </a>
	    </div>

	    <div class="subscribe">
	      <!-- <a href="https://eatonphil.com/hire-me.html">Hire me</a> -->
	      <!--
		  Hardcode link to home page because some pages don't
		  have a subscribe box. Some pages hide the subscribe.
		-->
	      <a href="https://eatonphil.com/subscribe.html">
		Subscribe
	      </a>
            </div>
	  </div>
	  <hr />
	  <div class="">
            <h2>May 6, 2018</h2>
            <h1>Writing a simple JSON parser</h1>
	    
            <div class="row" style="padding-bottom: 5px">
              <div class="tags"><a href="/tags/json.html" class="tag">json</a><a href="/tags/parsing.html" class="tag">parsing</a><a href="/tags/python.html" class="tag">python</a></div>
            </div>
	  </div>
	</div>
      </div>
    </header>
    <div class="container">
      <div class="col-6">
	<div class="post">
          <p>Writing a JSON parser is one of the easiest ways to get familiar with
parsing techniques. The format is extremely simple. It's defined
recursively so you get a slight challenge compared to, say, parsing
<a href="https://en.wikipedia.org/wiki/Brainfuck">Brainfuck</a>; and you probably
already use JSON. Aside from that last point, parsing
<a href="https://en.wikipedia.org/wiki/S-expression">S-expressions</a> for Scheme
might be an even simpler task.</p>
<p>If you'd just like to see the code for the library, <code>pj</code>, <a href="https://github.com/eatonphil/pj">check it out
on Github</a>.</p>
<h3 id="what-parsing-is-and-(typically)-is-not">What parsing is and (typically) is not</h3><p>Parsing is often broken up into two stages: lexical analysis and
syntactic analysis. Lexical analysis breaks source input into the
simplest decomposable elements of a language called "tokens".
Syntactic analysis (often itself called "parsing") receives the list
of tokens and tries to find patterns in them to meet the language
being parsed.</p>
<p>Parsing does not determine semantic viability of an input
source. Semantic viability of an input source might include whether or
not a variable is defined before being used, whether a function is
called with the correct arguments, or whether a variable can be
declared a second time in some scope.</p>
<p class="note">
  There are, of course, always variations in how people choose to
  parse and apply semantic rules, but I am assuming a "traditional"
  approach to explain the core concepts.
</p><h4 id="the-json-library's-interface">The JSON library's interface</h4><p>Ultimately, there should be a <code>from_string</code> method that accepts a
JSON-encoded string and returns the equivalent Python dictionary.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span>assert_equal(from_string(&#39;{&quot;foo&quot;: 1}&#39;),
             {&quot;foo&quot;: 1})
</pre></div>
<h3 id="lexical-analysis">Lexical analysis</h3><p>Lexical analysis breaks down an input string into tokens. Comments and
whitespace are often discarded during lexical analysis so you are left
with a simpler input you can search for grammatical matches during the
syntactic analysis.</p>
<p>Assuming a simple lexical analyzer, you might iterate over all the
characters in an input string (or stream) and break them apart into
fundemental, <strong>non-recursively</strong> defined language constructs such as
integers, strings, and boolean literals. In particular, strings
<strong>must</strong> be part of the lexical analysis because you cannot throw away
whitespace without knowing that it is not part of a string.</p>
<p class="note">
  In a helpful lexer you keep track of the whitespace and comments
  you've skipped, the current line number and file you are in so that
  you can refer back to it at any stage in errors produced by analysis
  of the source. <a
  href="https://v8project.blogspot.com/2018/03/v8-release-66.html">The
  V8 Javascript engine recently became able to do reproduce the exact
  source code of a function.</a> This, at the very least, would need
  the help of a lexer to make possible.
</p><h4 id="implementing-a-json-lexer">Implementing a JSON lexer</h4><p>The gist of the JSON lexer will be to iterate over the input source
and try to find patterns of strings, numbers, booleans, nulls, or JSON
syntax like left brackets and left braces, ultimately returning
each of these elements as a list.</p>
<p>Here is what the lexer should return for an example input:</p>
<div class="highlight"><pre><span></span><span class="n">assert_equal</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s1">&#39;{&quot;foo&quot;: [1, 2, {&quot;bar&quot;: 2}]}&#39;</span><span class="p">),</span>
             <span class="p">[</span><span class="s1">&#39;{&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="s1">&#39;[&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="s1">&#39;{&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;}&#39;</span><span class="p">,</span> <span class="s1">&#39;]&#39;</span><span class="p">,</span> <span class="s1">&#39;}&#39;</span><span class="p">])</span>
</pre></div>
<p>Here is what this logic might begin to look like:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">lex</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
        <span class="n">json_string</span><span class="p">,</span> <span class="n">string</span> <span class="o">=</span> <span class="n">lex_string</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">json_string</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">json_string</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># TODO: lex booleans, nulls, numbers</span>

        <span class="k">if</span> <span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">JSON_WHITESPACE</span><span class="p">:</span>
            <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">JSON_SYNTAX</span><span class="p">:</span>
            <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unexpected character: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">tokens</span>
</pre></div>
<p>The goal here is to try to match strings, numbers, booleans, and nulls
and add them to the list of tokens. If none of these match, check if
the character is whitespace and throw it away if so. Otherwise store
it as a token if it is part of JSON syntax (like left
brackets). Finally throw an exception if the character/string didn't
match any of these patterns.</p>
<p>Let's extend the core logic here a little bit to support all the types
and add the function stubs.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">lex_string</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">string</span>


<span class="k">def</span> <span class="nf">lex_number</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">string</span>


<span class="k">def</span> <span class="nf">lex_bool</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">string</span>


<span class="k">def</span> <span class="nf">lex_null</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">string</span>


<span class="k">def</span> <span class="nf">lex</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
        <span class="n">json_string</span><span class="p">,</span> <span class="n">string</span> <span class="o">=</span> <span class="n">lex_string</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">json_string</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">json_string</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">json_number</span><span class="p">,</span> <span class="n">string</span> <span class="o">=</span> <span class="n">lex_number</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">json_number</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">json_number</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">json_bool</span><span class="p">,</span> <span class="n">string</span> <span class="o">=</span> <span class="n">lex_bool</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">json_bool</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">json_bool</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">json_null</span><span class="p">,</span> <span class="n">string</span> <span class="o">=</span> <span class="n">lex_null</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">json_null</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">JSON_WHITESPACE</span><span class="p">:</span>
            <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">JSON_SYNTAX</span><span class="p">:</span>
            <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unexpected character: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">tokens</span>
</pre></div>
<h4 id="lexing-strings">Lexing strings</h4><p>For the <code>lex_string</code> function, the gist will be to check if the first
character is a quote. If it is, iterate over the input string until
you find an ending quote. If you don't find an initial quote, return
None and the original list. If you find an initial quote and an ending
quote, return the string within the quotes and the rest of the
unchecked input string.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">lex_string</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="n">json_string</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="k">if</span> <span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">JSON_QUOTE</span><span class="p">:</span>
        <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">string</span>

    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">string</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">JSON_QUOTE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">json_string</span><span class="p">,</span> <span class="n">string</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">json_string</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">json_string</span> <span class="o">+=</span> <span class="n">c</span>

    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Expected end-of-string quote&#39;</span><span class="p">)</span>
</pre></div>
<h4 id="lexing-numbers">Lexing numbers</h4><p>For the <code>lex_number</code> function, the gist will be to iterate over the
input until you find a character that cannot be part of a number.
(This is, of course, a gross simplification, but being more accurate
will be left as an exercise to the reader.) After finding a character
that cannot be part of a number, either return a float or int if the
characters you've accumulated number more than 0. Otherwise return
None and the original string input.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">lex_number</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="n">json_number</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="n">number_characters</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">string</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">number_characters</span><span class="p">:</span>
            <span class="n">json_number</span> <span class="o">+=</span> <span class="n">c</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="n">rest</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">json_number</span><span class="p">):]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">json_number</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">string</span>

    <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">json_number</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">json_number</span><span class="p">),</span> <span class="n">rest</span>

    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">json_number</span><span class="p">),</span> <span class="n">rest</span>
</pre></div>
<h4 id="lexing-booleans-and-nulls">Lexing booleans and nulls</h4><p>Finding boolean and null values is a very simple string match.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">lex_bool</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="n">string_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">string_len</span> <span class="o">&gt;=</span> <span class="n">TRUE_LEN</span> <span class="ow">and</span> \
       <span class="n">string</span><span class="p">[:</span><span class="n">TRUE_LEN</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;true&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">string</span><span class="p">[</span><span class="n">TRUE_LEN</span><span class="p">:]</span>
    <span class="k">elif</span> <span class="n">string_len</span> <span class="o">&gt;=</span> <span class="n">FALSE_LEN</span> <span class="ow">and</span> \
         <span class="n">string</span><span class="p">[:</span><span class="n">FALSE_LEN</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;false&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">string</span><span class="p">[</span><span class="n">FALSE_LEN</span><span class="p">:]</span>

    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">string</span>


<span class="k">def</span> <span class="nf">lex_null</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="n">string_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">string_len</span> <span class="o">&gt;=</span> <span class="n">NULL_LEN</span> <span class="ow">and</span> \
       <span class="n">string</span><span class="p">[:</span><span class="n">NULL_LEN</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;null&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">string</span><span class="p">[</span><span class="n">NULL_LEN</span><span class="p">:]</span>

    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">string</span>
</pre></div>
<p>And now the lexer code is done! See the
<a href="https://github.com/eatonphil/pj/blob/master/pj/lexer.py">pj/lexer.py</a>
for the code as a whole.</p>
<h3 id="syntactic-analysis">Syntactic analysis</h3><p>The syntax analyzer's (basic) job is to iterate over a one-dimensional
list of tokens and match groups of tokens up to pieces of the language
according to the definition of the language. If, at any point during
syntactic analysis, the parser cannot match the current set of tokens up
to a valid grammar of the language, the parser will fail and possibly
give you useful information as to what you gave, where, and what it
expected from you.</p>
<h4 id="implementing-a-json-parser">Implementing a JSON parser</h4><p>The gist of the JSON parser will be to iterate over the tokens
received after a call to <code>lex</code> and try to match the tokens to objects,
lists, or plain values.</p>
<p>Here is what the parser should return for an example input:</p>
<div class="highlight"><pre><span></span><span class="n">tokens</span> <span class="o">=</span> <span class="n">lex</span><span class="p">(</span><span class="s1">&#39;{&quot;foo&quot;: [1, 2, {&quot;bar&quot;: 2}]}&#39;</span><span class="p">)</span>
<span class="n">assert_equal</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span>
             <span class="p">[</span><span class="s1">&#39;{&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="s1">&#39;[&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;{&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;}&#39;</span><span class="p">,</span> <span class="s1">&#39;]&#39;</span><span class="p">,</span> <span class="s1">&#39;}&#39;</span><span class="p">])</span>
<span class="n">assert_equal</span><span class="p">(</span><span class="n">parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">),</span>
             <span class="p">{</span><span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}]})</span>
</pre></div>
<p>Here is what this logic might begin to look like:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">parse_array</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[],</span> <span class="n">tokens</span>

<span class="k">def</span> <span class="nf">parse_object</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{},</span> <span class="n">tokens</span>

<span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">JSON_LEFTBRACKET</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">parse_array</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="n">JSON_LEFTBRACE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">parse_object</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</pre></div>
<p>A key structural difference between this lexer and parser is that the
lexer returns a one-dimensional array of tokens. Parsers are often
defined recursively and returns a recursive, tree-like object. Since
JSON is a data serialization format instead of a language, the parser
should produce objects in Python rather than a syntax tree on which
you could perform more analysis (or code generation in the case of a
compiler).</p>
<p>And, again, the benefit of having the lexical analysis happen
independent from the parser is that both pieces of code are simpler
and concerned with only specific elements.</p>
<h4 id="parsing-arrays">Parsing arrays</h4><p>Parsing arrays is a matter of parsing array members and expecting a
comma token between them or a right bracket indicating the end
of the array.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">parse_array</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
    <span class="n">json_array</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">JSON_RIGHTBRACKET</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">json_array</span><span class="p">,</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">json</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="n">json_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">json</span><span class="p">)</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">JSON_RIGHTBRACKET</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">json_array</span><span class="p">,</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">JSON_COMMA</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Expected comma after object in array&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Expected end-of-array bracket&#39;</span><span class="p">)</span>
</pre></div>
<h4 id="parsing-objects">Parsing objects</h4><p>Parsing objects is a matter of parsing a key-value pair internally
separated by a colon and externally separated by a comma until you
reach the end of the object.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">parse_object</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
    <span class="n">json_object</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">JSON_RIGHTBRACE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">json_object</span><span class="p">,</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">json_key</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">json_key</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Expected string key, got: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">json_key</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">JSON_COLON</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Expected colon after key in object, got: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

        <span class="n">json_value</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="n">json_object</span><span class="p">[</span><span class="n">json_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">json_value</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">JSON_RIGHTBRACE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">json_object</span><span class="p">,</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">JSON_COMMA</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Expected comma after pair in object, got: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

        <span class="n">tokens</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Expected end-of-object brace&#39;</span><span class="p">)</span>
</pre></div>
<p>And now the parser code is done! See the
<a href="https://github.com/eatonphil/pj/blob/master/pj/parser.py">pj/parser.py</a>
for the code as a whole.</p>
<h3 id="unifying-the-library">Unifying the library</h3><p>To provide the ideal interface, create the <code>from_string</code> function
wrapping the <code>lex</code> and <code>parse</code> functions.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">from_string</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="n">lex</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
<p>And the library is complete! (ish). Check out the <a href="https://github.com/eatonphil/pj">project on
Github</a> for the full implementation
including basic testing setup.</p>
<h3 id="appendix-a:-single-step-parsing">Appendix A: Single-step parsing</h3><p>Some parsers choose to implement lexical and syntactic analysis in one
stage. For some languages this can simplify the parsing stage
entirely. Or, in more powerful languages like Common Lisp, it can
allow you to dynamically extend the lexer and parser in one step with
<a href="https://gist.github.com/chaitanyagupta/9324402">reader macros</a>.</p>
<p class="note">
  I wrote this library in Python to make it more accessible to
  a larger audience. However, many of the techniques used are more
  amenable to languages with pattern matching and support for monadic
  operations -- like Standard ML. If you are curious what this same
  code would look like in Standard ML, check out the <a
  href="https://github.com/eatonphil/ponyo/blob/master/src/Encoding/Json.sml">JSON
  code in Ponyo</a>.
</p><p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">I wrote a short post (and a corresponding Python library) explaining lexing and parsing with JSON <a href="https://t.co/3yEZlcU6i5">https://t.co/3yEZlcU6i5</a> <a href="https://t.co/FbksvUO9aT">https://t.co/FbksvUO9aT</a> <a href="https://twitter.com/hashtag/json?src=hash&amp;ref_src=twsrc%5Etfw">#json</a> <a href="https://twitter.com/hashtag/python?src=hash&amp;ref_src=twsrc%5Etfw">#python</a></p>&mdash; Phil Eaton (@phil_eaton) <a href="https://twitter.com/phil_eaton/status/993251098931712005?ref_src=twsrc%5Etfw">May 6, 2018</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>
<style>.feedback{display:initial;}</style>
	</div>
	<div class="feedback">
	  <h4>Feedback</h4>
	  <p>As always,
	      please <a href="mailto:phil@eatonphil.com">email</a>
	      or <a href="https://twitter.com/eatonphil">tweet me</a>
	      with questions, corrections, or ideas!</p>

	</div>
      </div>
    </div>
    <footer>
      <div class="container">
	<div>
	  <div id="subscribe">
	    <iframe frameBorder="0" src="https://cdn.forms-content-1.sg-form.com/e8ed4c3b-dd46-11f0-b6e6-ce075f2c5f80"></iframe>

	  </div>
	</div>
      </div>
    </footer>
  </body>
</html>
