<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="canonical" href="https://notes.eatonphil.com/2024-02-6-raft-from-scratch-in-rust.html">
    <title>Building an intuition for distributed consensus in OLTP systems | notes.eatonphil.com</title>
    <meta name="description" content="Building an intuition for distributed consensus in OLTP systems" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono">
  </head>
  <body>
    <header>
      <div class="lfw">
	<div class="container">
	  <div class="row">
	    <a href="https://eatonphil.com/2025-holiday-fundraiser.html">2025 holiday fundraiser</a>
	  </div>
	</div>
      </div>
      <div class="container">
        <div>
          <div class="row">
	    <div>
	      <a href="https://eatonphil.com" class="sm-link">
		Home
              </a>
	      <a href="/" class="sm-link">
		Blog
              </a>
	      <a href="/rss.xml" class="sm-link">
		RSS
              </a>
	    </div>

	    <div class="subscribe">
	      <!-- <a href="https://eatonphil.com/hire-me.html">Hire me</a> -->
	      <!--
		  Hardcode link to home page because some pages don't
		  have a subscribe box. Some pages hide the subscribe.
		-->
	      <a href="https://eatonphil.com/subscribe.html">
		Subscribe
	      </a>
            </div>
	  </div>
	  <hr />
	  <div class="">
            <h2>February 5, 2024</h2>
            <h1>Building an intuition for distributed consensus in OLTP systems</h1>
	    
            <div class="row" style="padding-bottom: 5px">
              ['raft', 'rust', 'draft']
            </div>
	  </div>
	</div>
      </div>
    </header>
    <div class="container">
      <div class="col-6">
	<div class="post">
          <p><!-- -*- mode: markdown -*- --></p>
<h3 id="and-implementing-raft-from-scratch-in-rust">And implementing Raft from scratch in Rust</h3><h3 id="implementation-notes">Implementation notes</h3><p>I implemented Raft for the <a href="https://github.com/eatonphil/raft-rs">second time in
Rust</a>, to practice Rust and
Raft. The first time was in Go. I wrote about it
<a href="https://notes.eatonphil.com/2023-05-25-raft.html">here</a>.</p>
<p>Like the Go implementation, the Rust one uses no third-party libraries
outside the Rust standard library. And it uses no <code>unsafe</code> code. Both
of these details make this implementation more verbose in some ways
than maybe it should be.</p>
<p>I was shocked by just how confined the Rust standard library is. I had
to implement <a href="https://github.com/eatonphil/raft-rs/blob/2167f65f6831ab3d29c6704762015c884d6afb2d/src/lib.rs#L2818">random number
generation</a>
(a port of <a href="https://prng.di.unimi.it/">xoshiro256plusplus</a>) and
<a href="https://github.com/eatonphil/raft-rs/blob/2167f65f6831ab3d29c6704762015c884d6afb2d/src/lib.rs#L2724">CRC32C for
checksums</a>
(a port from
<a href="https://web.mit.edu/freebsd/head/sys/libkern/crc32.c">FreeBSD</a>).</p>
<p>Nevertheless, it seems to me to be less "black magic" if an
implementation avoids use third-party libraries.</p>
<h3 id="architecture">Architecture</h3><p>There are three major components we can look at.</p>
<ol>
<li>Reading and writing log entries and Raft metadata to disk</li>
<li>Sending and receiving Raft messages over the network</li>
<li>The core Raft state machine</li>
</ol>
<h3 id="disk">Disk</h3><p>Raft requires that data is stored on disk durably before responding to
a request. But what data exactly? And how should it be stored on disk?</p>
<p>The top left portion of Figure 2 mentioned above describes the state
for a Raft node that must be stored on disk.</p>
<p><img src="/raft-figure2-state.png" alt="/raft-figure2-state.png"></p>
<p>So at a minimum we must find a way to store <code>currentTerm</code>, <code>votedFor</code>
and the <code>log</code> of all entries. But our format on disk will also store a
magic number to identify the data file and a version number for the
disk format itself. And we'll store a checksum for all of this
metadata too.</p>
<p>Why not store the data as JSON? That would be simple! But JSON is
pretty wasteful in space and in serialization and deserialization. And
almost all of the write behavior in Raft is updating metadata and
appending entries to the log.</p>
<p>So I chose to store the data in a binary format on disk organized in
"pages". A page is a 512- or 4096-byte chunk. This is what disks, and
file systems, and operating systems
<a href="https://docs.pmem.io/persistent-memory/getting-started-guide/creating-development-environments/linux-environments/advanced-topics/i-o-alignment-considerations">like</a>.</p>
<div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">PAGESIZE</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">512</span><span class="p">;</span>

<span class="c1">//        ON DISK FORMAT</span>
<span class="c1">//</span>
<span class="c1">// | Byte Range     | Value          |</span>
<span class="c1">// |----------------|----------------|</span>
<span class="c1">// |        0 - 4   | Magic Number   |</span>
<span class="c1">// |        4 - 8   | Format Version |</span>
<span class="c1">// |        8 - 16  | Term           |</span>
<span class="c1">// |       16 - 32  | Voted For      |</span>
<span class="c1">// |       32 - 40  | Log Length     |</span>
<span class="c1">// |       40 - 44  | Checksum       |</span>
<span class="c1">// | PAGESIZE - EOF | Log Entries    |</span>
</pre></div>
<p>This is pretty generous with space overall. 16 bytes (a <code>u128</code>) for
the <code>Voted For</code> field specifically though means we can use UUIDs for
server IDs.</p>
<p>Every time we write the metadata page, we'll update the checksum
too. And every time we read the metadata page, we'll compute the
checksum and compare it to the one on disk. If they differ, we'll
panic. This is a sign of data corruption; the user must restore from
backups.</p>
<h4 id="a-log-entry">A log entry</h4><p>Now how will log entries be stored? According to Figure 2, the log
entry consists of a term and a command. The command is an arbitrarily
long series of bytes.</p>
<p>To keep the code simple and to keep IO alignment, we'll say that each
log entry will be written out into N complete pages. Our code will pad
out entries so that they always take up a full page.</p>
<p>The first byte of each log entry page will indicate whether the page
is an overflow page for an entry or the start of an entry.</p>
<p>And again, we'll checksum each entry as we write and validate the
checksum every time we read an entry.</p>
<p>But there's one last thing to consider: as various nodes in the
cluster catch up to the leader, they end up asking for entries all
over the place. If we store entries in an append-only log with no
other metadata, and because each entry consists of a variable number
of pages on disk, it will be a O(n) search from the start or the end
to find a particular entry.</p>
<p>This is terrible as the log grows. So we'll also store the log entry
index redundantly along with the entry itself.</p>
<p>Finally, we'll also store a <code>Client Serial Id</code> that uniquely
identifies the message (per client) and <code>Id</code> of the client that sent
the message, so that we can alert the client about the message when
the message has been committed.</p>
<div class="highlight"><pre><span></span><span class="c1">//           ON DISK LOG ENTRY FORMAT</span>
<span class="c1">//</span>
<span class="c1">// | Byte Range                   | Value              |</span>
<span class="c1">// |------------------------------|--------------------|</span>
<span class="c1">// |  0                           | Entry Start Marker |</span>
<span class="c1">// |  1 - 5                       | Checksum           |</span>
<span class="c1">// |  5 - 13                      | Log Index          |</span>
<span class="c1">// | 13 - 21                      | Term               |</span>
<span class="c1">// | 21 - 37                      | Client Serial Id   |</span>
<span class="c1">// | 37 - 53                      | Client Id          |</span>
<span class="c1">// | 53 - 61                      | Command Length     |</span>
<span class="c1">// | 61 - (61 + $Command Length$) | Command            |</span>
<span class="c1">//</span>
<span class="c1">// $Entry Start$ is `1` when the page is the start of an entry, not an</span>
<span class="c1">// overflow page.</span>
</pre></div>
<p>Like <code>Voted For</code> above, <code>Client Serial Id</code> is a 16-byte
identifier. The node identifier everywhere is 16 bytes.</p>
<h4 id="metadata-and-log-entries-in-bulk">Metadata and log entries in bulk</h4><p>Now that we've built support for encoding and decoding a single log
entry, we need to build support for updating the metadata page,
reading and writing multiple log entries, and looking up a particular
log entry from disk.</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">DurableState</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// In-memory data.</span>
<span class="w">    </span><span class="n">last_log_term</span>: <span class="kt">u64</span><span class="p">,</span>
<span class="w">    </span><span class="n">next_log_index</span>: <span class="kt">u64</span><span class="p">,</span>
<span class="w">    </span><span class="n">next_log_offset</span>: <span class="kt">u64</span><span class="p">,</span>
<span class="w">    </span><span class="n">file</span>: <span class="nc">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// On-disk data.</span>
<span class="w">    </span><span class="n">current_term</span>: <span class="kt">u64</span><span class="p">,</span>
<span class="w">    </span><span class="n">voted_for</span>: <span class="kt">u128</span><span class="p">,</span><span class="w"> </span><span class="c1">// Zero is the None value. User must not be a valid server id.</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">DurableState</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">data_directory</span>: <span class="kp">&amp;</span><span class="nc">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">,</span><span class="w"> </span><span class="n">id</span>: <span class="kt">u128</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">DurableState</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_directory</span><span class="p">.</span><span class="n">to_path_buf</span><span class="p">();</span>
<span class="w">        </span><span class="n">filename</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="fm">format!</span><span class="p">(</span><span class="s">&quot;server_{}.data&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="p">));</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span>::<span class="n">options</span><span class="p">()</span>
<span class="w">            </span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="w">            </span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="w">            </span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="w">            </span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="w">            </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;Could not open data file.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">DurableState</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">last_log_term</span>: <span class="mi">0</span><span class="p">,</span>
<span class="w">            </span><span class="n">next_log_index</span>: <span class="mi">0</span><span class="p">,</span>
<span class="w">            </span><span class="n">next_log_offset</span>: <span class="nc">PAGESIZE</span><span class="p">,</span>
<span class="w">            </span><span class="n">file</span><span class="p">,</span>

<span class="w">            </span><span class="n">current_term</span>: <span class="mi">0</span><span class="p">,</span>
<span class="w">            </span><span class="n">voted_for</span>: <span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">restore</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// If there&#39;s nothing to restore, calling append with the</span>
<span class="w">        </span><span class="c1">// required 0th empty log entry will be sufficient to get</span>
<span class="w">        </span><span class="c1">// state into the right place.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">file</span><span class="p">.</span><span class="n">metadata</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="n">LogEntry</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">index</span>: <span class="mi">0</span><span class="p">,</span>
<span class="w">                    </span><span class="n">term</span>: <span class="mi">0</span><span class="p">,</span>
<span class="w">                    </span><span class="n">command</span>: <span class="nc">vec</span><span class="o">!</span><span class="p">[],</span>
<span class="w">                    </span><span class="n">client_serial_id</span>: <span class="mi">0</span><span class="p">,</span>
<span class="w">                    </span><span class="n">client_id</span>: <span class="mi">0</span><span class="p">,</span>
<span class="w">                </span><span class="p">}]);</span>
<span class="w">                </span><span class="k">return</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">metadata</span>: <span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="n">PAGESIZE</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">PAGESIZE</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">];</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">file</span><span class="p">.</span><span class="n">read_exact_at</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">metadata</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">        </span><span class="c1">// Magic number check.</span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="mh">0xFABEF15E_</span><span class="k">u32</span><span class="p">.</span><span class="n">to_le_bytes</span><span class="p">());</span>

<span class="w">        </span><span class="c1">// Version number check.</span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="mi">4</span><span class="o">..</span><span class="mi">8</span><span class="p">],</span><span class="w"> </span><span class="mi">1_</span><span class="k">u32</span><span class="p">.</span><span class="n">to_le_bytes</span><span class="p">());</span>

<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">current_term</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u64</span>::<span class="n">from_le_bytes</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="mi">8</span><span class="o">..</span><span class="mi">16</span><span class="p">].</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">());</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">voted_for</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u128</span>::<span class="n">from_le_bytes</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="mi">16</span><span class="o">..</span><span class="mi">32</span><span class="p">].</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">());</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">checksum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span>::<span class="n">from_le_bytes</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="mi">40</span><span class="o">..</span><span class="mi">44</span><span class="p">].</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">());</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">checksum</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">crc32c</span><span class="p">(</span><span class="o">&amp;</span><span class="n">metadata</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">40</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;Bad checksum for data file.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">log_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u64</span>::<span class="n">from_le_bytes</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="mi">32</span><span class="o">..</span><span class="mi">40</span><span class="p">].</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">())</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">scanned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">file</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="n">std</span>::<span class="n">io</span>::<span class="n">SeekFrom</span>::<span class="n">Start</span><span class="p">(</span><span class="n">PAGESIZE</span><span class="p">)).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="n">scanned</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">log_length</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">next_log_index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LogEntry</span>::<span class="n">decode</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">file</span><span class="p">);</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">last_log_term</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">term</span><span class="p">;</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">next_log_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">file</span><span class="p">.</span><span class="n">stream_position</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">            </span><span class="n">scanned</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">append</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">entries</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">LogEntry</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">append_from_index</span><span class="p">(</span><span class="n">entries</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">next_log_index</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Durably add logs to disk.</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">append_from_index</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">entries</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">LogEntry</span><span class="p">],</span><span class="w"> </span><span class="n">from_index</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span>: <span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="n">PAGESIZE</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">PAGESIZE</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">];</span>

<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">next_log_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">offset_from_index</span><span class="p">(</span><span class="n">from_index</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// This is extremely important. Sometimes the log must be</span>
<span class="w">        </span><span class="c1">// truncated. This is what does the truncation. Existing</span>
<span class="w">        </span><span class="c1">// messages are not necessarily overwritten. But metadata for</span>
<span class="w">        </span><span class="c1">// what the current last log index is always correct.</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">next_log_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">from_index</span><span class="p">;</span>

<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">file</span>
<span class="w">            </span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="n">std</span>::<span class="n">io</span>::<span class="n">SeekFrom</span>::<span class="n">Start</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">next_log_offset</span><span class="p">))</span>
<span class="w">            </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">entries</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Write out all new logs.</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">entries</span><span class="p">.</span><span class="n">iter_mut</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">entry</span><span class="p">.</span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">next_log_index</span><span class="p">;</span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">next_log_index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">                </span><span class="fm">assert!</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">next_log_offset</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">PAGESIZE</span><span class="p">);</span>

<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">pages</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entry</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">file</span><span class="p">);</span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">next_log_offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">pages</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">PAGESIZE</span><span class="p">;</span>

<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">last_log_term</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entry</span><span class="p">.</span><span class="n">term</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Write log length metadata.</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">current_term</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">voted_for</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Durably save non-log data.</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">term</span>: <span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="n">voted_for</span>: <span class="kt">u128</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">current_term</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">term</span><span class="p">;</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">voted_for</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">voted_for</span><span class="p">;</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">metadata</span>: <span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="n">PAGESIZE</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">PAGESIZE</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">];</span>
<span class="w">        </span><span class="c1">// Magic number.</span>
<span class="w">        </span><span class="n">metadata</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">4</span><span class="p">].</span><span class="n">copy_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="mh">0xFABEF15E_</span><span class="k">u32</span><span class="p">.</span><span class="n">to_le_bytes</span><span class="p">());</span>
<span class="w">        </span><span class="c1">// Version.</span>
<span class="w">        </span><span class="n">metadata</span><span class="p">[</span><span class="mi">4</span><span class="o">..</span><span class="mi">8</span><span class="p">].</span><span class="n">copy_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">1_</span><span class="k">u32</span><span class="p">.</span><span class="n">to_le_bytes</span><span class="p">());</span>

<span class="w">        </span><span class="n">metadata</span><span class="p">[</span><span class="mi">8</span><span class="o">..</span><span class="mi">16</span><span class="p">].</span><span class="n">copy_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">term</span><span class="p">.</span><span class="n">to_le_bytes</span><span class="p">());</span>

<span class="w">        </span><span class="n">metadata</span><span class="p">[</span><span class="mi">16</span><span class="o">..</span><span class="mi">32</span><span class="p">].</span><span class="n">copy_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">voted_for</span><span class="p">.</span><span class="n">to_le_bytes</span><span class="p">());</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">log_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">next_log_index</span><span class="p">;</span>
<span class="w">        </span><span class="n">metadata</span><span class="p">[</span><span class="mi">32</span><span class="o">..</span><span class="mi">40</span><span class="p">].</span><span class="n">copy_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log_length</span><span class="p">.</span><span class="n">to_le_bytes</span><span class="p">());</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">checksum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">crc32c</span><span class="p">(</span><span class="o">&amp;</span><span class="n">metadata</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">40</span><span class="p">]);</span>
<span class="w">        </span><span class="n">metadata</span><span class="p">[</span><span class="mi">40</span><span class="o">..</span><span class="mi">44</span><span class="p">].</span><span class="n">copy_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">checksum</span><span class="p">.</span><span class="n">to_le_bytes</span><span class="p">());</span>

<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">file</span><span class="p">.</span><span class="n">write_all_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">metadata</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">file</span><span class="p">.</span><span class="n">sync_all</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">offset_from_index</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u64</span> <span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">next_log_index</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">next_log_offset</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">next_log_index</span><span class="p">);</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">page</span>: <span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="n">PAGESIZE</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">PAGESIZE</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">];</span>

<span class="w">        </span><span class="c1">// Rather than linear search backwards, we store the index in</span>
<span class="w">        </span><span class="c1">// the page itself and then do a binary search on disk.</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PAGESIZE</span><span class="p">;</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">next_log_offset</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">PAGESIZE</span><span class="p">;</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">            </span><span class="c1">// Round up to the nearest page.</span>
<span class="w">            </span><span class="n">m</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">PAGESIZE</span><span class="p">;</span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">PAGESIZE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">            </span><span class="c1">// Look for a start of entry page.</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">file</span><span class="p">.</span><span class="n">read_exact_at</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">page</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="n">page</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">m</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">PAGESIZE</span><span class="p">;</span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">file</span><span class="p">.</span><span class="n">read_exact_at</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">page</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="c1">// TODO: Bad idea to hardcode the offset.</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">current_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u64</span>::<span class="n">from_le_bytes</span><span class="p">(</span><span class="n">page</span><span class="p">[</span><span class="mi">13</span><span class="o">..</span><span class="mi">21</span><span class="p">].</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">());</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">current_index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">current_index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// Read until the next entry, set m to the next entry.</span>
<span class="w">                </span><span class="n">page</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">                </span><span class="n">m</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">PAGESIZE</span><span class="p">;</span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">file</span><span class="p">.</span><span class="n">read_exact_at</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">page</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">                </span><span class="k">while</span><span class="w"> </span><span class="n">page</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">m</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">PAGESIZE</span><span class="p">;</span>
<span class="w">                    </span><span class="bp">self</span><span class="p">.</span><span class="n">file</span><span class="p">.</span><span class="n">read_exact_at</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">page</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">PAGESIZE</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="fm">unreachable!</span><span class="p">(</span>
<span class="w">            </span><span class="s">&quot;Could not find index {index} with log length: {}.&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">next_log_index</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">log_at_index</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">i</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">LogEntry</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">offset_from_index</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">file</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="n">std</span>::<span class="n">io</span>::<span class="n">SeekFrom</span>::<span class="n">Start</span><span class="p">(</span><span class="n">offset</span><span class="p">)).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">        </span><span class="n">LogEntry</span>::<span class="n">decode</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">file</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>This is all straightforward like the <code>LogEntry</code> implementation
was. But there are two things to call out.</p>
<p>First, we use binary search when looking up a log entry on disk by its
index. This is critical for latency and throughput because as the
leader quickly adds entries to its own disk, followers may be 100s or
1000s of entries behind, or worse. You don't want to do linear search
hitting disk every time.</p>
<p>That leads to the second point: this implementation on its own is
needlessly bad. What we really need is a cache. A cache we write to
every time we append entries to disk, but that we read from first
before invoking actual disk IO every time we look up an entry.</p>
<p>I dropped the page cache from the code for this post because the code
overall was getting complex. If you want to look at a very dumb
implementation of a page cache, see the <a href="https://github.com/eatonphil/raft-rs/blob/main/src/lib.rs">main branch of this
project</a>. It
is dumb because rather than being FIFO or LIFO or CLOCK or SIEVE, it
simply drops all entries once the cache becomes full.</p>
<p>But even this terrible page cache improves throughput by 10-100x
versus not having any cache at all.</p>
<h3 id="rpc">RPC</h3><h3 id="raft-state-machine">Raft State Machine</h3><h3 id="further-reading">Further reading</h3><ul>
<li><a href="https://raft.github.io/raft.pdf">The Raft Paper</a></li>
<li><a href="https://github.com/ongardie/raft.tla/blob/master/raft.tla">The Raft TLA+ Spec</a></li>
<li><a href="https://web.stanford.edu/~ouster/cgi-bin/papers/OngaroPhD.pdf">The Raft Author's PhD Thesis on Raft</a></li>
<li><a href="https://dataintensive.net/">Designing Data-Intensive Applications</a></li>
</ul>
<p>Thank you to Paul Nowoczynski, Alex Miller, and Jack Vanlightly for
reviewing drafts of this post.</p>

	</div>
	<div class="feedback">
	  <h4>Feedback</h4>
	  <p>As always,
	      please <a href="mailto:phil@eatonphil.com">email</a>
	      or <a href="https://twitter.com/eatonphil">tweet me</a>
	      with questions, corrections, or ideas!</p>

	</div>
      </div>
    </div>
    <footer>
      <div class="container">
	<div>
	  <div id="subscribe">
	    <iframe frameBorder="0" src="https://cdn.forms-content-1.sg-form.com/e8ed4c3b-dd46-11f0-b6e6-ce075f2c5f80"/>

	  </div>
	</div>
      </div>
    </footer>
    <script async onload="loadGA()" src="https://www.googletagmanager.com/gtag/js?id=UA-58109156-2"></script>
    <script>
      function loadGA() {
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());
	  gtag('config', 'UA-58109156-2');
      }
    </script>
    <script defer src="https://cdn.usefathom.com/script.js" data-site="CEPUOLOQ"></script>
  </body>
</html>
