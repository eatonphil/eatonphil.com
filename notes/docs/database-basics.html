<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="canonical" href="https://notes.eatonphil.com/database-basics.html">
    <title>Writing a SQL database from scratch in Go: 1. SELECT, INSERT, CREATE and a REPL | notes.eatonphil.com</title>
    <meta name="description" content="Writing a SQL database from scratch in Go: 1. SELECT, INSERT, CREATE and a REPL" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono">
  </head>
  <body>
    <header>
      <div class="lfw">
	<div class="container">
	  <div class="row">
	    <a href="https://eatonphil.com/30.html">Turning 30, a little fundraiser ðŸŽ‰</a>
	  </div>
	</div>
      </div>
      <div class="container">
        <div>
          <div class="row">
	    <div>
	      <a href="https://eatonphil.com" class="sm-link">
		Home
              </a>
	      <a href="/" class="sm-link">
		Blog
              </a>
	      <a href="/rss.xml" class="sm-link">
		RSS
              </a>
	    </div>

	    <div class="subscribe">
	      <!-- <a href="https://eatonphil.com/hire-me.html">Hire me</a> -->
	      <!--
		  Hardcode link to home page because some pages don't
		  have a subscribe box. Some pages hide the subscribe.
		-->
	      <a href="https://eatonphil.com/subscribe.html">
		Subscribe
	      </a>
            </div>
	  </div>
	  <hr />
	  <div class="">
            <h2>March 6, 2020</h2>
            <h1>Writing a SQL database from scratch in Go: 1. SELECT, INSERT, CREATE and a REPL</h1>
	    
            <div class="row" style="padding-bottom: 5px">
              <div class="tags"><a href="/tags/databases.html" class="tag">databases</a><a href="/tags/go.html" class="tag">go</a><a href="/tags/parsing.html" class="tag">parsing</a><a href="/tags/sql.html" class="tag">sql</a><a href="/tags/postgres.html" class="tag">postgres</a></div>
            </div>
	  </div>
	</div>
      </div>
    </header>
    <div class="container">
      <div class="col-6">
	<div class="post">
          <p class="note">
  Next in database basics:
  <! forgive me, for I have sinned >
  <br />
  <a href="/database-basics-expressions-and-where.html">2. binary expressions and WHERE filters</a>
  <br />
  <a href="/database-basics-indexes.html">3. indexes</a>
  <br />
  <a href="/database-basics-a-database-sql-driver.html">4. a database/sql driver</a>
</p><p>In this series we'll write a rudimentary database from
scratch in Go. Project source code is available on
<a href="https://github.com/eatonphil/gosql">Github</a>.</p>
<p>In this first post we'll build enough of a parser to run some simple
<code>CREATE</code>, <code>INSERT</code>, and <code>SELECT</code>
queries. Then we'll build an in-memory backend
supporting <code>TEXT</code> and <code>INT</code> types and write a
basic REPL.</p>
<p>We'll be able to support the following interaction:</p>
<div class="highlight"><pre><span></span><span class="err">$</span><span class="w"> </span><span class="k">go</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">*</span><span class="p">.</span><span class="k">go</span>
<span class="n">Welcome</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">gosql</span><span class="p">.</span>
<span class="o">#</span><span class="w"> </span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="nb">INT</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="nb">TEXT</span><span class="p">);</span>
<span class="n">ok</span>
<span class="o">#</span><span class="w"> </span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Phil&#39;</span><span class="p">);</span>
<span class="n">ok</span>
<span class="o">#</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users</span><span class="p">;</span>
<span class="o">|</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">|</span>
<span class="o">====================</span>
<span class="o">|</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="n">Phil</span><span class="w"> </span><span class="o">|</span>
<span class="n">ok</span>
<span class="o">#</span><span class="w"> </span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Kate&#39;</span><span class="p">);</span>
<span class="n">ok</span>
<span class="o">#</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users</span><span class="p">;</span>
<span class="o">|</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">|</span>
<span class="o">====================</span>
<span class="o">|</span><span class="w"> </span><span class="n">Phil</span><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span>
<span class="o">|</span><span class="w"> </span><span class="n">Kate</span><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="mi">2</span><span class="w"> </span><span class="o">|</span>
<span class="n">ok</span>
</pre></div>
<p>The first stage will be to map a SQL source into a list of tokens
(lexing). Then we'll call parse functions to find individual SQL
statements (such as <code>SELECT</code>). These parse functions will
in turn call their own helper functions to find patterns of
recursively parseable chunks, keywords, symbols (like parenthesis),
identifiers (like a table name), and numeric or string literals.</p>
<p>Then, we'll write an in-memory backend to do operations based on an
AST. Finally, we'll write a REPL to accept SQL from a CLI and pass it
to the in-memory backend.</p>
<p class="note">
  This post assumes a basic understanding of parsing concepts. We
  won't skip any code, but also won't go into great detail on why we
  structure the way we do.
  <br />
  <br />
  For a simpler introduction to parsing and parsing concepts,
  see <a href="/writing-a-simple-json-parser.html">this post on
  parsing JSON</a>.
</p><h3 id="lexing">Lexing</h3><p>The lexer is responsible for finding every distinct group of
characters in source code: tokens. This will consist primarily of
identifiers, numbers, strings, and symbols.</p>
<p class="note">
  What follows is a second, more orthodox pass at lexing. The first
  pass took a number of shortcuts and couldn't handle spaces in
  strings, for example.
  <br />
  <br />
  <a href="https://github.com/eatonphil/gosql/pull/2">Here is the
  relevant pull request in gosql if you are curious.</a>
</p><p>The gist of the logic will be to pass control to a helper function for
each kind of token. If the helper function succeeds in finding a
token, it will return true and the location for the lexer to start at
next. It will continue doing this until it reaches the end of the
source.</p>
<p>First off, we'll define a few types and constants for use
in <code>lexer.go</code>:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span><span class="w"> </span><span class="nx">gosql</span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;fmt&quot;</span>
<span class="w">    </span><span class="s">&quot;strings&quot;</span>
<span class="p">)</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">location</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">line</span><span class="w"> </span><span class="kt">uint</span>
<span class="w">    </span><span class="nx">col</span><span class="w">  </span><span class="kt">uint</span>
<span class="p">}</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">keyword</span><span class="w"> </span><span class="kt">string</span>

<span class="kd">const</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="nx">selectKeyword</span><span class="w"> </span><span class="nx">keyword</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;select&quot;</span>
<span class="w">    </span><span class="nx">fromKeyword</span><span class="w">   </span><span class="nx">keyword</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;from&quot;</span>
<span class="w">    </span><span class="nx">asKeyword</span><span class="w">     </span><span class="nx">keyword</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;as&quot;</span>
<span class="w">    </span><span class="nx">tableKeyword</span><span class="w">  </span><span class="nx">keyword</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;table&quot;</span>
<span class="w">    </span><span class="nx">createKeyword</span><span class="w"> </span><span class="nx">keyword</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;create&quot;</span>
<span class="w">    </span><span class="nx">insertKeyword</span><span class="w"> </span><span class="nx">keyword</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;insert&quot;</span>
<span class="w">    </span><span class="nx">intoKeyword</span><span class="w">   </span><span class="nx">keyword</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;into&quot;</span>
<span class="w">    </span><span class="nx">valuesKeyword</span><span class="w"> </span><span class="nx">keyword</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;values&quot;</span>
<span class="w">    </span><span class="nx">intKeyword</span><span class="w">    </span><span class="nx">keyword</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;int&quot;</span>
<span class="w">    </span><span class="nx">textKeyword</span><span class="w">   </span><span class="nx">keyword</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;text&quot;</span>
<span class="p">)</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">symbol</span><span class="w"> </span><span class="kt">string</span>

<span class="kd">const</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="nx">semicolonSymbol</span><span class="w">  </span><span class="nx">symbol</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;;&quot;</span>
<span class="w">    </span><span class="nx">asteriskSymbol</span><span class="w">   </span><span class="nx">symbol</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;*&quot;</span>
<span class="w">    </span><span class="nx">commaSymbol</span><span class="w">      </span><span class="nx">symbol</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;,&quot;</span>
<span class="w">    </span><span class="nx">leftparenSymbol</span><span class="w">  </span><span class="nx">symbol</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;(&quot;</span>
<span class="w">    </span><span class="nx">rightparenSymbol</span><span class="w"> </span><span class="nx">symbol</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;)&quot;</span>
<span class="p">)</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">tokenKind</span><span class="w"> </span><span class="kt">uint</span>

<span class="kd">const</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="nx">keywordKind</span><span class="w"> </span><span class="nx">tokenKind</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">iota</span>
<span class="w">    </span><span class="nx">symbolKind</span>
<span class="w">    </span><span class="nx">identifierKind</span>
<span class="w">    </span><span class="nx">stringKind</span>
<span class="w">    </span><span class="nx">numericKind</span>
<span class="p">)</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">token</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">value</span><span class="w"> </span><span class="kt">string</span>
<span class="w">    </span><span class="nx">kind</span><span class="w">  </span><span class="nx">tokenKind</span>
<span class="w">    </span><span class="nx">loc</span><span class="w">   </span><span class="nx">location</span>
<span class="p">}</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">cursor</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">pointer</span><span class="w"> </span><span class="kt">uint</span>
<span class="w">    </span><span class="nx">loc</span><span class="w">     </span><span class="nx">location</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">t</span><span class="w"> </span><span class="o">*</span><span class="nx">token</span><span class="p">)</span><span class="w"> </span><span class="nx">equals</span><span class="p">(</span><span class="nx">other</span><span class="w"> </span><span class="o">*</span><span class="nx">token</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">other</span><span class="p">.</span><span class="nx">value</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">other</span><span class="p">.</span><span class="nx">kind</span>
<span class="p">}</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">lexer</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span>
</pre></div>
<p>Next we'll write out the main loop:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">lex</span><span class="p">(</span><span class="nx">source</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">([]</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">tokens</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">token</span><span class="p">{}</span>
<span class="w">    </span><span class="nx">cur</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">cursor</span><span class="p">{}</span>

<span class="nx">lex</span><span class="p">:</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">source</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">lexers</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="nx">lexer</span><span class="p">{</span><span class="nx">lexKeyword</span><span class="p">,</span><span class="w"> </span><span class="nx">lexSymbol</span><span class="p">,</span><span class="w"> </span><span class="nx">lexString</span><span class="p">,</span><span class="w"> </span><span class="nx">lexNumeric</span><span class="p">,</span><span class="w"> </span><span class="nx">lexIdentifier</span><span class="p">}</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">l</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">lexers</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">l</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span><span class="w"> </span><span class="nx">cur</span><span class="p">);</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">cur</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newCursor</span>

<span class="w">                </span><span class="c1">// Omit nil tokens for valid, but empty syntax like newlines</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="nx">token</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="nx">tokens</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">token</span><span class="p">)</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="k">continue</span><span class="w"> </span><span class="nx">lex</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nx">hint</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s">&quot;&quot;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">tokens</span><span class="p">)</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">hint</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot; after &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">tokens</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">tokens</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nx">value</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;Unable to lex token%s, at %d:%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">hint</span><span class="p">,</span><span class="w"> </span><span class="nx">cur</span><span class="p">.</span><span class="nx">loc</span><span class="p">.</span><span class="nx">line</span><span class="p">,</span><span class="w"> </span><span class="nx">cur</span><span class="p">.</span><span class="nx">loc</span><span class="p">.</span><span class="nx">col</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
<p>Then we'll write a helper for each kind of fundemental token.</p>
<h4 id="analyzing-numbers">Analyzing numbers</h4><p>Numbers are the most complex. So we'll refer to the <a href="https://www.postgresql.org/docs/current/sql-syntax-lexical.html">PostgreSQL
documentation (section
4.1.2.6)</a>
for what constitutes a valid number.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">lexNumeric</span><span class="p">(</span><span class="nx">source</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="w"> </span><span class="nx">cursor</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">cur</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ic</span>

<span class="w">    </span><span class="nx">periodFound</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="nx">expMarkerFound</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kc">false</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">source</span><span class="p">));</span><span class="w"> </span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">source</span><span class="p">[</span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="p">]</span>
<span class="w">        </span><span class="nx">cur</span><span class="p">.</span><span class="nx">loc</span><span class="p">.</span><span class="nx">col</span><span class="o">++</span>

<span class="w">        </span><span class="nx">isDigit</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="sc">&#39;0&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="sc">&#39;9&#39;</span>
<span class="w">        </span><span class="nx">isPeriod</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;.&#39;</span>
<span class="w">        </span><span class="nx">isExpMarker</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;e&#39;</span>

<span class="w">        </span><span class="c1">// Must start with a digit or period</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">ic</span><span class="p">.</span><span class="nx">pointer</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">isDigit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">!</span><span class="nx">isPeriod</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="nx">periodFound</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">isPeriod</span>
<span class="w">            </span><span class="k">continue</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">isPeriod</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">periodFound</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="nx">periodFound</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">true</span>
<span class="w">            </span><span class="k">continue</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">isExpMarker</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">expMarkerFound</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="c1">// No periods allowed after expMarker</span>
<span class="w">            </span><span class="nx">periodFound</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">true</span>
<span class="w">            </span><span class="nx">expMarkerFound</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">true</span>

<span class="w">            </span><span class="c1">// expMarker must be followed by digits</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="nx">cNext</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">source</span><span class="p">[</span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">cNext</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;-&#39;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">cNext</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;+&#39;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="o">++</span>
<span class="w">                </span><span class="nx">cur</span><span class="p">.</span><span class="nx">loc</span><span class="p">.</span><span class="nx">col</span><span class="o">++</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="k">continue</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">isDigit</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">break</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// No characters accumulated</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">ic</span><span class="p">.</span><span class="nx">pointer</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">token</span><span class="p">{</span>
<span class="w">        </span><span class="nx">value</span><span class="p">:</span><span class="w"> </span><span class="nx">source</span><span class="p">[</span><span class="nx">ic</span><span class="p">.</span><span class="nx">pointer</span><span class="p">:</span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="p">],</span>
<span class="w">        </span><span class="nx">loc</span><span class="p">:</span><span class="w">   </span><span class="nx">ic</span><span class="p">.</span><span class="nx">loc</span><span class="p">,</span>
<span class="w">        </span><span class="nx">kind</span><span class="p">:</span><span class="w">  </span><span class="nx">numericKind</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span><span class="nx">cur</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="p">}</span>
</pre></div>
<h4 id="analyzing-strings">Analyzing strings</h4><p>Strings must start and end with a single apostrophe. They can contain
a single apostophe if it is followed by another single
apostrophe. We'll put this kind of character delimited lexing logic
into a helper function so we can use it again when analyzing
identifiers.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">lexCharacterDelimited</span><span class="p">(</span><span class="nx">source</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">delimiter</span><span class="w"> </span><span class="kt">byte</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">cur</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ic</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">source</span><span class="p">[</span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="p">:])</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">source</span><span class="p">[</span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">delimiter</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">cur</span><span class="p">.</span><span class="nx">loc</span><span class="p">.</span><span class="nx">col</span><span class="o">++</span>
<span class="w">    </span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="o">++</span>

<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">source</span><span class="p">));</span><span class="w"> </span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">source</span><span class="p">[</span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="p">]</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">delimiter</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// SQL escapes are via double characters, not backslash.</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">source</span><span class="p">))</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">source</span><span class="p">[</span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">delimiter</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">token</span><span class="p">{</span>
<span class="w">                    </span><span class="nx">value</span><span class="p">:</span><span class="w"> </span><span class="nb">string</span><span class="p">(</span><span class="nx">value</span><span class="p">),</span>
<span class="w">                    </span><span class="nx">loc</span><span class="p">:</span><span class="w">   </span><span class="nx">ic</span><span class="p">.</span><span class="nx">loc</span><span class="p">,</span>
<span class="w">                    </span><span class="nx">kind</span><span class="p">:</span><span class="w">  </span><span class="nx">stringKind</span><span class="p">,</span>
<span class="w">                </span><span class="p">},</span><span class="w"> </span><span class="nx">cur</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">value</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="nx">delimiter</span><span class="p">)</span>
<span class="w">                </span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="o">++</span>
<span class="w">                </span><span class="nx">cur</span><span class="p">.</span><span class="nx">loc</span><span class="p">.</span><span class="nx">col</span><span class="o">++</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nx">value</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">)</span>
<span class="w">        </span><span class="nx">cur</span><span class="p">.</span><span class="nx">loc</span><span class="p">.</span><span class="nx">col</span><span class="o">++</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">lexString</span><span class="p">(</span><span class="nx">source</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="w"> </span><span class="nx">cursor</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">lexCharacterDelimited</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;\&#39;&#39;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<h4 id="analyzing-symbols-and-keywords">Analyzing symbols and keywords</h4><p>Symbols come from a fixed set of strings, so they're easy
to compare against. Whitespace should be thrown away.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">lexSymbol</span><span class="p">(</span><span class="nx">source</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="w"> </span><span class="nx">cursor</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">source</span><span class="p">[</span><span class="nx">ic</span><span class="p">.</span><span class="nx">pointer</span><span class="p">]</span>
<span class="w">    </span><span class="nx">cur</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ic</span>
<span class="w">    </span><span class="c1">// Will get overwritten later if not an ignored syntax</span>
<span class="w">    </span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="o">++</span>
<span class="w">    </span><span class="nx">cur</span><span class="p">.</span><span class="nx">loc</span><span class="p">.</span><span class="nx">col</span><span class="o">++</span>

<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Syntax that should be thrown away</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="nx">cur</span><span class="p">.</span><span class="nx">loc</span><span class="p">.</span><span class="nx">line</span><span class="o">++</span>
<span class="w">        </span><span class="nx">cur</span><span class="p">.</span><span class="nx">loc</span><span class="p">.</span><span class="nx">col</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">        </span><span class="k">fallthrough</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="sc">&#39;\t&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="k">fallthrough</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">cur</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Syntax that should be kept</span>
<span class="w">    </span><span class="nx">symbols</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="nx">symbol</span><span class="p">{</span>
<span class="w">        </span><span class="nx">commaSymbol</span><span class="p">,</span>
<span class="w">        </span><span class="nx">leftParenSymbol</span><span class="p">,</span>
<span class="w">        </span><span class="nx">rightParenSymbol</span><span class="p">,</span>
<span class="w">        </span><span class="nx">semicolonSymbol</span><span class="p">,</span>
<span class="w">        </span><span class="nx">asteriskSymbol</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">options</span><span class="w"> </span><span class="p">[]</span><span class="kt">string</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">symbols</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">options</span><span class="p">,</span><span class="w"> </span><span class="nb">string</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Use `ic`, not `cur`</span>
<span class="w">    </span><span class="nx">match</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">longestMatch</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="p">,</span><span class="w"> </span><span class="nx">options</span><span class="p">)</span>
<span class="w">    </span><span class="c1">// Unknown character</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">match</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">ic</span><span class="p">.</span><span class="nx">pointer</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">match</span><span class="p">))</span>
<span class="w">    </span><span class="nx">cur</span><span class="p">.</span><span class="nx">loc</span><span class="p">.</span><span class="nx">col</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">ic</span><span class="p">.</span><span class="nx">loc</span><span class="p">.</span><span class="nx">col</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">match</span><span class="p">))</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">token</span><span class="p">{</span>
<span class="w">        </span><span class="nx">value</span><span class="p">:</span><span class="w"> </span><span class="nx">match</span><span class="p">,</span>
<span class="w">        </span><span class="nx">loc</span><span class="p">:</span><span class="w">   </span><span class="nx">ic</span><span class="p">.</span><span class="nx">loc</span><span class="p">,</span>
<span class="w">        </span><span class="nx">kind</span><span class="p">:</span><span class="w">  </span><span class="nx">symbolKind</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span><span class="nx">cur</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="p">}</span>
</pre></div>
<p>Keywords are even simpler, and use the same <code>longestMatch</code>
helper.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">lexKeyword</span><span class="p">(</span><span class="nx">source</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="w"> </span><span class="nx">cursor</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">cur</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ic</span>
<span class="w">    </span><span class="nx">keywords</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="nx">keyword</span><span class="p">{</span>
<span class="w">        </span><span class="nx">selectKeyword</span><span class="p">,</span>
<span class="w">        </span><span class="nx">insertKeyword</span><span class="p">,</span>
<span class="w">        </span><span class="nx">valuesKeyword</span><span class="p">,</span>
<span class="w">        </span><span class="nx">tableKeyword</span><span class="p">,</span>
<span class="w">        </span><span class="nx">createKeyword</span><span class="p">,</span>
<span class="w">        </span><span class="nx">whereKeyword</span><span class="p">,</span>
<span class="w">        </span><span class="nx">fromKeyword</span><span class="p">,</span>
<span class="w">        </span><span class="nx">intoKeyword</span><span class="p">,</span>
<span class="w">        </span><span class="nx">textKeyword</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">options</span><span class="w"> </span><span class="p">[]</span><span class="kt">string</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">k</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">keywords</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">options</span><span class="p">,</span><span class="w"> </span><span class="nb">string</span><span class="p">(</span><span class="nx">k</span><span class="p">))</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">match</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">longestMatch</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="p">,</span><span class="w"> </span><span class="nx">options</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">match</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">ic</span><span class="p">.</span><span class="nx">pointer</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">match</span><span class="p">))</span>
<span class="w">    </span><span class="nx">cur</span><span class="p">.</span><span class="nx">loc</span><span class="p">.</span><span class="nx">col</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">ic</span><span class="p">.</span><span class="nx">loc</span><span class="p">.</span><span class="nx">col</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">match</span><span class="p">))</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">token</span><span class="p">{</span>
<span class="w">        </span><span class="nx">value</span><span class="p">:</span><span class="w"> </span><span class="nx">match</span><span class="p">,</span>
<span class="w">        </span><span class="nx">kind</span><span class="p">:</span><span class="w">  </span><span class="nx">kind</span><span class="p">,</span>
<span class="w">        </span><span class="nx">loc</span><span class="p">:</span><span class="w">   </span><span class="nx">ic</span><span class="p">.</span><span class="nx">loc</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span><span class="nx">cur</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="p">}</span>
</pre></div>
<p>And finally we implement the <code>longestMatch</code> helper:</p>
<div class="highlight"><pre><span></span><span class="c1">// longestMatch iterates through a source string starting at the given</span>
<span class="c1">// cursor to find the longest matching substring among the provided</span>
<span class="c1">// options</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">longestMatch</span><span class="p">(</span><span class="nx">source</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">options</span><span class="w"> </span><span class="p">[]</span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">skipList</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">match</span><span class="w"> </span><span class="kt">string</span>

<span class="w">    </span><span class="nx">cur</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ic</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">source</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="nx">value</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="nx">strings</span><span class="p">.</span><span class="nx">ToLower</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">source</span><span class="p">[</span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="p">]))</span><span class="o">...</span><span class="p">)</span>
<span class="w">        </span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="o">++</span>

<span class="w">    </span><span class="nx">match</span><span class="p">:</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">option</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">options</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">skip</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">skipList</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">skip</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="k">continue</span><span class="w"> </span><span class="nx">match</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="c1">// Deal with cases like INT vs INTO</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">option</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">string</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">skipList</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">skipList</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">option</span><span class="p">)</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">match</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="nx">match</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">option</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="k">continue</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="nx">sharesPrefix</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">string</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">option</span><span class="p">[:</span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="o">-</span><span class="nx">ic</span><span class="p">.</span><span class="nx">pointer</span><span class="p">]</span>
<span class="w">            </span><span class="nx">tooLong</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">option</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">tooLong</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">!</span><span class="nx">sharesPrefix</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">skipList</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">skipList</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">skipList</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">options</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">break</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">match</span>
<span class="p">}</span>
</pre></div>
<h4 id="analyzing-identifiers">Analyzing identifiers</h4><p>An identifier is either a double-quoted string or a group of
characters starting with an alphabetical character and possibly
containing numbers and underscores.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">lexIdentifier</span><span class="p">(</span><span class="nx">source</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="w"> </span><span class="nx">cursor</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Handle separately if is a double-quoted identifier</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">lexCharacterDelimited</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;&quot;&#39;</span><span class="p">);</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">cur</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ic</span>

<span class="w">    </span><span class="nx">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">source</span><span class="p">[</span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="p">]</span>
<span class="w">    </span><span class="c1">// Other characters count too, big ignoring non-ascii for now</span>
<span class="w">    </span><span class="nx">isAlphabetical</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="sc">&#39;Z&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="sc">&#39;z&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">isAlphabetical</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="o">++</span>
<span class="w">    </span><span class="nx">cur</span><span class="p">.</span><span class="nx">loc</span><span class="p">.</span><span class="nx">col</span><span class="o">++</span>

<span class="w">    </span><span class="nx">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">{</span><span class="nx">c</span><span class="p">}</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">source</span><span class="p">));</span><span class="w"> </span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">c</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">source</span><span class="p">[</span><span class="nx">cur</span><span class="p">.</span><span class="nx">pointer</span><span class="p">]</span>

<span class="w">        </span><span class="c1">// Other characters count too, big ignoring non-ascii for now</span>
<span class="w">        </span><span class="nx">isAlphabetical</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="sc">&#39;Z&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="sc">&#39;z&#39;</span><span class="p">)</span>
<span class="w">        </span><span class="nx">isNumeric</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="sc">&#39;0&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="sc">&#39;9&#39;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">isAlphabetical</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">isNumeric</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;$&#39;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;_&#39;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">value</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">)</span>
<span class="w">            </span><span class="nx">cur</span><span class="p">.</span><span class="nx">loc</span><span class="p">.</span><span class="nx">col</span><span class="o">++</span>
<span class="w">            </span><span class="k">continue</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">break</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">ic</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">token</span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Unquoted dentifiers are case-insensitive</span>
<span class="w">        </span><span class="nx">value</span><span class="p">:</span><span class="w"> </span><span class="nx">strings</span><span class="p">.</span><span class="nx">ToLower</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">value</span><span class="p">)),</span>
<span class="w">        </span><span class="nx">loc</span><span class="p">:</span><span class="w">   </span><span class="nx">ic</span><span class="p">.</span><span class="nx">loc</span><span class="p">,</span>
<span class="w">        </span><span class="nx">kind</span><span class="p">:</span><span class="w">  </span><span class="nx">identifierKind</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span><span class="nx">cur</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="p">}</span>
</pre></div>
<p>And that's it for the lexer! If you copy
<a href="https://github.com/eatonphil/gosql/blob/master/lexer_test.go">lexer_test.go</a>
from the main project, the tests should now pass.</p>
<h3 id="ast-model">AST model</h3><p>At the highest level, an AST is a collection of statements:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">Ast</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">Statements</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">Statement</span>
<span class="p">}</span>
</pre></div>
<p>A statement, for now, is one of <code>INSERT</code>,
<code>CREATE</code>, or <code>SELECT</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">AstKind</span><span class="w"> </span><span class="kt">uint</span>

<span class="kd">const</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="nx">SelectKind</span><span class="w"> </span><span class="nx">AstKind</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">iota</span>
<span class="w">    </span><span class="nx">CreateTableKind</span>
<span class="w">    </span><span class="nx">InsertKind</span>
<span class="p">)</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">Statement</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">SelectStatement</span><span class="w">      </span><span class="o">*</span><span class="nx">SelectStatement</span>
<span class="w">    </span><span class="nx">CreateTableStatement</span><span class="w"> </span><span class="o">*</span><span class="nx">CreateTableStatement</span>
<span class="w">    </span><span class="nx">InsertStatement</span><span class="w">      </span><span class="o">*</span><span class="nx">InsertStatement</span>
<span class="w">    </span><span class="nx">Kind</span><span class="w">                 </span><span class="nx">AstKind</span>
<span class="p">}</span>
</pre></div>
<h4 id="insert">INSERT</h4><p>An insert statement, for now, has a table name and a list of values to
insert:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">InsertStatement</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">table</span><span class="w">  </span><span class="nx">token</span>
<span class="w">    </span><span class="nx">values</span><span class="w"> </span><span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">expression</span>
<span class="p">}</span>
</pre></div>
<p>An expression is a literal token or (in the future) a function call or
inline operation:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">expressionKind</span><span class="w"> </span><span class="kt">uint</span>

<span class="kd">const</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="nx">literalKind</span><span class="w"> </span><span class="nx">expressionKind</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">iota</span>
<span class="p">)</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">expression</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">literal</span><span class="w"> </span><span class="o">*</span><span class="nx">token</span>
<span class="w">    </span><span class="nx">kind</span><span class="w">    </span><span class="nx">expressionKind</span>
<span class="p">}</span>
</pre></div>
<h4 id="create">CREATE</h4><p>A create statement, for now, has a table name and a list of column
names and types:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">columnDefinition</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">name</span><span class="w">     </span><span class="nx">token</span>
<span class="w">    </span><span class="nx">datatype</span><span class="w"> </span><span class="nx">token</span>
<span class="p">}</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">CreateTableStatement</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">name</span><span class="w"> </span><span class="nx">token</span>
<span class="w">    </span><span class="nx">cols</span><span class="w"> </span><span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">columnDefinition</span>
<span class="p">}</span>
</pre></div>
<h4 id="select">SELECT</h4><p>A select statement, for now, has a table name and a list of column
names:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">SelectStatement</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">item</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">expression</span>
<span class="w">    </span><span class="nx">from</span><span class="w"> </span><span class="nx">token</span>
<span class="p">}</span>
</pre></div>
<p>And that's it for the AST.</p>
<h3 id="parsing">Parsing</h3><p>The <code>Parse</code> entrypoint will take a list of tokens and
attempt to parse statements, separated by a semi-colon, until it
reaches the last token.</p>
<p>In general our strategy will be to increment and pass around a cursor
containing the current position of unparsed tokens. Each helper will
return the new cursor that the caller should start from.</p>
<div class="highlight"><pre><span></span><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;errors&quot;</span>
<span class="w">    </span><span class="s">&quot;fmt&quot;</span>
<span class="p">)</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">tokenFromKeyword</span><span class="p">(</span><span class="nx">k</span><span class="w"> </span><span class="nx">keyword</span><span class="p">)</span><span class="w"> </span><span class="nx">token</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">token</span><span class="p">{</span>
<span class="w">        </span><span class="nx">kind</span><span class="p">:</span><span class="w">  </span><span class="nx">keywordKind</span><span class="p">,</span>
<span class="w">        </span><span class="nx">value</span><span class="p">:</span><span class="w"> </span><span class="nb">string</span><span class="p">(</span><span class="nx">k</span><span class="p">),</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">s</span><span class="w"> </span><span class="nx">symbol</span><span class="p">)</span><span class="w"> </span><span class="nx">token</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">token</span><span class="p">{</span>
<span class="w">        </span><span class="nx">kind</span><span class="p">:</span><span class="w">  </span><span class="nx">symbolKind</span><span class="p">,</span>
<span class="w">        </span><span class="nx">value</span><span class="p">:</span><span class="w"> </span><span class="nb">string</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">expectToken</span><span class="p">(</span><span class="nx">tokens</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="nx">t</span><span class="w"> </span><span class="nx">token</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">cursor</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">tokens</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">equals</span><span class="p">(</span><span class="nx">tokens</span><span class="p">[</span><span class="nx">cursor</span><span class="p">])</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="nx">msg</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">*</span><span class="nx">token</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">cursor</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">tokens</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">c</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">tokens</span><span class="p">[</span><span class="nx">cursor</span><span class="p">]</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">c</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">tokens</span><span class="p">[</span><span class="nx">cursor</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;[%d,%d]: %s, got: %s\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">.</span><span class="nx">loc</span><span class="p">.</span><span class="nx">line</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">.</span><span class="nx">loc</span><span class="p">.</span><span class="nx">col</span><span class="p">,</span><span class="w"> </span><span class="nx">msg</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">Parse</span><span class="p">(</span><span class="nx">source</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">Ast</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">lex</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">Ast</span><span class="p">{}</span>
<span class="w">    </span><span class="nx">cursor</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">cursor</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">tokens</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">stmt</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parseStatement</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">semicolonSymbol</span><span class="p">))</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected statement&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;Failed to parse, expected statement&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nx">cursor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newCursor</span>

<span class="w">        </span><span class="nx">a</span><span class="p">.</span><span class="nx">Statements</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Statements</span><span class="p">,</span><span class="w"> </span><span class="nx">stmt</span><span class="p">)</span>

<span class="w">        </span><span class="nx">atLeastOneSemicolon</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kc">false</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">expectToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">semicolonSymbol</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">cursor</span><span class="o">++</span>
<span class="w">            </span><span class="nx">atLeastOneSemicolon</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">atLeastOneSemicolon</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected semi-colon delimiter between statements&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;Missing semi-colon between statements&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
<h4 id="parsing-statements">Parsing statements</h4><p>Each statement will be one of <code>INSERT</code>,
<code>CREATE</code>, or <code>SELECT</code>. The
<code>parseStatement</code> helper will call a helper on each of these
statement types and return <code>true</code> if one of them succeeds
in parsing.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">parseStatement</span><span class="p">(</span><span class="nx">tokens</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="nx">delimiter</span><span class="w"> </span><span class="nx">token</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">Statement</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">cursor</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">initialCursor</span>

<span class="w">    </span><span class="c1">// Look for a SELECT statement</span>
<span class="w">    </span><span class="nx">semicolonToken</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">semicolonSymbol</span><span class="p">)</span>
<span class="w">    </span><span class="nx">slct</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parseSelectStatement</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">semicolonToken</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Statement</span><span class="p">{</span>
<span class="w">            </span><span class="nx">Kind</span><span class="p">:</span><span class="w">            </span><span class="nx">SelectKind</span><span class="p">,</span>
<span class="w">            </span><span class="nx">SelectStatement</span><span class="p">:</span><span class="w"> </span><span class="nx">slct</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Look for a INSERT statement</span>
<span class="w">    </span><span class="nx">inst</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parseInsertStatement</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">semicolonToken</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Statement</span><span class="p">{</span>
<span class="w">            </span><span class="nx">Kind</span><span class="p">:</span><span class="w">            </span><span class="nx">InsertKind</span><span class="p">,</span>
<span class="w">            </span><span class="nx">InsertStatement</span><span class="p">:</span><span class="w"> </span><span class="nx">inst</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Look for a CREATE statement</span>
<span class="w">    </span><span class="nx">crtTbl</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parseCreateTableStatement</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">semicolonToken</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Statement</span><span class="p">{</span>
<span class="w">            </span><span class="nx">Kind</span><span class="p">:</span><span class="w">                 </span><span class="nx">CreateTableKind</span><span class="p">,</span>
<span class="w">            </span><span class="nx">CreateTableStatement</span><span class="p">:</span><span class="w"> </span><span class="nx">crtTbl</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="p">}</span>
</pre></div>
<h4 id="parsing-select-statements">Parsing select statements</h4><p>Parsing <code>SELECT</code> statements is easy. We'll look for the
following token pattern:</p>
<ol>
<li><code>SELECT</code></li>
<li><code>$expression [, ...]</code></li>
<li><code>FROM</code></li>
<li><code>$table-name</code></li>
</ol>
<p>Sketching that out we get:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">parseSelectStatement</span><span class="p">(</span><span class="nx">tokens</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="nx">delimiter</span><span class="w"> </span><span class="nx">token</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">SelectStatement</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">cursor</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">initialCursor</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">expectToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">tokenFromKeyword</span><span class="p">(</span><span class="nx">selectKeyword</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">cursor</span><span class="o">++</span>

<span class="w">    </span><span class="nx">slct</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">SelectStatement</span><span class="p">{}</span>

<span class="w">    </span><span class="nx">exps</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parseExpressions</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="p">[]</span><span class="nx">token</span><span class="p">{</span><span class="nx">tokenFromKeyword</span><span class="p">(</span><span class="nx">fromKeyword</span><span class="p">),</span><span class="w"> </span><span class="nx">delimiter</span><span class="p">})</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">slct</span><span class="p">.</span><span class="nx">item</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="o">*</span><span class="nx">exps</span>
<span class="w">    </span><span class="nx">cursor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newCursor</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">expectToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">tokenFromKeyword</span><span class="p">(</span><span class="nx">fromKeyword</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">cursor</span><span class="o">++</span>

<span class="w">        </span><span class="nx">from</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parseToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">identifierKind</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected FROM token&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nx">slct</span><span class="p">.</span><span class="nx">from</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="o">*</span><span class="nx">from</span>
<span class="w">        </span><span class="nx">cursor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newCursor</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">slct</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="p">}</span>
</pre></div>
<p>The <code>parseToken</code> helper will look for a token of a
particular token kind.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">parseToken</span><span class="p">(</span><span class="nx">tokens</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="nx">kind</span><span class="w"> </span><span class="nx">tokenKind</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">cursor</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">initialCursor</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">cursor</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">tokens</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">current</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">tokens</span><span class="p">[</span><span class="nx">cursor</span><span class="p">]</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">current</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">kind</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">current</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="p">}</span>
</pre></div>
<p>The <code>parseExpressions</code> helper will look for tokens
separated by a comma until a delimiter is found. It will use existing
helpers plus <code>parseExpression</code>.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">parseExpressions</span><span class="p">(</span><span class="nx">tokens</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="nx">delimiters</span><span class="w"> </span><span class="p">[]</span><span class="nx">token</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">expression</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">cursor</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">initialCursor</span>

<span class="w">    </span><span class="nx">exps</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">expression</span><span class="p">{}</span>
<span class="nx">outer</span><span class="p">:</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">cursor</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">tokens</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Look for delimiter</span>
<span class="w">        </span><span class="nx">current</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">tokens</span><span class="p">[</span><span class="nx">cursor</span><span class="p">]</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">delimiter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">delimiters</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">delimiter</span><span class="p">.</span><span class="nx">equals</span><span class="p">(</span><span class="nx">current</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">break</span><span class="w"> </span><span class="nx">outer</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Look for comma</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">exps</span><span class="p">)</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">expectToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">commaSymbol</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected comma&quot;</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="nx">cursor</span><span class="o">++</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Look for expression</span>
<span class="w">        </span><span class="nx">exp</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parseExpression</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">commaSymbol</span><span class="p">))</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected expression&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nx">cursor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newCursor</span>

<span class="w">        </span><span class="nx">exps</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">exps</span><span class="p">,</span><span class="w"> </span><span class="nx">exp</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">exps</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="p">}</span>
</pre></div>
<p>The <code>parseExpression</code> helper (for now) will look for a
numeric, string, or identifier token.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">parseExpression</span><span class="p">(</span><span class="nx">tokens</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">token</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">expression</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">cursor</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">initialCursor</span>

<span class="w">    </span><span class="nx">kinds</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="nx">tokenKind</span><span class="p">{</span><span class="nx">identifierKind</span><span class="p">,</span><span class="w"> </span><span class="nx">numericKind</span><span class="p">,</span><span class="w"> </span><span class="nx">stringKind</span><span class="p">}</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">kind</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">kinds</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">t</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parseToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">kind</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">expression</span><span class="p">{</span>
<span class="w">                </span><span class="nx">literal</span><span class="p">:</span><span class="w"> </span><span class="nx">t</span><span class="p">,</span>
<span class="w">                </span><span class="nx">kind</span><span class="p">:</span><span class="w">    </span><span class="nx">literalKind</span><span class="p">,</span>
<span class="w">            </span><span class="p">},</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="p">}</span>
</pre></div>
<p>And that's it for parsing a <code>SELECT</code> statement!</p>
<h4 id="parsing-insert-statements">Parsing insert statements</h4><p>We'll look for the following token pattern:</p>
<ol>
<li><code>INSERT</code></li>
<li><code>INTO</code></li>
<li><code>$table-name</code></li>
<li><code>VALUES</code></li>
<li><code>(</code></li>
<li><code>$expression [, ...]</code></li>
<li><code>)</code></li>
</ol>
<p>With the existing helpers, this is straightforward to sketch out:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">parseInsertStatement</span><span class="p">(</span><span class="nx">tokens</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="nx">delimiter</span><span class="w"> </span><span class="nx">token</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">InsertStatement</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">cursor</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">initialCursor</span>

<span class="w">    </span><span class="c1">// Look for INSERT</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">expectToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">tokenFromKeyword</span><span class="p">(</span><span class="nx">insertKeyword</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">cursor</span><span class="o">++</span>

<span class="w">    </span><span class="c1">// Look for INTO</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">expectToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">tokenFromKeyword</span><span class="p">(</span><span class="nx">intoKeyword</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected into&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">cursor</span><span class="o">++</span>

<span class="w">    </span><span class="c1">// Look for table name</span>
<span class="w">    </span><span class="nx">table</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parseToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">identifierKind</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected table name&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">cursor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newCursor</span>

<span class="w">    </span><span class="c1">// Look for VALUES</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">expectToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">tokenFromKeyword</span><span class="p">(</span><span class="nx">valuesKeyword</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected VALUES&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">cursor</span><span class="o">++</span>

<span class="w">    </span><span class="c1">// Look for left paren</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">expectToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">leftparenSymbol</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected left paren&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">cursor</span><span class="o">++</span>

<span class="w">    </span><span class="c1">// Look for expression list</span>
<span class="w">    </span><span class="nx">values</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parseExpressions</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="p">[]</span><span class="nx">token</span><span class="p">{</span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">rightparenSymbol</span><span class="p">)})</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">cursor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newCursor</span>

<span class="w">    </span><span class="c1">// Look for right paren</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">expectToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">rightparenSymbol</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected right paren&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">cursor</span><span class="o">++</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">InsertStatement</span><span class="p">{</span>
<span class="w">        </span><span class="nx">table</span><span class="p">:</span><span class="w">  </span><span class="o">*</span><span class="nx">table</span><span class="p">,</span>
<span class="w">        </span><span class="nx">values</span><span class="p">:</span><span class="w"> </span><span class="nx">values</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="p">}</span>
</pre></div>
<p>And that's it for parsing an <code>INSERT</code> statement!</p>
<h4 id="parsing-create-statements">Parsing create statements</h4><p>Finally, for create statements we'll look for the following token
pattern:</p>
<ol>
<li><code>CREATE</code></li>
<li><code>$table-name</code></li>
<li><code>(</code></li>
<li><code>[$column-name $column-type [, ...]]</code></li>
<li><code>)</code></li>
</ol>
<p>Sketching that out with a new <code>parseColumnDefinitions</code>
helper we get:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">parseCreateTableStatement</span><span class="p">(</span><span class="nx">tokens</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="nx">delimiter</span><span class="w"> </span><span class="nx">token</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">CreateTableStatement</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">cursor</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">initialCursor</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">expectToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">tokenFromKeyword</span><span class="p">(</span><span class="nx">createKeyword</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">cursor</span><span class="o">++</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">expectToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">tokenFromKeyword</span><span class="p">(</span><span class="nx">tableKeyword</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">cursor</span><span class="o">++</span>

<span class="w">    </span><span class="nx">name</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parseToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">identifierKind</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected table name&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">cursor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newCursor</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">expectToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">leftparenSymbol</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected left parenthesis&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">cursor</span><span class="o">++</span>

<span class="w">    </span><span class="nx">cols</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parseColumnDefinitions</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">rightparenSymbol</span><span class="p">))</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">cursor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newCursor</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">expectToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">rightparenSymbol</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected right parenthesis&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">cursor</span><span class="o">++</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">CreateTableStatement</span><span class="p">{</span>
<span class="w">        </span><span class="nx">name</span><span class="p">:</span><span class="w"> </span><span class="o">*</span><span class="nx">name</span><span class="p">,</span>
<span class="w">        </span><span class="nx">cols</span><span class="p">:</span><span class="w"> </span><span class="nx">cols</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="p">}</span>
</pre></div>
<p>The <code>parseColumnDefinitions</code> helper will look column names
followed by column types separated by a comma and ending with some
delimiter:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">parseColumnDefinitions</span><span class="p">(</span><span class="nx">tokens</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="nx">delimiter</span><span class="w"> </span><span class="nx">token</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">columnDefinition</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">cursor</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">initialCursor</span>

<span class="w">    </span><span class="nx">cds</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">columnDefinition</span><span class="p">{}</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">cursor</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">tokens</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Look for a delimiter</span>
<span class="w">        </span><span class="nx">current</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">tokens</span><span class="p">[</span><span class="nx">cursor</span><span class="p">]</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">delimiter</span><span class="p">.</span><span class="nx">equals</span><span class="p">(</span><span class="nx">current</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">break</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Look for a comma</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">cds</span><span class="p">)</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">expectToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">tokenFromSymbol</span><span class="p">(</span><span class="nx">commaSymbol</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected comma&quot;</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="nx">cursor</span><span class="o">++</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Look for a column name</span>
<span class="w">        </span><span class="nx">id</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parseToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">identifierKind</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected column name&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nx">cursor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newCursor</span>

<span class="w">        </span><span class="c1">// Look for a column type</span>
<span class="w">        </span><span class="nx">ty</span><span class="p">,</span><span class="w"> </span><span class="nx">newCursor</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parseToken</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="nx">keywordKind</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">helpMessage</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected column type&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">initialCursor</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nx">cursor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newCursor</span>

<span class="w">        </span><span class="nx">cds</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">cds</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">columnDefinition</span><span class="p">{</span>
<span class="w">            </span><span class="nx">name</span><span class="p">:</span><span class="w">     </span><span class="o">*</span><span class="nx">id</span><span class="p">,</span>
<span class="w">            </span><span class="nx">datatype</span><span class="p">:</span><span class="w"> </span><span class="o">*</span><span class="nx">ty</span><span class="p">,</span>
<span class="w">        </span><span class="p">})</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">cds</span><span class="p">,</span><span class="w"> </span><span class="nx">cursor</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="p">}</span>
</pre></div>
<p>And that's it for parsing! If you copy
<a href="https://github.com/eatonphil/gosql/blob/master/parser_test.go">parser_test.go</a>
from the main project, the tests should now pass.</p>
<h3 id="an-in-memory-backend">An in-memory backend</h3><p>Our in-memory backend should conform to a general backend interface
that allows a user to create, select, and insert data:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="s">&quot;errors&quot;</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">ColumnType</span><span class="w"> </span><span class="kt">uint</span>

<span class="kd">const</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="nx">TextType</span><span class="w"> </span><span class="nx">ColumnType</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">iota</span>
<span class="w">    </span><span class="nx">IntType</span>
<span class="p">)</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">Cell</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">AsText</span><span class="p">()</span><span class="w"> </span><span class="kt">string</span>
<span class="w">    </span><span class="nx">AsInt</span><span class="p">()</span><span class="w"> </span><span class="kt">int32</span>
<span class="p">}</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">Results</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">Columns</span><span class="w"> </span><span class="p">[]</span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">Type</span><span class="w"> </span><span class="nx">ColumnType</span>
<span class="w">        </span><span class="nx">Name</span><span class="w"> </span><span class="kt">string</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">Rows</span><span class="w"> </span><span class="p">[][]</span><span class="nx">Cell</span>
<span class="p">}</span>

<span class="kd">var</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="nx">ErrTableDoesNotExist</span><span class="w">  </span><span class="p">=</span><span class="w"> </span><span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;Table does not exist&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="nx">ErrColumnDoesNotExist</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;Column does not exist&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="nx">ErrInvalidSelectItem</span><span class="w">  </span><span class="p">=</span><span class="w"> </span><span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;Select item is not valid&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="nx">ErrInvalidDatatype</span><span class="w">    </span><span class="p">=</span><span class="w"> </span><span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;Invalid datatype&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="nx">ErrMissingValues</span><span class="w">      </span><span class="p">=</span><span class="w"> </span><span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;Missing values&quot;</span><span class="p">)</span>
<span class="p">)</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">Backend</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">CreateTable</span><span class="p">(</span><span class="o">*</span><span class="nx">CreateTableStatement</span><span class="p">)</span><span class="w"> </span><span class="kt">error</span>
<span class="w">    </span><span class="nx">Insert</span><span class="p">(</span><span class="o">*</span><span class="nx">InsertStatement</span><span class="p">)</span><span class="w"> </span><span class="kt">error</span>
<span class="w">    </span><span class="nx">Select</span><span class="p">(</span><span class="o">*</span><span class="nx">SelectStatement</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">Results</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>This leaves us room in the future for a disk-backed backend.</p>
<h4 id="memory-layout">Memory layout</h4><p>Our in-memory backend should store a list of tables. Each table
will have a list of columns and rows. Each column will have a name and
type. Each row will have a list of byte arrays.</p>
<div class="highlight"><pre><span></span><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;bytes&quot;</span>
<span class="w">    </span><span class="s">&quot;encoding/binary&quot;</span>
<span class="w">    </span><span class="s">&quot;fmt&quot;</span>
<span class="w">    </span><span class="s">&quot;strconv&quot;</span>
<span class="p">)</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">MemoryCell</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">mc</span><span class="w"> </span><span class="nx">MemoryCell</span><span class="p">)</span><span class="w"> </span><span class="nx">AsInt</span><span class="p">()</span><span class="w"> </span><span class="kt">int32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kt">int32</span>
<span class="w">    </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">binary</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">NewBuffer</span><span class="p">(</span><span class="nx">mc</span><span class="p">),</span><span class="w"> </span><span class="nx">binary</span><span class="p">.</span><span class="nx">BigEndian</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">i</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">i</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">mc</span><span class="w"> </span><span class="nx">MemoryCell</span><span class="p">)</span><span class="w"> </span><span class="nx">AsText</span><span class="p">()</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">string</span><span class="p">(</span><span class="nx">mc</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">table</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">columns</span><span class="w">     </span><span class="p">[]</span><span class="kt">string</span>
<span class="w">    </span><span class="nx">columnTypes</span><span class="w"> </span><span class="p">[]</span><span class="nx">ColumnType</span>
<span class="w">    </span><span class="nx">rows</span><span class="w">        </span><span class="p">[][]</span><span class="nx">MemoryCell</span>
<span class="p">}</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">MemoryBackend</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">tables</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">table</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">NewMemoryBackend</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="nx">MemoryBackend</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">MemoryBackend</span><span class="p">{</span>
<span class="w">        </span><span class="nx">tables</span><span class="p">:</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">table</span><span class="p">{},</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h4 id="implementing-create-table-support">Implementing create table support</h4><p>When creating a table, we'll make a new entry in the backend tables
map. Then we'll create columns as specified by the AST.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">mb</span><span class="w"> </span><span class="o">*</span><span class="nx">MemoryBackend</span><span class="p">)</span><span class="w"> </span><span class="nx">CreateTable</span><span class="p">(</span><span class="nx">crt</span><span class="w"> </span><span class="o">*</span><span class="nx">CreateTableStatement</span><span class="p">)</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">table</span><span class="p">{}</span>
<span class="w">    </span><span class="nx">mb</span><span class="p">.</span><span class="nx">tables</span><span class="p">[</span><span class="nx">crt</span><span class="p">.</span><span class="nx">name</span><span class="p">.</span><span class="nx">value</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">t</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">crt</span><span class="p">.</span><span class="nx">cols</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="o">*</span><span class="nx">crt</span><span class="p">.</span><span class="nx">cols</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">t</span><span class="p">.</span><span class="nx">columns</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">columns</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="p">.</span><span class="nx">name</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>

<span class="w">        </span><span class="kd">var</span><span class="w"> </span><span class="nx">dt</span><span class="w"> </span><span class="nx">ColumnType</span>
<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="nx">col</span><span class="p">.</span><span class="nx">datatype</span><span class="p">.</span><span class="nx">value</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="s">&quot;int&quot;</span><span class="p">:</span>
<span class="w">            </span><span class="nx">dt</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">IntType</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="s">&quot;text&quot;</span><span class="p">:</span>
<span class="w">            </span><span class="nx">dt</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">TextType</span>
<span class="w">        </span><span class="k">default</span><span class="p">:</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">ErrInvalidDatatype</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nx">t</span><span class="p">.</span><span class="nx">columnTypes</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">columnTypes</span><span class="p">,</span><span class="w"> </span><span class="nx">dt</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
<h4 id="implementing-insert-support">Implementing insert support</h4><p>Keeping things simple, we'll assume the value passed can be correctly
mapped to the type of the column specified.</p>
<p>We'll reference a helper for mapper values to internal storage,
<code>tokenToCell</code>.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">mb</span><span class="w"> </span><span class="o">*</span><span class="nx">MemoryBackend</span><span class="p">)</span><span class="w"> </span><span class="nx">Insert</span><span class="p">(</span><span class="nx">inst</span><span class="w"> </span><span class="o">*</span><span class="nx">InsertStatement</span><span class="p">)</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">table</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">mb</span><span class="p">.</span><span class="nx">tables</span><span class="p">[</span><span class="nx">inst</span><span class="p">.</span><span class="nx">table</span><span class="p">.</span><span class="nx">value</span><span class="p">]</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">ErrTableDoesNotExist</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">inst</span><span class="p">.</span><span class="nx">values</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">row</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="nx">MemoryCell</span><span class="p">{}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">inst</span><span class="p">.</span><span class="nx">values</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">table</span><span class="p">.</span><span class="nx">columns</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">ErrMissingValues</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="o">*</span><span class="nx">inst</span><span class="p">.</span><span class="nx">values</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">value</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">literalKind</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Skipping non-literal.&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="k">continue</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nx">row</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="nx">mb</span><span class="p">.</span><span class="nx">tokenToCell</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">literal</span><span class="p">))</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">table</span><span class="p">.</span><span class="nx">rows</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">table</span><span class="p">.</span><span class="nx">rows</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
<p>The <code>tokenToCell</code> helper will write numbers as binary bytes
and will write strings as bytes:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">mb</span><span class="w"> </span><span class="o">*</span><span class="nx">MemoryBackend</span><span class="p">)</span><span class="w"> </span><span class="nx">tokenToCell</span><span class="p">(</span><span class="nx">t</span><span class="w"> </span><span class="o">*</span><span class="nx">token</span><span class="p">)</span><span class="w"> </span><span class="nx">MemoryCell</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">numericKind</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">buf</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
<span class="w">        </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">strconv</span><span class="p">.</span><span class="nx">Atoi</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nx">err</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">binary</span><span class="p">.</span><span class="nx">Write</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span><span class="w"> </span><span class="nx">binary</span><span class="p">.</span><span class="nx">BigEndian</span><span class="p">,</span><span class="w"> </span><span class="nb">int32</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">MemoryCell</span><span class="p">(</span><span class="nx">buf</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">())</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">stringKind</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">MemoryCell</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
<h4 id="implementing-select-support">Implementing select support</h4><p>Finally, for select we'll iterate over each row in the table and
return the cells according to the columns specified by the AST.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">mb</span><span class="w"> </span><span class="o">*</span><span class="nx">MemoryBackend</span><span class="p">)</span><span class="w"> </span><span class="nx">Select</span><span class="p">(</span><span class="nx">slct</span><span class="w"> </span><span class="o">*</span><span class="nx">SelectStatement</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">Results</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">table</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">mb</span><span class="p">.</span><span class="nx">tables</span><span class="p">[</span><span class="nx">slct</span><span class="p">.</span><span class="nx">from</span><span class="p">.</span><span class="nx">table</span><span class="p">]</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">ErrTableDoesNotExist</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">results</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[][]</span><span class="nx">Cell</span><span class="p">{}</span>
<span class="w">    </span><span class="nx">columns</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">Type</span><span class="w"> </span><span class="nx">ColumnType</span>
<span class="w">        </span><span class="nx">Name</span><span class="w"> </span><span class="kt">string</span>
<span class="w">    </span><span class="p">}{}</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">table</span><span class="p">.</span><span class="nx">rows</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="nx">Cell</span><span class="p">{}</span>
<span class="w">        </span><span class="nx">isFirstRow</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">exp</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">slct</span><span class="p">.</span><span class="nx">item</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">exp</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">literalKind</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// Unsupported, doesn&#39;t currently exist, ignore.</span>
<span class="w">                </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Skipping non-literal expression.&quot;</span><span class="p">)</span>
<span class="w">                </span><span class="k">continue</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="nx">lit</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">exp</span><span class="p">.</span><span class="nx">literal</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">lit</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">identifierKind</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">found</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kc">false</span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">tableCol</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">table</span><span class="p">.</span><span class="nx">columns</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="nx">tableCol</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">lit</span><span class="p">.</span><span class="nx">value</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="nx">isFirstRow</span><span class="w"> </span><span class="p">{</span>
<span class="w">                            </span><span class="nx">columns</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">columns</span><span class="p">,</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">                                </span><span class="nx">Type</span><span class="w"> </span><span class="nx">ColumnType</span>
<span class="w">                                </span><span class="nx">Name</span><span class="w"> </span><span class="kt">string</span>
<span class="w">                            </span><span class="p">}{</span>
<span class="w">                                </span><span class="nx">Type</span><span class="p">:</span><span class="w"> </span><span class="nx">table</span><span class="p">.</span><span class="nx">columnTypes</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span>
<span class="w">                                </span><span class="nx">Name</span><span class="p">:</span><span class="w"> </span><span class="nx">lit</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span>
<span class="w">                            </span><span class="p">})</span>
<span class="w">                        </span><span class="p">}</span>

<span class="w">                        </span><span class="nx">result</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
<span class="w">                        </span><span class="nx">found</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">true</span>
<span class="w">                        </span><span class="k">break</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">found</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">ErrColumnDoesNotExist</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="k">continue</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">ErrColumnDoesNotExist</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nx">results</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">results</span><span class="p">,</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Results</span><span class="p">{</span>
<span class="w">        </span><span class="nx">Columns</span><span class="p">:</span><span class="w"> </span><span class="nx">columns</span><span class="p">,</span>
<span class="w">        </span><span class="nx">Rows</span><span class="p">:</span><span class="w">    </span><span class="nx">results</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span><span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
<h3 id="the-repl">The REPL</h3><p>At last, we're ready to wrap the parser and in-memory backend in a
REPL. The most complex part is displaying the table of results from a
select query.</p>
<div class="highlight"><pre><span></span><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;bufio&quot;</span>
<span class="w">    </span><span class="s">&quot;fmt&quot;</span>
<span class="w">    </span><span class="s">&quot;os&quot;</span>
<span class="w">    </span><span class="s">&quot;strings&quot;</span>

<span class="w">    </span><span class="s">&quot;github.com/eatonphil/gosql&quot;</span>
<span class="p">)</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">mb</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">gosql</span><span class="p">.</span><span class="nx">NewMemoryBackend</span><span class="p">()</span>

<span class="w">    </span><span class="nx">reader</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">bufio</span><span class="p">.</span><span class="nx">NewReader</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Welcome to gosql.&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="s">&quot;# &quot;</span><span class="p">)</span>
<span class="w">        </span><span class="nx">text</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">reader</span><span class="p">.</span><span class="nx">ReadString</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">)</span>
<span class="w">        </span><span class="nx">text</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">strings</span><span class="p">.</span><span class="nx">Replace</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="w">        </span><span class="nx">ast</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">gosql</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">stmt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">ast</span><span class="p">.</span><span class="nx">Statements</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">switch</span><span class="w"> </span><span class="nx">stmt</span><span class="p">.</span><span class="nx">Kind</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">case</span><span class="w"> </span><span class="nx">gosql</span><span class="p">.</span><span class="nx">CreateTableKind</span><span class="p">:</span>
<span class="w">                </span><span class="nx">err</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">mb</span><span class="p">.</span><span class="nx">CreateTable</span><span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="nx">Statements</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">CreateTableStatement</span><span class="p">)</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;ok&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="k">case</span><span class="w"> </span><span class="nx">gosql</span><span class="p">.</span><span class="nx">InsertKind</span><span class="p">:</span>
<span class="w">                </span><span class="nx">err</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">mb</span><span class="p">.</span><span class="nx">Insert</span><span class="p">(</span><span class="nx">stmt</span><span class="p">.</span><span class="nx">InsertStatement</span><span class="p">)</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;ok&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="k">case</span><span class="w"> </span><span class="nx">gosql</span><span class="p">.</span><span class="nx">SelectKind</span><span class="p">:</span>
<span class="w">                </span><span class="nx">results</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">mb</span><span class="p">.</span><span class="nx">Select</span><span class="p">(</span><span class="nx">stmt</span><span class="p">.</span><span class="nx">SelectStatement</span><span class="p">)</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">results</span><span class="p">.</span><span class="nx">Columns</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;| %s &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;|&quot;</span><span class="p">)</span>

<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;=&quot;</span><span class="p">)</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">()</span>

<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">results</span><span class="p">.</span><span class="nx">Rows</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;|&quot;</span><span class="p">)</span>

<span class="w">                    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">cell</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="nx">typ</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">results</span><span class="p">.</span><span class="nx">Columns</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Type</span>
<span class="w">                        </span><span class="nx">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s">&quot;&quot;</span>
<span class="w">                        </span><span class="k">switch</span><span class="w"> </span><span class="nx">typ</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="k">case</span><span class="w"> </span><span class="nx">gosql</span><span class="p">.</span><span class="nx">IntType</span><span class="p">:</span>
<span class="w">                            </span><span class="nx">s</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">cell</span><span class="p">.</span><span class="nx">AsInt</span><span class="p">())</span>
<span class="w">                        </span><span class="k">case</span><span class="w"> </span><span class="nx">gosql</span><span class="p">.</span><span class="nx">TextType</span><span class="p">:</span>
<span class="w">                            </span><span class="nx">s</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">cell</span><span class="p">.</span><span class="nx">AsText</span><span class="p">()</span>
<span class="w">                        </span><span class="p">}</span>

<span class="w">                        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot; %s | &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">s</span><span class="p">)</span>
<span class="w">                    </span><span class="p">}</span>

<span class="w">                    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">()</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;ok&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Putting it all together:</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>go<span class="w"> </span>run<span class="w"> </span>*.go
Welcome<span class="w"> </span>to<span class="w"> </span>gosql.
<span class="c1"># CREATE TABLE users (id INT, name TEXT);</span>
ok
<span class="c1"># INSERT INTO users VALUES (1, &#39;Phil&#39;);</span>
ok
<span class="c1"># SELECT id, name FROM users;</span>
<span class="p">|</span><span class="w"> </span>id<span class="w"> </span><span class="p">|</span><span class="w"> </span>name<span class="w"> </span><span class="p">|</span>
<span class="o">====================</span>
<span class="p">|</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">|</span><span class="w">  </span>Phil<span class="w"> </span><span class="p">|</span>
ok
<span class="c1"># INSERT INTO users VALUES (2, &#39;Kate&#39;);</span>
ok
<span class="c1"># SELECT name, id FROM users;</span>
<span class="p">|</span><span class="w"> </span>name<span class="w"> </span><span class="p">|</span><span class="w"> </span>id<span class="w"> </span><span class="p">|</span>
<span class="o">====================</span>
<span class="p">|</span><span class="w"> </span>Phil<span class="w"> </span><span class="p">|</span><span class="w">  </span><span class="m">1</span><span class="w"> </span><span class="p">|</span>
<span class="p">|</span><span class="w"> </span>Kate<span class="w"> </span><span class="p">|</span><span class="w">  </span><span class="m">2</span><span class="w"> </span><span class="p">|</span>
ok
</pre></div>
<p>And we've got a very simple SQL database!</p>
<p>Next up we'll get into filtering, sorting, and indexing.</p>
<h4 id="further-reading">Further reading</h4><ul>
<li><a href="/writing-a-simple-json-parser.html">Writing a simple JSON parser</a><ul>
<li>This post goes into a little more detail about the theory and basics of parsing.</li>
</ul>
</li>
<li><a href="https://www.goodreads.com/book/show/617120.Database_Systems">Database Systems: A Practical Approach to Design, Implementation and Management</a><ul>
<li>A giant book, but an excellent and very easy introduction to database theory.</li>
</ul>
</li>
</ul>
<p><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr">Latest blog post: writing a simple SQL database from scratch in Go <a href="https://t.co/csQmNhWIEf">https://t.co/csQmNhWIEf</a></p>&mdash; Phil Eaton (@phil_eaton) <a href="https://twitter.com/phil_eaton/status/1237522975143776256?ref_src=twsrc%5Etfw">March 10, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>
<style>.feedback{display:initial;}</style>
	</div>
	<div class="feedback">
	  <h4>Feedback</h4>
	  <p>As always,
	      please <a href="mailto:phil@eatonphil.com">email</a>
	      or <a href="https://twitter.com/eatonphil">tweet me</a>
	      with questions, corrections, or ideas!</p>

	</div>
      </div>
    </div>
    <footer>
      <div class="container">
	<div>
	  <div id="subscribe">
	    <iframe src="https://cdn.forms-content-1.sg-form.com/e8ed4c3b-dd46-11f0-b6e6-ce075f2c5f80"/>

	  </div>
	</div>
      </div>
    </footer>
    <script async onload="loadGA()" src="https://www.googletagmanager.com/gtag/js?id=UA-58109156-2"></script>
    <script>
      function loadGA() {
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());
	  gtag('config', 'UA-58109156-2');
      }
    </script>
    <script defer src="https://cdn.usefathom.com/script.js" data-site="CEPUOLOQ"></script>
  </body>
</html>
