<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="canonical" href="https://notes.eatonphil.com/lua-in-rust.html">
    <title>Writing a minimal Lua implementation with a virtual machine from scratch in Rust | notes.eatonphil.com</title>
    <meta name="description" content="Writing a minimal Lua implementation with a virtual machine from scratch in Rust" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono">
  </head>
  <body>
    <header>
      <!-- <div class="lfw"> -->
      <!-- 	<div class="container"> -->
      <!-- 	  <div class="row"> -->
      <!-- 	    <a href="https://eatonphil.com/hire-me.html">Hire me!</a> -->
      <!-- 	  </div> -->
      <!-- 	</div> -->
      <!-- </div> -->
      <div class="container">
        <div>
          <div class="row">
	    <div>
	      <a href="https://eatonphil.com" class="sm-link">
		Home
              </a>
	      <a href="/" class="sm-link">
		Notes
              </a>
	      <a href="/favorites.html" class="sm-link hide-mobile">
		Popular
              </a>
	      <a href="/rss.xml" class="sm-link">
		RSS
              </a>
	    </div>

	    <div class="subscribe">
	      <!-- <a href="https://eatonphil.com/hire-me.html">Hire me</a> -->
	      <!--
		  Hardcode link to home page because some pages don't
		  have a subscribe box. Some pages hide the subscribe.
		-->
	      <a class="fancy" href="https://eatonphil.com/subscribe.html">
		Subscribe
	      </a>
            </div>
	  </div>
	  <hr />
	  <div class="">
            <h2>December 28, 2021</h2>
            <h1>Writing a minimal Lua implementation with a virtual machine from scratch in Rust</h1>
	    
            <div class="row" style="padding-bottom: 5px">
              <div class="tags"><a href="/tags/lua.html" class="tag">lua</a><a href="/tags/compilers.html" class="tag">compilers</a><a href="/tags/interpreters.html" class="tag">interpreters</a><a href="/tags/virtual-machines.html" class="tag">virtual machines</a><a href="/tags/rust.html" class="tag">rust</a><a href="/tags/parsing.html" class="tag">parsing</a></div>
            </div>
	  </div>
	</div>
      </div>
    </header>
    <div class="container">
      <div class="col-6">
	<div class="post">
          <p>By the end of this guide we'll have a minimal, working implementation
of a small part of Lua from scratch. It will be able to run the
following program (among others):</p>
<div class="highlight"><pre><span></span><span class="kr">function</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
   <span class="kr">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="kr">then</span>
      <span class="kr">return</span> <span class="n">n</span><span class="p">;</span>
   <span class="kr">end</span>

   <span class="kd">local</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
   <span class="kd">local</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
   <span class="kr">return</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span><span class="p">;</span>
<span class="kr">end</span>

<span class="nb">print</span><span class="p">(</span><span class="n">fib</span><span class="p">(</span><span class="mi">30</span><span class="p">));</span>
</pre></div>
<p>This is my second project in Rust and only the third time I've
invented an instruction set so don't take my style as gospel. However,
I have found some Rust parsing tutorials overly complex so I'm hoping
you'll find this one simpler.</p>
<p>All <a href="https://github.com/eatonphil/lust">source code is available on Github</a>.</p>
<h3 id="entrypoint">Entrypoint</h3><p>Running <code>cargo init</code> will give the boilerplate necessary. In
<code>src/main.rs</code> we'll accept a file name from the command line, perform
lexical analysis to retrieve all tokens from the file, perform grammar
analysis on the tokens to retrieve a tree structure, compile the tree
to a linear set of virtual machine instructions, and finally interpret
the virtual machine instructions.</p>
<div class="highlight"><pre><span></span><span class="k">mod</span> <span class="nn">eval</span><span class="p">;</span>
<span class="k">mod</span> <span class="nn">lex</span><span class="p">;</span>
<span class="k">mod</span> <span class="nn">parse</span><span class="p">;</span>

<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">env</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span>::<span class="n">args</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span>::<span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]).</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;Could not read file&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">raw</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tokens</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">lex</span>::<span class="n">lex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">raw</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">tokens</span><span class="p">,</span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">),</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">parse</span>::<span class="n">parse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">tokens</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">ast</span><span class="p">,</span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">),</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">pgrm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eval</span>::<span class="n">compile</span><span class="p">(</span><span class="o">&amp;</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">ast</span><span class="p">);</span>

<span class="w">    </span><span class="n">eval</span>::<span class="n">eval</span><span class="p">(</span><span class="n">pgrm</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>Easy peasy. Now let's implement <code>lex</code>.</p>
<h3 id="lexical-analysis">Lexical analysis</h3><p>Lexical analysis drops whitespace (Lua is not whitespace
sensitive) and chunks all source code characters into their
smallest possible meaningful pieces like commas, numbers, identifiers,
keywords, etc.</p>
<p>In order to have useful error messages, we'll keep track of state in
the file with a <code>Location</code> struct that implements <code>increment</code> and
<code>debug</code>.</p>
<p>This goes in <code>src/lex.rs</code>.</p>
<div class="highlight"><pre><span></span><span class="cp">#[derive(Copy, Clone, Debug)]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Location</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">col</span>: <span class="kt">i32</span><span class="p">,</span>
<span class="w">    </span><span class="n">line</span>: <span class="kt">i32</span><span class="p">,</span>
<span class="w">    </span><span class="n">index</span>: <span class="kt">usize</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
<p>The <code>increment</code> function will update line and column numbers as well
as the current index in the file.</p>
<div class="highlight"><pre><span></span><span class="kd">impl</span><span class="w"> </span><span class="nx">Location</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">fn</span><span class="w"> </span><span class="nx">increment</span><span class="p">(</span><span class="o">&amp;</span><span class="kp">self</span><span class="p">,</span><span class="w"> </span><span class="nx">newline</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nx">Location</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">newline</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">Location</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">index</span><span class="p">:</span><span class="w"> </span><span class="kp">self</span><span class="p">.</span><span class="nx">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">                </span><span class="nx">col</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                </span><span class="nx">line</span><span class="p">:</span><span class="w"> </span><span class="kp">self</span><span class="p">.</span><span class="nx">line</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">Location</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">index</span><span class="p">:</span><span class="w"> </span><span class="kp">self</span><span class="p">.</span><span class="nx">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">                </span><span class="nx">col</span><span class="p">:</span><span class="w"> </span><span class="kp">self</span><span class="p">.</span><span class="nx">col</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">                </span><span class="nx">line</span><span class="p">:</span><span class="w"> </span><span class="kp">self</span><span class="p">.</span><span class="nx">line</span><span class="p">,</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
<p>And the <code>debug</code> function will dump the current line with a pointer in
text to the current column along with a message.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="n">pub</span><span class="w"> </span><span class="n">fn</span><span class="w"> </span><span class="n">debug</span><span class="o">&lt;</span><span class="nl">S</span><span class="p">:</span><span class="w"> </span><span class="k">Into</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="nl">raw</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;[</span><span class="n">char</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="nl">msg</span><span class="p">:</span><span class="w"> </span><span class="n">S</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="n">let</span><span class="w"> </span><span class="n">mut</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">let</span><span class="w"> </span><span class="n">mut</span><span class="w"> </span><span class="n">line_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nl">String</span><span class="p">:</span><span class="err">:</span><span class="k">new</span><span class="p">();</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">Find</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">whole</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">original</span><span class="w"> </span><span class="n">source</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">raw</span><span class="w"> </span><span class="err">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s1">&#39;\n&#39;</span><span class="w"> </span><span class="err">{</span>
<span class="w">                </span><span class="n">line</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">                </span><span class="o">//</span><span class="w"> </span><span class="n">Done</span><span class="w"> </span><span class="n">discovering</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">question</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="err">!</span><span class="n">line_str</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="err">{</span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span>
<span class="w">                </span><span class="err">}</span>

<span class="w">                </span><span class="k">continue</span><span class="p">;</span>
<span class="w">            </span><span class="err">}</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">line</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="err">{</span>
<span class="w">                </span><span class="n">line_str</span><span class="p">.</span><span class="n">push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">.</span><span class="n">to_string</span><span class="p">());</span>
<span class="w">            </span><span class="err">}</span>
<span class="w">        </span><span class="err">}</span>

<span class="w">        </span><span class="n">let</span><span class="w"> </span><span class="nf">space</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; &quot;</span><span class="p">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">usize</span><span class="p">);</span>
<span class="w">        </span><span class="nf">format</span><span class="err">!</span><span class="p">(</span><span class="ss">&quot;{}\n\n{}\n{}^ Near here&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">.</span><span class="k">into</span><span class="p">(),</span><span class="w"> </span><span class="n">line_str</span><span class="p">,</span><span class="w"> </span><span class="nf">space</span><span class="p">)</span>
<span class="w">    </span><span class="err">}</span>
<span class="err">}</span>
</pre></div>
<p>The smallest individual unit after lexical analysis is a token which
is either a keyword, number, identifier, operator, or syntax. (This
implementation is clearly skipping lots of real Lua syntax like
strings.)</p>
<div class="highlight"><pre><span></span><span class="cp">#[derive(Debug, PartialEq, Eq, Clone)]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">TokenKind</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Identifier</span><span class="p">,</span>
<span class="w">    </span><span class="n">Syntax</span><span class="p">,</span>
<span class="w">    </span><span class="n">Keyword</span><span class="p">,</span>
<span class="w">    </span><span class="n">Number</span><span class="p">,</span>
<span class="w">    </span><span class="n">Operator</span><span class="p">,</span>
<span class="p">}</span>

<span class="cp">#[derive(Debug, Clone)]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Token</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">value</span>: <span class="nb">String</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">kind</span>: <span class="nc">TokenKind</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">loc</span>: <span class="nc">Location</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
<p>The top-level <code>lex</code> function will iterate over the file and call a lex
helper for each kind of token, returning an array of all tokens on
success. In between lexing it will "eat whitespace".</p>
<div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">lex</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">char</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Location</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">col</span>: <span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="n">index</span>: <span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="n">line</span>: <span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">tokens</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[];</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">lexers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="n">lex_keyword</span><span class="p">,</span>
<span class="w">        </span><span class="n">lex_identifier</span><span class="p">,</span>
<span class="w">        </span><span class="n">lex_number</span><span class="p">,</span>
<span class="w">        </span><span class="n">lex_syntax</span><span class="p">,</span>
<span class="w">        </span><span class="n">lex_operator</span><span class="p">,</span>
<span class="w">    </span><span class="p">];</span>
<span class="w">    </span><span class="o">&#39;</span><span class="na">outer</span>: <span class="nc">while</span><span class="w"> </span><span class="n">loc</span><span class="p">.</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eat_whitespace</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">loc</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">loc</span><span class="p">.</span><span class="n">index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">lexer</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">lexers</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lexer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">loc</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">((</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">next_loc</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next_loc</span><span class="p">;</span>
<span class="w">                </span><span class="n">tokens</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="w">                </span><span class="k">continue</span><span class="w"> </span><span class="nl">&#39;outer</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">loc</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Unrecognized character while lexing:&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<h4 id="whitespace">Whitespace</h4><p>Eating whitespace is just incrementing the location while we see a
space, tab, newline, etc.</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">eat_whitespace</span><span class="p">(</span><span class="n">raw</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">char</span><span class="p">],</span><span class="w"> </span><span class="n">initial_loc</span>: <span class="nc">Location</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Location</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">raw</span><span class="p">[</span><span class="n">initial_loc</span><span class="p">.</span><span class="n">index</span><span class="p">];</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">next_loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initial_loc</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">[</span><span class="sc">&#39; &#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;\r&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;\t&#39;</span><span class="p">].</span><span class="n">contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">next_loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next_loc</span><span class="p">.</span><span class="n">increment</span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">next_loc</span><span class="p">.</span><span class="n">index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">raw</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">raw</span><span class="p">[</span><span class="n">next_loc</span><span class="p">.</span><span class="n">index</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">next_loc</span>
<span class="p">}</span>
</pre></div>
<h4 id="numbers">Numbers</h4><p>Lexing numbers iterates through the source starting at a position
until it stops seeing decimal digits (this implementation only
supports integers).</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">lex_number</span><span class="p">(</span><span class="n">raw</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">char</span><span class="p">],</span><span class="w"> </span><span class="n">initial_loc</span>: <span class="nc">Location</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Token</span><span class="p">,</span><span class="w"> </span><span class="n">Location</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ident</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">next_loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initial_loc</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">raw</span><span class="p">[</span><span class="n">initial_loc</span><span class="p">.</span><span class="n">index</span><span class="p">];</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">is_digit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ident</span><span class="p">.</span><span class="n">push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">.</span><span class="n">to_string</span><span class="p">());</span>
<span class="w">        </span><span class="n">next_loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next_loc</span><span class="p">.</span><span class="n">increment</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
<span class="w">        </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">raw</span><span class="p">[</span><span class="n">next_loc</span><span class="p">.</span><span class="n">index</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
<p>If there are no digits in the string then this is not a number.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">ident</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nb">Some</span><span class="p">((</span>
<span class="w">            </span><span class="n">Token</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">value</span>: <span class="nc">ident</span><span class="p">,</span>
<span class="w">                </span><span class="n">loc</span>: <span class="nc">initial_loc</span><span class="p">,</span>
<span class="w">                </span><span class="n">kind</span>: <span class="nc">TokenKind</span>::<span class="n">Number</span><span class="p">,</span>
<span class="w">            </span><span class="p">},</span>
<span class="w">            </span><span class="n">next_loc</span><span class="p">,</span>
<span class="w">        </span><span class="p">))</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nb">None</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h4 id="identifiers">Identifiers</h4><p>Identifiers are any collection of alphabet characters, numbers, and
underscores.</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">lex_identifier</span><span class="p">(</span><span class="n">raw</span>: <span class="kp">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">initial_loc</span>: <span class="nc">Location</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Token</span><span class="p">,</span><span class="w"> </span><span class="n">Location</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ident</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">next_loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initial_loc</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">raw</span><span class="p">[</span><span class="n">initial_loc</span><span class="p">.</span><span class="n">index</span><span class="p">];</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">is_alphanumeric</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;_&#39;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ident</span><span class="p">.</span><span class="n">push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">.</span><span class="n">to_string</span><span class="p">());</span>
<span class="w">        </span><span class="n">next_loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next_loc</span><span class="p">.</span><span class="n">increment</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
<span class="w">        </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">raw</span><span class="p">[</span><span class="n">next_loc</span><span class="p">.</span><span class="n">index</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
<p>But they cannot start with a number.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">// First character must not be a digit</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">ident</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">ident</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">is_digit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nb">Some</span><span class="p">((</span>
<span class="w">            </span><span class="n">Token</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">value</span>: <span class="nc">ident</span><span class="p">,</span>
<span class="w">                </span><span class="n">loc</span>: <span class="nc">initial_loc</span><span class="p">,</span>
<span class="w">                </span><span class="n">kind</span>: <span class="nc">TokenKind</span>::<span class="n">Identifier</span><span class="p">,</span>
<span class="w">            </span><span class="p">},</span>
<span class="w">            </span><span class="n">next_loc</span><span class="p">,</span>
<span class="w">        </span><span class="p">))</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nb">None</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h4 id="keywords">Keywords</h4><p>Keywords are alphabetical like identifiers are but they cannot be
reused as variables by the user.</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">lex_keyword</span><span class="p">(</span><span class="n">raw</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">char</span><span class="p">],</span><span class="w"> </span><span class="n">initial_loc</span>: <span class="nc">Location</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Token</span><span class="p">,</span><span class="w"> </span><span class="n">Location</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">syntax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;function&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;end&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;if&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;then&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;local&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;return&quot;</span><span class="p">];</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">next_loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initial_loc</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span>
<span class="w">    </span><span class="o">&#39;</span><span class="na">outer</span>: <span class="nc">for</span><span class="w"> </span><span class="n">possible_syntax</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">syntax</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">raw</span><span class="p">[</span><span class="n">initial_loc</span><span class="p">.</span><span class="n">index</span><span class="p">];</span>
<span class="w">        </span><span class="n">next_loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initial_loc</span><span class="p">;</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">is_alphanumeric</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;_&#39;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">value</span><span class="p">.</span><span class="n">push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">.</span><span class="n">to_string</span><span class="p">());</span>
<span class="w">            </span><span class="n">next_loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next_loc</span><span class="p">.</span><span class="n">increment</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
<span class="w">            </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">raw</span><span class="p">[</span><span class="n">next_loc</span><span class="p">.</span><span class="n">index</span><span class="p">];</span>

<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next_loc</span><span class="p">.</span><span class="n">index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">initial_loc</span><span class="p">.</span><span class="n">index</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">possible_syntax</span><span class="p">[</span><span class="o">..</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span>
<span class="w">                </span><span class="k">continue</span><span class="w"> </span><span class="nl">&#39;outer</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Not a complete match</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">value</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">possible_syntax</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// If it got to this point it found a match, so exit early.</span>
<span class="w">        </span><span class="c1">// We don&#39;t need a longest match.</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">value</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
<p>Aside from matching a list of strings we have to make sure
there is a complete match. For example <code>function1</code> is not a keyword,
it's a valid identifier. Whereas <code>function 1</code> is a valid set of tokens
(the keyword <code>function</code> and the number <code>1</code>), even if it's not a valid
Lua grammar.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">// If the next character would be part of a valid identifier, then</span>
<span class="w">    </span><span class="c1">// this is not a keyword.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">next_loc</span><span class="p">.</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">raw</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">next_c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">raw</span><span class="p">[</span><span class="n">next_loc</span><span class="p">.</span><span class="n">index</span><span class="p">];</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">next_c</span><span class="p">.</span><span class="n">is_alphanumeric</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">next_c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;_&#39;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nb">Some</span><span class="p">((</span>
<span class="w">        </span><span class="n">Token</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">value</span>: <span class="nc">value</span><span class="p">,</span>
<span class="w">            </span><span class="n">loc</span>: <span class="nc">initial_loc</span><span class="p">,</span>
<span class="w">            </span><span class="n">kind</span>: <span class="nc">TokenKind</span>::<span class="n">Keyword</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="n">next_loc</span><span class="p">,</span>
<span class="w">    </span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
<h4 id="syntax">Syntax</h4><p>Syntax (in this context) is just language junk that isn't
operators. Things like commas, parenthesis, etc.</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">lex_syntax</span><span class="p">(</span><span class="n">raw</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">char</span><span class="p">],</span><span class="w"> </span><span class="n">initial_loc</span>: <span class="nc">Location</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Token</span><span class="p">,</span><span class="w"> </span><span class="n">Location</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">syntax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;;&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;=&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;(&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p">];</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">possible_syntax</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">syntax</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">raw</span><span class="p">[</span><span class="n">initial_loc</span><span class="p">.</span><span class="n">index</span><span class="p">];</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">next_loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initial_loc</span><span class="p">.</span><span class="n">increment</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// TODO: this won&#39;t work with multiple-character syntax bits like &gt;= or ==</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">possible_syntax</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">to_string</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">Some</span><span class="p">((</span>
<span class="w">                </span><span class="n">Token</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">value</span>: <span class="nc">possible_syntax</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span>
<span class="w">                    </span><span class="n">loc</span>: <span class="nc">initial_loc</span><span class="p">,</span>
<span class="w">                    </span><span class="n">kind</span>: <span class="nc">TokenKind</span>::<span class="n">Syntax</span><span class="p">,</span>
<span class="w">                </span><span class="p">},</span>
<span class="w">                </span><span class="n">next_loc</span><span class="p">,</span>
<span class="w">            </span><span class="p">));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nb">None</span>
<span class="p">}</span>
</pre></div>
<h4 id="operators">Operators</h4><p>Operators are things like plus, minus, and less than
symbols. Operators are syntax but it helps us later on to break these
out into a seperate type of token.</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">lex_operator</span><span class="p">(</span><span class="n">raw</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">char</span><span class="p">],</span><span class="w"> </span><span class="n">initial_loc</span>: <span class="nc">Location</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Token</span><span class="p">,</span><span class="w"> </span><span class="n">Location</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">operators</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;+&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;-&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&lt;&quot;</span><span class="p">];</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">possible_syntax</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">operators</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">raw</span><span class="p">[</span><span class="n">initial_loc</span><span class="p">.</span><span class="n">index</span><span class="p">];</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">next_loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initial_loc</span><span class="p">.</span><span class="n">increment</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// TODO: this won&#39;t work with multiple-character operators like &gt;= or ==</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">possible_syntax</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">to_string</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">Some</span><span class="p">((</span>
<span class="w">                </span><span class="n">Token</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">value</span>: <span class="nc">possible_syntax</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span>
<span class="w">                    </span><span class="n">loc</span>: <span class="nc">initial_loc</span><span class="p">,</span>
<span class="w">                    </span><span class="n">kind</span>: <span class="nc">TokenKind</span>::<span class="n">Operator</span><span class="p">,</span>
<span class="w">                </span><span class="p">},</span>
<span class="w">                </span><span class="n">next_loc</span><span class="p">,</span>
<span class="w">            </span><span class="p">));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nb">None</span>
<span class="p">}</span>
</pre></div>
<p>And now we're all done lexing!</p>
<h3 id="grammar-analysis">Grammar analysis</h3><p>Parsing finds grammatical (tree) patterns in a flat list of
tokens. This is called a syntax tree or abstract syntax tree (AST).</p>
<p>The boring part is defining the tree. Generally speaking (and
specifically for this project), the syntax tree is a list of
statements. Statements can be function definitions or expression
statements or if statements or return statements or local
declarations.</p>
<p>This goes in <code>src/parse.rs</code>.</p>
<div class="highlight"><pre><span></span><span class="cp">#[derive(Debug)]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Statement</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Expression</span><span class="p">(</span><span class="n">Expression</span><span class="p">),</span>
<span class="w">    </span><span class="n">If</span><span class="p">(</span><span class="n">If</span><span class="p">),</span>
<span class="w">    </span><span class="n">FunctionDeclaration</span><span class="p">(</span><span class="n">FunctionDeclaration</span><span class="p">),</span>
<span class="w">    </span><span class="n">Return</span><span class="p">(</span><span class="n">Return</span><span class="p">),</span>
<span class="w">    </span><span class="n">Local</span><span class="p">(</span><span class="n">Local</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">type</span> <span class="nc">Ast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Statement</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
<p>There's almost nothing special at all about the rest of the tree
definitions.</p>
<div class="highlight"><pre><span></span><span class="cp">#[derive(Debug)]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Literal</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Identifier</span><span class="p">(</span><span class="n">Token</span><span class="p">),</span>
<span class="w">    </span><span class="n">Number</span><span class="p">(</span><span class="n">Token</span><span class="p">),</span>
<span class="p">}</span>

<span class="cp">#[derive(Debug)]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">FunctionCall</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">name</span>: <span class="nc">Token</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">arguments</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Expression</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="cp">#[derive(Debug)]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">BinaryOperation</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">operator</span>: <span class="nc">Token</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">left</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Expression</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">right</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Expression</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="cp">#[derive(Debug)]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Expression</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FunctionCall</span><span class="p">(</span><span class="n">FunctionCall</span><span class="p">),</span>
<span class="w">    </span><span class="n">BinaryOperation</span><span class="p">(</span><span class="n">BinaryOperation</span><span class="p">),</span>
<span class="w">    </span><span class="n">Literal</span><span class="p">(</span><span class="n">Literal</span><span class="p">),</span>
<span class="p">}</span>

<span class="cp">#[derive(Debug)]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">FunctionDeclaration</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">name</span>: <span class="nc">Token</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">parameters</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">body</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Statement</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="cp">#[derive(Debug)]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">If</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">test</span>: <span class="nc">Expression</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">body</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Statement</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="cp">#[derive(Debug)]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Local</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">name</span>: <span class="nc">Token</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">expression</span>: <span class="nc">Expression</span><span class="p">,</span>
<span class="p">}</span>

<span class="cp">#[derive(Debug)]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Return</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">expression</span>: <span class="nc">Expression</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
<p>And that's it for the AST!</p>
<h4 id="some-helpers">Some helpers</h4><p>Lastly before the fun part, we'll define a few helpers for validating
each kind of token.</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">expect_keyword</span><span class="p">(</span><span class="n">tokens</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">Token</span><span class="p">],</span><span class="w"> </span><span class="n">index</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">value</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">tokens</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokens</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">clone</span><span class="p">();</span>
<span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">kind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TokenKind</span>::<span class="n">Keyword</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">value</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">expect_syntax</span><span class="p">(</span><span class="n">tokens</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">Token</span><span class="p">],</span><span class="w"> </span><span class="n">index</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">value</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">tokens</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokens</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">clone</span><span class="p">();</span>
<span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">kind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TokenKind</span>::<span class="n">Syntax</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">value</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">expect_identifier</span><span class="p">(</span><span class="n">tokens</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">Token</span><span class="p">],</span><span class="w"> </span><span class="n">index</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">tokens</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokens</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">clone</span><span class="p">();</span>
<span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">kind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TokenKind</span>::<span class="n">Identifier</span>
<span class="p">}</span>
</pre></div>
<p>Now on to the fun part, actually detecting these trees!</p>
<h4 id="top-level-parse">Top-level parse</h4><p>The top-level <code>parse</code> function and it's major helper,
<code>parse_statement</code>, dispatch very similarly to the top-level lex
function. For each statement in the file we look for function
declarations, if statements, return statements, local declarations,
and expression statements.</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">parse_statement</span><span class="p">(</span><span class="n">raw</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">char</span><span class="p">],</span><span class="w"> </span><span class="n">tokens</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">Token</span><span class="p">],</span><span class="w"> </span><span class="n">index</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Statement</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">parsers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="n">parse_if</span><span class="p">,</span>
<span class="w">        </span><span class="n">parse_expression_statement</span><span class="p">,</span>
<span class="w">        </span><span class="n">parse_return</span><span class="p">,</span>
<span class="w">        </span><span class="n">parse_function</span><span class="p">,</span>
<span class="w">        </span><span class="n">parse_local</span><span class="p">,</span>
<span class="w">    </span><span class="p">];</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">parser</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">parsers</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">res</span><span class="p">.</span><span class="n">is_some</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nb">None</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">parse</span><span class="p">(</span><span class="n">raw</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">char</span><span class="p">],</span><span class="w"> </span><span class="n">tokens</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Ast</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[];</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ntokens</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokens</span><span class="p">.</span><span class="n">len</span><span class="p">();</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ntokens</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse_statement</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">((</span><span class="n">stmt</span><span class="p">,</span><span class="w"> </span><span class="n">next_index</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next_index</span><span class="p">;</span>
<span class="w">            </span><span class="n">ast</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">stmt</span><span class="p">);</span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">loc</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Invalid token while parsing:&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<h4 id="expression-statements">Expression statements</h4><p>Expression statements are just a wrapper for the Rust type
system. They call <code>parse_expression</code> (which we'll define shortly),
expect a semicolon afterward, and wrap the expression in a statement.</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">parse_expression_statement</span><span class="p">(</span>
<span class="w">    </span><span class="n">raw</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">char</span><span class="p">],</span>
<span class="w">    </span><span class="n">tokens</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">Token</span><span class="p">],</span>
<span class="w">    </span><span class="n">index</span>: <span class="kt">usize</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Statement</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">next_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse_expression</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">next_index</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="n">next_next_index</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="w">    </span><span class="n">next_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next_next_index</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">expect_syntax</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">next_index</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;;&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span>
<span class="w">            </span><span class="s">&quot;{}&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="n">tokens</span><span class="p">[</span><span class="n">next_index</span><span class="p">]</span>
<span class="w">                </span><span class="p">.</span><span class="n">loc</span>
<span class="w">                </span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected semicolon after expression:&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">next_index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Skip past semicolon</span>

<span class="w">    </span><span class="nb">Some</span><span class="p">((</span><span class="n">Statement</span>::<span class="n">Expression</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span><span class="w"> </span><span class="n">next_index</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
<h4 id="expressions">Expressions</h4><p>Expressions in this minimal Lua are only one of function calls,
literals (numbers, identifiers), or binary operations. To keep things
very simple, binary operations cannot be combined. So instead of <code>1 +
2 + 3</code> we'd need to do <code>local tmp1 = 1 + 2; local tmp2 = tmp1 + 3;</code>
and so on.</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">parse_expression</span><span class="p">(</span><span class="n">raw</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">char</span><span class="p">],</span><span class="w"> </span><span class="n">tokens</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">Token</span><span class="p">],</span><span class="w"> </span><span class="n">index</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Expression</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">tokens</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokens</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">clone</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">kind</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">TokenKind</span>::<span class="n">Number</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Expression</span>::<span class="n">Literal</span><span class="p">(</span><span class="n">Literal</span>::<span class="n">Number</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span>
<span class="w">        </span><span class="n">TokenKind</span>::<span class="n">Identifier</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Expression</span>::<span class="n">Literal</span><span class="p">(</span><span class="n">Literal</span>::<span class="n">Identifier</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span>
</pre></div>
<p>If what follows the first literal is an open parenthesis then we try
to parse a function call.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">next_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">expect_syntax</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">next_index</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;(&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">next_index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Skip past open paren</span>

<span class="w">        </span><span class="c1">// Function call</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">arguments</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Expression</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[];</span>
</pre></div>
<p>We need to call <code>parse_expression</code> recursively for every possible
argument passed to the function.</p>
<div class="highlight"><pre><span></span><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="o">!</span><span class="n">expect_syntax</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">next_index</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">arguments</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">expect_syntax</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">next_index</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="fm">println!</span><span class="p">(</span>
<span class="w">                        </span><span class="s">&quot;{}&quot;</span><span class="p">,</span>
<span class="w">                        </span><span class="n">tokens</span><span class="p">[</span><span class="n">next_index</span><span class="p">]</span>
<span class="w">                            </span><span class="p">.</span><span class="n">loc</span>
<span class="w">                            </span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected comma between function call arguments:&quot;</span><span class="p">)</span>
<span class="w">                    </span><span class="p">);</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="n">next_index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Skip past comma</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse_expression</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">next_index</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">((</span><span class="n">arg</span><span class="p">,</span><span class="w"> </span><span class="n">next_next_index</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">next_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next_next_index</span><span class="p">;</span>
<span class="w">                </span><span class="n">arguments</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="fm">println!</span><span class="p">(</span>
<span class="w">                    </span><span class="s">&quot;{}&quot;</span><span class="p">,</span>
<span class="w">                    </span><span class="n">tokens</span><span class="p">[</span><span class="n">next_index</span><span class="p">]</span>
<span class="w">                        </span><span class="p">.</span><span class="n">loc</span>
<span class="w">                        </span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected valid expression in function call arguments:&quot;</span><span class="p">)</span>
<span class="w">                </span><span class="p">);</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">next_index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Skip past closing paren</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">Some</span><span class="p">((</span>
<span class="w">            </span><span class="n">Expression</span>::<span class="n">FunctionCall</span><span class="p">(</span><span class="n">FunctionCall</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">name</span>: <span class="nc">tokens</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">clone</span><span class="p">(),</span>
<span class="w">                </span><span class="n">arguments</span><span class="p">,</span>
<span class="w">            </span><span class="p">}),</span>
<span class="w">            </span><span class="n">next_index</span><span class="p">,</span>
<span class="w">        </span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
<p>Otherwise if there isn't an opening parenthesis then we could be
parsing either a literal expression or a binary operation. If the
token that follows is an operator token then we know it's a binary
operation.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">// Might be a literal expression</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">next_index</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">tokens</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">tokens</span><span class="p">[</span><span class="n">next_index</span><span class="p">].</span><span class="n">clone</span><span class="p">().</span><span class="n">kind</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">TokenKind</span>::<span class="n">Operator</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">Some</span><span class="p">((</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">next_index</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Otherwise is a binary operation</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokens</span><span class="p">[</span><span class="n">next_index</span><span class="p">].</span><span class="n">clone</span><span class="p">();</span>
<span class="w">    </span><span class="n">next_index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Skip past op</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">next_index</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">tokens</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span>
<span class="w">            </span><span class="s">&quot;{}&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="n">tokens</span><span class="p">[</span><span class="n">next_index</span><span class="p">]</span>
<span class="w">                </span><span class="p">.</span><span class="n">loc</span>
<span class="w">                </span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected valid right hand side binary operand:&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">rtoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokens</span><span class="p">[</span><span class="n">next_index</span><span class="p">].</span><span class="n">clone</span><span class="p">();</span>
</pre></div>
<p>It is at this point that we <em>could</em> (but won't) call
<code>parse_expression</code> recursively. I don't want to deal with operator
precedence right now so we'll just require that the right hand side is
another literal.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">rtoken</span><span class="p">.</span><span class="n">kind</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">TokenKind</span>::<span class="n">Number</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Expression</span>::<span class="n">Literal</span><span class="p">(</span><span class="n">Literal</span>::<span class="n">Number</span><span class="p">(</span><span class="n">rtoken</span><span class="p">)),</span>
<span class="w">        </span><span class="n">TokenKind</span>::<span class="n">Identifier</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Expression</span>::<span class="n">Literal</span><span class="p">(</span><span class="n">Literal</span>::<span class="n">Identifier</span><span class="p">(</span><span class="n">rtoken</span><span class="p">)),</span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="fm">println!</span><span class="p">(</span>
<span class="w">                </span><span class="s">&quot;{}&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="n">rtoken</span>
<span class="w">                    </span><span class="p">.</span><span class="n">loc</span>
<span class="w">                    </span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected valid right hand side binary operand:&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">next_index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Skip past right hand operand</span>

<span class="w">    </span><span class="nb">Some</span><span class="p">((</span>
<span class="w">        </span><span class="n">Expression</span>::<span class="n">BinaryOperation</span><span class="p">(</span><span class="n">BinaryOperation</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">left</span>: <span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">left</span><span class="p">),</span>
<span class="w">            </span><span class="n">right</span>: <span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">right</span><span class="p">),</span>
<span class="w">            </span><span class="n">operator</span>: <span class="nc">op</span><span class="p">,</span>
<span class="w">        </span><span class="p">}),</span>
<span class="w">        </span><span class="n">next_index</span><span class="p">,</span>
<span class="w">    </span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
<p>And now we're done parsing expressions!</p>
<h4 id="function-declarations">Function declarations</h4><p>Functions start with the <code>function</code> keyword, and an identifier token follows.</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">parse_function</span><span class="p">(</span><span class="n">raw</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">char</span><span class="p">],</span><span class="w"> </span><span class="n">tokens</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">Token</span><span class="p">],</span><span class="w"> </span><span class="n">index</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Statement</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">expect_keyword</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;function&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">next_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">expect_identifier</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">next_index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span>
<span class="w">            </span><span class="s">&quot;{}&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="n">tokens</span><span class="p">[</span><span class="n">next_index</span><span class="p">]</span>
<span class="w">                </span><span class="p">.</span><span class="n">loc</span>
<span class="w">                </span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected valid identifier for function name:&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokens</span><span class="p">[</span><span class="n">next_index</span><span class="p">].</span><span class="n">clone</span><span class="p">();</span>
</pre></div>
<p>After the function name comes the argument list that can be empty or a
comma separated list of identifiers.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="n">next_index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Skip past name</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">expect_syntax</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">next_index</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;(&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span>
<span class="w">            </span><span class="s">&quot;{}&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="n">tokens</span><span class="p">[</span><span class="n">next_index</span><span class="p">]</span>
<span class="w">                </span><span class="p">.</span><span class="n">loc</span>
<span class="w">                </span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected open parenthesis in function declaration:&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">next_index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Skip past open paren</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">parameters</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[];</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="o">!</span><span class="n">expect_syntax</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">next_index</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">parameters</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">expect_syntax</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">next_index</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">tokens</span><span class="p">[</span><span class="n">next_index</span><span class="p">].</span><span class="n">loc</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected comma or close parenthesis after parameter in function declaration:&quot;</span><span class="p">));</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="n">next_index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Skip past comma</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">parameters</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">next_index</span><span class="p">].</span><span class="n">clone</span><span class="p">());</span>
<span class="w">        </span><span class="n">next_index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Skip past param</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">next_index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Skip past close paren</span>
</pre></div>
<p>Next we parse all statements in the function body until we find the
<code>end</code> keyword.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">statements</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Statement</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[];</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="o">!</span><span class="n">expect_keyword</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">next_index</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;end&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse_statement</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">next_index</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">((</span><span class="n">stmt</span><span class="p">,</span><span class="w"> </span><span class="n">next_next_index</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">next_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next_next_index</span><span class="p">;</span>
<span class="w">            </span><span class="n">statements</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">stmt</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="fm">println!</span><span class="p">(</span>
<span class="w">                </span><span class="s">&quot;{}&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="n">tokens</span><span class="p">[</span><span class="n">next_index</span><span class="p">]</span>
<span class="w">                    </span><span class="p">.</span><span class="n">loc</span>
<span class="w">                    </span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected valid statement in function declaration:&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">next_index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Skip past end</span>

<span class="w">    </span><span class="nb">Some</span><span class="p">((</span>
<span class="w">        </span><span class="n">Statement</span>::<span class="n">FunctionDeclaration</span><span class="p">(</span><span class="n">FunctionDeclaration</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">name</span><span class="p">,</span>
<span class="w">            </span><span class="n">parameters</span><span class="p">,</span>
<span class="w">            </span><span class="n">body</span>: <span class="nc">statements</span><span class="p">,</span>
<span class="w">        </span><span class="p">}),</span>
<span class="w">        </span><span class="n">next_index</span><span class="p">,</span>
<span class="w">    </span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
<p>Phew! We're halfway through the parser.</p>
<h4 id="return-statements">Return statements</h4><p>Return statements just check for the <code>return</code> keyword, an expression,
and a semicolon.</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">parse_return</span><span class="p">(</span><span class="n">raw</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">char</span><span class="p">],</span><span class="w"> </span><span class="n">tokens</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">Token</span><span class="p">],</span><span class="w"> </span><span class="n">index</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Statement</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">expect_keyword</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;return&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">next_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Skip past return</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse_expression</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">next_index</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">res</span><span class="p">.</span><span class="n">is_none</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span>
<span class="w">            </span><span class="s">&quot;{}&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="n">tokens</span><span class="p">[</span><span class="n">next_index</span><span class="p">]</span>
<span class="w">                </span><span class="p">.</span><span class="n">loc</span>
<span class="w">                </span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected valid expression in return statement:&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="n">next_next_index</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">res</span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">    </span><span class="n">next_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next_next_index</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">expect_syntax</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">next_index</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;;&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span>
<span class="w">            </span><span class="s">&quot;{}&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="n">tokens</span><span class="p">[</span><span class="n">next_index</span><span class="p">]</span>
<span class="w">                </span><span class="p">.</span><span class="n">loc</span>
<span class="w">                </span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected semicolon in return statement:&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">next_index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Skip past semicolon</span>

<span class="w">    </span><span class="nb">Some</span><span class="p">((</span><span class="n">Statement</span>::<span class="n">Return</span><span class="p">(</span><span class="n">Return</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">expression</span>: <span class="nc">expr</span><span class="w"> </span><span class="p">}),</span><span class="w"> </span><span class="n">next_index</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
<h4 id="local-declarations">Local declarations</h4><p>Local declarations start with the <code>local</code> keyword, then the local
name, then an equal sign, then an expression, and then a semicolon.</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">parse_local</span><span class="p">(</span><span class="n">raw</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">char</span><span class="p">],</span><span class="w"> </span><span class="n">tokens</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">Token</span><span class="p">],</span><span class="w"> </span><span class="n">index</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Statement</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">expect_keyword</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;local&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">next_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Skip past local</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">expect_identifier</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">next_index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span>
<span class="w">            </span><span class="s">&quot;{}&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="n">tokens</span><span class="p">[</span><span class="n">next_index</span><span class="p">]</span>
<span class="w">                </span><span class="p">.</span><span class="n">loc</span>
<span class="w">                </span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected valid identifier for local name:&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokens</span><span class="p">[</span><span class="n">next_index</span><span class="p">].</span><span class="n">clone</span><span class="p">();</span>
<span class="w">    </span><span class="n">next_index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Skip past name</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">expect_syntax</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">next_index</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;=&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span>
<span class="w">            </span><span class="s">&quot;{}&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="n">tokens</span><span class="p">[</span><span class="n">next_index</span><span class="p">]</span>
<span class="w">                </span><span class="p">.</span><span class="n">loc</span>
<span class="w">                </span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected = syntax after local name:&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">next_index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Skip past =</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse_expression</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">next_index</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">res</span><span class="p">.</span><span class="n">is_none</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span>
<span class="w">            </span><span class="s">&quot;{}&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="n">tokens</span><span class="p">[</span><span class="n">next_index</span><span class="p">]</span>
<span class="w">                </span><span class="p">.</span><span class="n">loc</span>
<span class="w">                </span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected valid expression in local declaration:&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="n">next_next_index</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">res</span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">    </span><span class="n">next_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next_next_index</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">expect_syntax</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">next_index</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;;&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span>
<span class="w">            </span><span class="s">&quot;{}&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="n">tokens</span><span class="p">[</span><span class="n">next_index</span><span class="p">]</span>
<span class="w">                </span><span class="p">.</span><span class="n">loc</span>
<span class="w">                </span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected semicolon in return statement:&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">next_index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Skip past semicolon</span>

<span class="w">    </span><span class="nb">Some</span><span class="p">((</span>
<span class="w">        </span><span class="n">Statement</span>::<span class="n">Local</span><span class="p">(</span><span class="n">Local</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">name</span><span class="p">,</span>
<span class="w">            </span><span class="n">expression</span>: <span class="nc">expr</span><span class="p">,</span>
<span class="w">        </span><span class="p">}),</span>
<span class="w">        </span><span class="n">next_index</span><span class="p">,</span>
<span class="w">    </span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
<h4 id="if-statements">If statements</h4><p>This implementation of Lua doesn't support <code>elseif</code> so parsing <code>if</code>
just checks for the <code>if</code> keyword followed by a test expression, then
the <code>else</code> keyword, then the if body (a list of statements), and then the
<code>end</code> keyword.</p>
<div class="highlight"><pre><span></span><span class="sx">fn</span><span class="w"> </span><span class="nl">parse_if(raw</span><span class="p">:</span><span class="w"> </span><span class="sx">&amp;[char],</span><span class="w"> </span><span class="nl">tokens</span><span class="p">:</span><span class="w"> </span><span class="sx">&amp;[Token],</span><span class="w"> </span><span class="nl">index</span><span class="p">:</span><span class="w"> </span><span class="sx">usize)</span><span class="w"> </span><span class="sx">-&gt;</span><span class="w"> </span><span class="sx">Option&lt;(Statement,</span><span class="w"> </span><span class="sx">usize)&gt;</span><span class="w"> </span><span class="sx">{</span>
<span class="w">    </span><span class="sx">if</span><span class="w"> </span><span class="sx">!expect_keyword(tokens,</span><span class="w"> </span><span class="sx">index,</span><span class="w"> </span><span class="s2">&quot;if&quot;</span><span class="sx">)</span><span class="w"> </span><span class="sx">{</span>
<span class="w">        </span><span class="kr">return</span><span class="w"> </span><span class="sx">None;</span>
<span class="w">    </span><span class="sx">}</span>

<span class="w">    </span><span class="sx">let</span><span class="w"> </span><span class="sx">mut</span><span class="w"> </span><span class="sx">next_index</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="sx">index</span><span class="w"> </span><span class="sx">+</span><span class="w"> </span><span class="sx">1;</span><span class="w"> </span><span class="sx">//</span><span class="w"> </span><span class="sx">Skip</span><span class="w"> </span><span class="sx">past</span><span class="w"> </span><span class="sx">if</span>
<span class="w">    </span><span class="sx">let</span><span class="w"> </span><span class="sx">res</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="sx">parse_expression(raw,</span><span class="w"> </span><span class="sx">tokens,</span><span class="w"> </span><span class="sx">next_index);</span>
<span class="w">    </span><span class="sx">if</span><span class="w"> </span><span class="sx">res.is_none()</span><span class="w"> </span><span class="sx">{</span>
<span class="w">        </span><span class="sx">println!(</span>
<span class="w">            </span><span class="s2">&quot;{}&quot;</span><span class="sx">,</span>
<span class="w">            </span><span class="sx">tokens[next_index]</span>
<span class="w">                </span><span class="sx">.loc</span>
<span class="w">                </span><span class="sx">.debug(raw,</span><span class="w"> </span><span class="s2">&quot;Expected valid expression for if test:&quot;</span><span class="sx">)</span>
<span class="w">        </span><span class="sx">);</span>
<span class="w">        </span><span class="kr">return</span><span class="w"> </span><span class="sx">None;</span>
<span class="w">    </span><span class="sx">}</span>

<span class="w">    </span><span class="sx">let</span><span class="w"> </span><span class="sx">(test,</span><span class="w"> </span><span class="sx">next_next_index)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="sx">res.unwrap();</span>
<span class="w">    </span><span class="sx">next_index</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="sx">next_next_index;</span>

<span class="w">    </span><span class="sx">if</span><span class="w"> </span><span class="sx">!expect_keyword(tokens,</span><span class="w"> </span><span class="sx">next_index,</span><span class="w"> </span><span class="s2">&quot;then&quot;</span><span class="sx">)</span><span class="w"> </span><span class="sx">{</span>
<span class="w">        </span><span class="kr">return</span><span class="w"> </span><span class="sx">None;</span>
<span class="w">    </span><span class="sx">}</span>

<span class="w">    </span><span class="sx">next_index</span><span class="w"> </span><span class="sx">+</span><span class="p">=</span><span class="w"> </span><span class="sx">1;</span><span class="w"> </span><span class="sx">//</span><span class="w"> </span><span class="sx">Skip</span><span class="w"> </span><span class="sx">past</span><span class="w"> </span><span class="sx">then</span>

<span class="w">    </span><span class="sx">let</span><span class="w"> </span><span class="sx">mut</span><span class="w"> </span><span class="nl">statements</span><span class="p">:</span><span class="w"> </span><span class="sx">Vec&lt;Statement&gt;</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="sx">vec![];</span>
<span class="w">    </span><span class="sx">while</span><span class="w"> </span><span class="sx">!expect_keyword(tokens,</span><span class="w"> </span><span class="sx">next_index,</span><span class="w"> </span><span class="s2">&quot;end&quot;</span><span class="sx">)</span><span class="w"> </span><span class="sx">{</span>
<span class="w">        </span><span class="sx">let</span><span class="w"> </span><span class="sx">res</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="sx">parse_statement(raw,</span><span class="w"> </span><span class="sx">tokens,</span><span class="w"> </span><span class="sx">next_index);</span>
<span class="w">        </span><span class="sx">if</span><span class="w"> </span><span class="sx">let</span><span class="w"> </span><span class="sx">Some((stmt,</span><span class="w"> </span><span class="sx">next_next_index))</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="sx">res</span><span class="w"> </span><span class="sx">{</span>
<span class="w">            </span><span class="sx">next_index</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="sx">next_next_index;</span>
<span class="w">            </span><span class="sx">statements.push(stmt);</span>
<span class="w">        </span><span class="sx">}</span><span class="w"> </span><span class="sx">else</span><span class="w"> </span><span class="sx">{</span>
<span class="w">            </span><span class="sx">println!(</span>
<span class="w">                </span><span class="s2">&quot;{}&quot;</span><span class="sx">,</span>
<span class="w">                </span><span class="sx">tokens[next_index]</span>
<span class="w">                    </span><span class="sx">.loc</span>
<span class="w">                    </span><span class="sx">.debug(raw,</span><span class="w"> </span><span class="s2">&quot;Expected valid statement in if body:&quot;</span><span class="sx">)</span>
<span class="w">            </span><span class="sx">);</span>
<span class="w">            </span><span class="kr">return</span><span class="w"> </span><span class="sx">None;</span>
<span class="w">        </span><span class="sx">}</span>
<span class="w">    </span><span class="sx">}</span>

<span class="w">    </span><span class="sx">next_index</span><span class="w"> </span><span class="sx">+</span><span class="p">=</span><span class="w"> </span><span class="sx">1;</span><span class="w"> </span><span class="sx">//</span><span class="w"> </span><span class="sx">Skip</span><span class="w"> </span><span class="sx">past</span><span class="w"> </span><span class="sx">end</span>

<span class="w">    </span><span class="sx">Some((</span>
<span class="w">        </span><span class="nl">Statement</span><span class="p">::</span><span class="nl">If(If</span><span class="w"> </span><span class="sx">{</span>
<span class="w">            </span><span class="sx">test,</span>
<span class="w">            </span><span class="nl">body</span><span class="p">:</span><span class="w"> </span><span class="sx">statements,</span>
<span class="w">        </span><span class="sx">}),</span>
<span class="w">        </span><span class="sx">next_index,</span>
<span class="w">    </span><span class="sx">))</span>
<span class="sx">}</span>
</pre></div>
<p>And goshdarnit we're done parsing.</p>
<h3 id="compiling-to-a-made-up-virtual-machine">Compiling to a made up virtual machine</h3><p>This virtual machine will be entirely stack-based other than the stack
pointer and program counter.</p>
<p>The calling convention is that the caller will put arguments on the
stack followed by the frame pointer, the program counter, and then the
number of arguments (for cleanup). Then it will alter the program
counter and frame pointer. Then the caller will allocate space on the
stack for all arguments and locals within the function.</p>
<p>For simplicity in addressing modes, the function declaration once
jumped to will copy the arguments from before the frame pointer to in
front of it (yes I know, I know, this is silly).</p>
<p>The virtual machine will support add, subtract, less than operations
as well as jump, jump-if-not-zero, return, and call. It will support a
few more memory-specific instructions for loading literals, loading
identifiers, and managing arguments.</p>
<p>I'll explain the non-obvious instructions as we implement them.</p>
<div class="highlight"><pre><span></span><span class="k">use</span><span class="w"> </span><span class="k">crate</span>::<span class="n">parse</span>::<span class="o">*</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">HashMap</span><span class="p">;</span>

<span class="cp">#[derive(Debug)]</span>
<span class="k">enum</span> <span class="nc">Instruction</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">DupPlusFP</span><span class="p">(</span><span class="kt">i32</span><span class="p">),</span>
<span class="w">    </span><span class="n">MoveMinusFP</span><span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">),</span>
<span class="w">    </span><span class="n">MovePlusFP</span><span class="p">(</span><span class="kt">usize</span><span class="p">),</span>
<span class="w">    </span><span class="n">Store</span><span class="p">(</span><span class="kt">i32</span><span class="p">),</span>
<span class="w">    </span><span class="n">Return</span><span class="p">,</span>
<span class="w">    </span><span class="n">JumpIfNotZero</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
<span class="w">    </span><span class="n">Jump</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
<span class="w">    </span><span class="n">Call</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">),</span>
<span class="w">    </span><span class="n">Add</span><span class="p">,</span>
<span class="w">    </span><span class="n">Subtract</span><span class="p">,</span>
<span class="w">    </span><span class="n">LessThan</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
<p>The result of compiling will be a <code>Program</code> instance. This instance
will contain symbol information and the actual instructions to run.</p>
<div class="highlight"><pre><span></span><span class="cp">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="nc">Symbol</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">location</span>: <span class="kt">i32</span><span class="p">,</span>
<span class="w">    </span><span class="n">narguments</span>: <span class="kt">usize</span><span class="p">,</span>
<span class="w">    </span><span class="n">nlocals</span>: <span class="kt">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="cp">#[derive(Debug)]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Program</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">syms</span>: <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">Symbol</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="n">instructions</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Instruction</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
<p>Compiling, similar to parsing, just calls the helper
<code>compile_statement</code> for each statement in the AST.</p>
<div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">compile</span><span class="p">(</span><span class="n">raw</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">char</span><span class="p">],</span><span class="w"> </span><span class="n">ast</span>: <span class="nc">Ast</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Program</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">locals</span>: <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashMap</span>::<span class="n">new</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">pgrm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Program</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">syms</span>: <span class="nc">HashMap</span>::<span class="n">new</span><span class="p">(),</span>
<span class="w">        </span><span class="n">instructions</span>: <span class="nb">Vec</span>::<span class="n">new</span><span class="p">(),</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">stmt</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">ast</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">compile_statement</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">pgrm</span><span class="p">,</span><span class="w"> </span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">locals</span><span class="p">,</span><span class="w"> </span><span class="n">stmt</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">pgrm</span>
<span class="p">}</span>
</pre></div>
<p>And <code>compile_statement</code> dispatches to additional helpers based on the
kind of statement.</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">compile_statement</span><span class="p">(</span>
<span class="w">    </span><span class="n">pgrm</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Program</span><span class="p">,</span>
<span class="w">    </span><span class="n">raw</span>: <span class="kp">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="n">locals</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="n">stmt</span>: <span class="nc">Statement</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">stmt</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Statement</span>::<span class="n">FunctionDeclaration</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">compile_declaration</span><span class="p">(</span><span class="n">pgrm</span><span class="p">,</span><span class="w"> </span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">locals</span><span class="p">,</span><span class="w"> </span><span class="n">fd</span><span class="p">),</span>
<span class="w">        </span><span class="n">Statement</span>::<span class="n">Return</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">compile_return</span><span class="p">(</span><span class="n">pgrm</span><span class="p">,</span><span class="w"> </span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">locals</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">),</span>
<span class="w">        </span><span class="n">Statement</span>::<span class="n">If</span><span class="p">(</span><span class="n">if_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">compile_if</span><span class="p">(</span><span class="n">pgrm</span><span class="p">,</span><span class="w"> </span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">locals</span><span class="p">,</span><span class="w"> </span><span class="n">if_</span><span class="p">),</span>
<span class="w">        </span><span class="n">Statement</span>::<span class="n">Local</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">compile_local</span><span class="p">(</span><span class="n">pgrm</span><span class="p">,</span><span class="w"> </span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">locals</span><span class="p">,</span><span class="w"> </span><span class="n">loc</span><span class="p">),</span>
<span class="w">        </span><span class="n">Statement</span>::<span class="n">Expression</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">compile_expression</span><span class="p">(</span><span class="n">pgrm</span><span class="p">,</span><span class="w"> </span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">locals</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">),</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h4 id="function-declarations">Function declarations</h4><p>Let's do the hard one first. First off, function declarations will
include an unconditional guard around them so that we can evaluate
from the 0th instruction at the top-level and have only
non-function-declaration statements be evaluated.</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">compile_declaration</span><span class="p">(</span>
<span class="w">    </span><span class="n">pgrm</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Program</span><span class="p">,</span>
<span class="w">    </span><span class="n">raw</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">char</span><span class="p">],</span>
<span class="w">    </span><span class="n">_</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="n">fd</span>: <span class="nc">FunctionDeclaration</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Jump to end of function to guard top-level</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">done_label</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">format!</span><span class="p">(</span><span class="s">&quot;function_done_{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pgrm</span><span class="p">.</span><span class="n">instructions</span><span class="p">.</span><span class="n">len</span><span class="p">());</span>
<span class="w">    </span><span class="n">pgrm</span><span class="p">.</span><span class="n">instructions</span>
<span class="w">        </span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Instruction</span>::<span class="n">Jump</span><span class="p">(</span><span class="n">done_label</span><span class="p">.</span><span class="n">clone</span><span class="p">()));</span>
</pre></div>
<p>Then we'll add another limitation/simplification that local variables
are only accessible within the current function scope.</p>
<p>For each parameter, we'll copy the parameter on the stack before the
frame pointer to a place in front of the frame pointer. This gets
around addressing mode limitations in our virtual machine.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">new_locals</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashMap</span>::<span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">();</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">function_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pgrm</span><span class="p">.</span><span class="n">instructions</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">narguments</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fd</span><span class="p">.</span><span class="n">parameters</span><span class="p">.</span><span class="n">len</span><span class="p">();</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">param</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">fd</span><span class="p">.</span><span class="n">parameters</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pgrm</span><span class="p">.</span><span class="n">instructions</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Instruction</span>::<span class="n">MoveMinusFP</span><span class="p">(</span>
<span class="w">            </span><span class="n">i</span><span class="p">,</span>
<span class="w">            </span><span class="n">narguments</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span>
<span class="w">        </span><span class="p">));</span>
<span class="w">        </span><span class="n">new_locals</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
<p>Then we compile the body.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">stmt</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">fd</span><span class="p">.</span><span class="n">body</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">compile_statement</span><span class="p">(</span><span class="n">pgrm</span><span class="p">,</span><span class="w"> </span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">new_locals</span><span class="p">,</span><span class="w"> </span><span class="n">stmt</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
<p>Once the body is compiled we know the total number of locals so we can
fill out the symbol table correctly. The location is importantly
already stored because it is the location of the instruction where the
function started.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="n">pgrm</span><span class="p">.</span><span class="n">syms</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span>
<span class="w">        </span><span class="n">fd</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">value</span><span class="p">,</span>
<span class="w">        </span><span class="n">Symbol</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">location</span>: <span class="nc">function_index</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span>
<span class="w">            </span><span class="n">narguments</span><span class="p">,</span>
<span class="w">            </span><span class="n">nlocals</span>: <span class="nc">new_locals</span><span class="p">.</span><span class="n">keys</span><span class="p">().</span><span class="n">len</span><span class="p">(),</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">    </span><span class="p">);</span>
</pre></div>
<p>Finally we add a symbol linking the done label for the function to
the position of the end of the function. Again, this allows us to skip
past the function declaration when evaluating instructions from 0 to
N.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="n">pgrm</span><span class="p">.</span><span class="n">syms</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span>
<span class="w">        </span><span class="n">done_label</span><span class="p">,</span>
<span class="w">        </span><span class="n">Symbol</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">location</span>: <span class="nc">pgrm</span><span class="p">.</span><span class="n">instructions</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span>
<span class="w">            </span><span class="n">narguments</span>: <span class="mi">0</span><span class="p">,</span>
<span class="w">            </span><span class="n">nlocals</span>: <span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">    </span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>Ok that wasn't so bad. And the rest are simpler.</p>
<h4 id="local-declarations">Local declarations</h4><p>The expression for the local is compiled and then the local name is
stored in a locals table mapped to the current number of locals
(including arguments). This allows the compiler to turn <code>identifier</code>
token lookups into simply an offset from the frame pointer.</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">compile_local</span><span class="p">(</span>
<span class="w">    </span><span class="n">pgrm</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Program</span><span class="p">,</span>
<span class="w">    </span><span class="n">raw</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">char</span><span class="p">],</span>
<span class="w">    </span><span class="n">locals</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="n">local</span>: <span class="nc">Local</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">locals</span><span class="p">.</span><span class="n">keys</span><span class="p">().</span><span class="n">len</span><span class="p">();</span>
<span class="w">    </span><span class="n">locals</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">local</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="p">);</span>
<span class="w">    </span><span class="n">compile_expression</span><span class="p">(</span><span class="n">pgrm</span><span class="p">,</span><span class="w"> </span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">locals</span><span class="p">,</span><span class="w"> </span><span class="n">local</span><span class="p">.</span><span class="n">expression</span><span class="p">);</span>
<span class="w">    </span><span class="n">pgrm</span><span class="p">.</span><span class="n">instructions</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Instruction</span>::<span class="n">MovePlusFP</span><span class="p">(</span><span class="n">index</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
<p>And specifically, the instruction pattern is to evaluate the
expression and then copy it back into a relative position in the
stack.</p>
<h4 id="literals">Literals</h4><p>Number literals use the <code>store</code> instruction for pushing a number onto
the stack. Identifier literals are copied to the top of the stack from
their position relative to the frame pointer.</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">compile_literal</span><span class="p">(</span>
<span class="w">    </span><span class="n">pgrm</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Program</span><span class="p">,</span>
<span class="w">    </span><span class="n">_</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">char</span><span class="p">],</span>
<span class="w">    </span><span class="n">locals</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="n">lit</span>: <span class="nc">Literal</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">lit</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Literal</span>::<span class="n">Number</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">            </span><span class="n">pgrm</span><span class="p">.</span><span class="n">instructions</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Instruction</span>::<span class="n">Store</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">Literal</span>::<span class="n">Identifier</span><span class="p">(</span><span class="n">ident</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">pgrm</span><span class="p">.</span><span class="n">instructions</span>
<span class="w">                </span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Instruction</span>::<span class="n">DupPlusFP</span><span class="p">(</span><span class="n">locals</span><span class="p">[</span><span class="o">&amp;</span><span class="n">ident</span><span class="p">.</span><span class="n">value</span><span class="p">]));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h4 id="function-calls">Function calls</h4><p>Pretty simple: just compile all the arguments and then issue a call
instruction.</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">compile_function_call</span><span class="p">(</span>
<span class="w">    </span><span class="n">pgrm</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Program</span><span class="p">,</span>
<span class="w">    </span><span class="n">raw</span>: <span class="kp">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="n">locals</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="n">fc</span>: <span class="nc">FunctionCall</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fc</span><span class="p">.</span><span class="n">arguments</span><span class="p">.</span><span class="n">len</span><span class="p">();</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">fc</span><span class="p">.</span><span class="n">arguments</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">compile_expression</span><span class="p">(</span><span class="n">pgrm</span><span class="p">,</span><span class="w"> </span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">locals</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">pgrm</span><span class="p">.</span><span class="n">instructions</span>
<span class="w">        </span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Instruction</span>::<span class="n">Call</span><span class="p">(</span><span class="n">fc</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
<h4 id="binary-operations">Binary operations</h4><p>Binary operations compile the left, then the right, and then issue an
instruction based on the operator. All the operators are builtin and
act on the top two elements on the stack.</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">compile_binary_operation</span><span class="p">(</span>
<span class="w">    </span><span class="n">pgrm</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Program</span><span class="p">,</span>
<span class="w">    </span><span class="n">raw</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">char</span><span class="p">],</span>
<span class="w">    </span><span class="n">locals</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="n">bop</span>: <span class="nc">BinaryOperation</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">compile_expression</span><span class="p">(</span><span class="n">pgrm</span><span class="p">,</span><span class="w"> </span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">locals</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">bop</span><span class="p">.</span><span class="n">left</span><span class="p">);</span>
<span class="w">    </span><span class="n">compile_expression</span><span class="p">(</span><span class="n">pgrm</span><span class="p">,</span><span class="w"> </span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">locals</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">bop</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">bop</span><span class="p">.</span><span class="n">operator</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">as_str</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="s">&quot;+&quot;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">pgrm</span><span class="p">.</span><span class="n">instructions</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Instruction</span>::<span class="n">Add</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="s">&quot;-&quot;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">pgrm</span><span class="p">.</span><span class="n">instructions</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Instruction</span>::<span class="n">Subtract</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="s">&quot;&lt;&quot;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">pgrm</span><span class="p">.</span><span class="n">instructions</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Instruction</span>::<span class="n">LessThan</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span>
<span class="w">            </span><span class="s">&quot;{}&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="n">bop</span><span class="p">.</span><span class="n">operator</span>
<span class="w">                </span><span class="p">.</span><span class="n">loc</span>
<span class="w">                </span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Unable to compile binary operation:&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">),</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h4 id="expressions">Expressions</h4><p>Compiling expressions just dispatches to a compile helper based on the
type of expression. We've already written those three helpers.</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">compile_expression</span><span class="p">(</span>
<span class="w">    </span><span class="n">pgrm</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Program</span><span class="p">,</span>
<span class="w">    </span><span class="n">raw</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">char</span><span class="p">],</span>
<span class="w">    </span><span class="n">locals</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="n">exp</span>: <span class="nc">Expression</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Expression</span>::<span class="n">BinaryOperation</span><span class="p">(</span><span class="n">bop</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">compile_binary_operation</span><span class="p">(</span><span class="n">pgrm</span><span class="p">,</span><span class="w"> </span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">locals</span><span class="p">,</span><span class="w"> </span><span class="n">bop</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">Expression</span>::<span class="n">FunctionCall</span><span class="p">(</span><span class="n">fc</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">compile_function_call</span><span class="p">(</span><span class="n">pgrm</span><span class="p">,</span><span class="w"> </span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">locals</span><span class="p">,</span><span class="w"> </span><span class="n">fc</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">Expression</span>::<span class="n">Literal</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">compile_literal</span><span class="p">(</span><span class="n">pgrm</span><span class="p">,</span><span class="w"> </span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">locals</span><span class="p">,</span><span class="w"> </span><span class="n">lit</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h4 id="if">If</h4><p>First we compile the conditional test and then we jump to after the if
the test result is not zero.</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">compile_if</span><span class="p">(</span><span class="n">pgrm</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Program</span><span class="p">,</span><span class="w"> </span><span class="n">raw</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">char</span><span class="p">],</span><span class="w"> </span><span class="n">locals</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">if_</span>: <span class="nc">If</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">compile_expression</span><span class="p">(</span><span class="n">pgrm</span><span class="p">,</span><span class="w"> </span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">locals</span><span class="p">,</span><span class="w"> </span><span class="n">if_</span><span class="p">.</span><span class="n">test</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">done_label</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">format!</span><span class="p">(</span><span class="s">&quot;if_else_{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pgrm</span><span class="p">.</span><span class="n">instructions</span><span class="p">.</span><span class="n">len</span><span class="p">());</span>
<span class="w">    </span><span class="n">pgrm</span><span class="p">.</span><span class="n">instructions</span>
<span class="w">        </span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Instruction</span>::<span class="n">JumpIfNotZero</span><span class="p">(</span><span class="n">done_label</span><span class="p">.</span><span class="n">clone</span><span class="p">()));</span>
</pre></div>
<p>Then we compile the body.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">stmt</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">if_</span><span class="p">.</span><span class="n">body</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">compile_statement</span><span class="p">(</span><span class="n">pgrm</span><span class="p">,</span><span class="w"> </span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">locals</span><span class="p">,</span><span class="w"> </span><span class="n">stmt</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
<p>And finally make sure we insert the <code>done</code> symbol in the right place after the if.</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="n">pgrm</span><span class="p">.</span><span class="n">syms</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span>
<span class="w">        </span><span class="n">done_label</span><span class="p">,</span>
<span class="w">        </span><span class="n">Symbol</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">location</span>: <span class="nc">pgrm</span><span class="p">.</span><span class="n">instructions</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">            </span><span class="n">nlocals</span>: <span class="mi">0</span><span class="p">,</span>
<span class="w">            </span><span class="n">narguments</span>: <span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">    </span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<h4 id="return">Return</h4><p>The final statement type is return. We simply compile the return
expression and issue a return instruction.</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">compile_return</span><span class="p">(</span>
<span class="w">    </span><span class="n">pgrm</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Program</span><span class="p">,</span>
<span class="w">    </span><span class="n">raw</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">char</span><span class="p">],</span>
<span class="w">    </span><span class="n">locals</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="n">ret</span>: <span class="nc">Return</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">compile_expression</span><span class="p">(</span><span class="n">pgrm</span><span class="p">,</span><span class="w"> </span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="n">locals</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">.</span><span class="n">expression</span><span class="p">);</span>
<span class="w">    </span><span class="n">pgrm</span><span class="p">.</span><span class="n">instructions</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Instruction</span>::<span class="n">Return</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>That's it for the compiler! Now the trickiest part. I lost a few hours
debugging and iterating on the next bit.</p>
<h3 id="the-virtual-machine">The virtual machine</h3><p>Ok so the easy part is that there are only two registers, a program
counter and a frame pointer. There's also a data stack. The frame
pointer points to the location on the data stack where each function
can start storing its locals.</p>
<p>Evaluation starts from 0 and goes until the last instruction.</p>
<div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">eval</span><span class="p">(</span><span class="n">pgrm</span>: <span class="nc">Program</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">pc</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">fp</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">data</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[];</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="n">pc</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pgrm</span><span class="p">.</span><span class="n">instructions</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pgrm</span><span class="p">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">pc</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
</pre></div>
<p>Each instruction will be responsible for incrementing the program
counter or having it jump around.</p>
<h4 id="addition,-subtraction,-less-than">Addition, subtraction, less than</h4><p>The easiest ones are the math operators. We just pop off the data
stack, perform the operation, and store the result.</p>
<div class="highlight"><pre><span></span><span class="w">            </span><span class="n">Instruction</span>::<span class="n">Add</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">                </span><span class="n">data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>
<span class="w">                </span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">Instruction</span>::<span class="n">Subtract</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">                </span><span class="n">data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>
<span class="w">                </span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">Instruction</span>::<span class="n">LessThan</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">                </span><span class="n">data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">});</span>
<span class="w">                </span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
</pre></div>
<p>The <code>store</code> instruction is another easy one. It just pushes a literal
number onto the stack.</p>
<div class="highlight"><pre><span></span><span class="w">            </span><span class="n">Instruction</span>::<span class="n">Store</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="p">);</span>
<span class="w">                </span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
</pre></div>
<h4 id="jump-variants">Jump variants</h4><p>The jump variants are easy too. Just grab the location and change the
program counter. If it's a conditional jump then test the condition
first.</p>
<div class="highlight"><pre><span></span><span class="w">            </span><span class="n">Instruction</span>::<span class="n">JumpIfNotZero</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">pc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pgrm</span><span class="p">.</span><span class="n">syms</span><span class="p">[</span><span class="n">label</span><span class="p">].</span><span class="n">location</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">Instruction</span>::<span class="n">Jump</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">pc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pgrm</span><span class="p">.</span><span class="n">syms</span><span class="p">[</span><span class="n">label</span><span class="p">].</span><span class="n">location</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
</pre></div>
<h4 id="loading-from-a-variable">Loading from a variable</h4><p>The <code>MovePlusFP</code> instruction copies a value from the stack (offset the
frame pointer) onto the top of the stack. This is for references to
arguments and locals.</p>
<div class="highlight"><pre><span></span><span class="w">            </span><span class="n">Instruction</span>::<span class="n">MovePlusFP</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
<span class="w">                </span><span class="c1">// Accounts for top-level locals</span>
<span class="w">                </span><span class="k">while</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="w">                </span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
</pre></div>
<h4 id="storing-locals">Storing locals</h4><p>The <code>DupPlusFP</code> instruction is used by <code>compile_locals</code> to store a
local once compiled onto the stack in the relative position from the
frame pointer.</p>
<div class="highlight"><pre><span></span><span class="w">            </span><span class="n">Instruction</span>::<span class="n">DupPlusFP</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">data</span><span class="p">[(</span><span class="n">fp</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">]);</span>
<span class="w">                </span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
</pre></div>
<h4 id="duplicating-arguments">Duplicating arguments</h4><p>The <code>MoveMinusFP</code> instruction is, again, a hack to work around limited
addressing modes in this minimal virtual machine. It copies
arguments from behind the frame pointer to in front of the frame
pointer.</p>
<div class="highlight"><pre><span></span><span class="w">            </span><span class="n">Instruction</span>::<span class="n">MoveMinusFP</span><span class="p">(</span><span class="n">local_offset</span><span class="p">,</span><span class="w"> </span><span class="n">fp_offset</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">data</span><span class="p">[</span><span class="n">fp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">local_offset</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[(</span><span class="n">fp</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">fp_offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">];</span>
<span class="w">                </span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
</pre></div>
<p>Now we're down to the last two instructions: call and return.</p>
<h4 id="call">Call</h4><p>Call has a special dispatch for builtin functions (the only one that
exists being <code>print</code>).</p>
<div class="highlight"><pre><span></span><span class="w">            </span><span class="n">Instruction</span>::<span class="n">Call</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="w"> </span><span class="n">narguments</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// Handle builtin functions</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">label</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;print&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..*</span><span class="n">narguments</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="fm">print!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">unwrap</span><span class="p">());</span>
<span class="w">                        </span><span class="fm">print!</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">);</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="fm">println!</span><span class="p">();</span>
<span class="w">                    </span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">                    </span><span class="k">continue</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
</pre></div>
<p>Otherwise it pushes the current frame pointer, then the program
counter, and finally the number of arguments (not locals) onto the
stack for preservation. Then it sets up the new program counter and
frame pointer and creates space for all locals and arguments after the
new frame pointer.</p>
<div class="highlight"><pre><span></span><span class="w">                </span><span class="n">data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="w">                </span><span class="n">data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">                </span><span class="n">data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pgrm</span><span class="p">.</span><span class="n">syms</span><span class="p">[</span><span class="n">label</span><span class="p">].</span><span class="n">narguments</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="p">);</span>
<span class="w">                </span><span class="n">pc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pgrm</span><span class="p">.</span><span class="n">syms</span><span class="p">[</span><span class="n">label</span><span class="p">].</span><span class="n">location</span><span class="p">;</span>
<span class="w">                </span><span class="n">fp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span>

<span class="w">                </span><span class="c1">// Set up space for all arguments/locals</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">nlocals</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pgrm</span><span class="p">.</span><span class="n">syms</span><span class="p">[</span><span class="n">label</span><span class="p">].</span><span class="n">nlocals</span><span class="p">;</span>
<span class="w">                </span><span class="k">while</span><span class="w"> </span><span class="n">nlocals</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">                    </span><span class="n">nlocals</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
</pre></div>
<h4 id="return">Return</h4><p>The return instructions pops the return value from the stack. Then it
pops off all locals and arguments. Then it restores the program
counter and frame pointer, and pops off the arguments before the frame
pointer. Finally it adds the return value back onto the stack.</p>
<div class="highlight"><pre><span></span><span class="w">            </span><span class="n">Instruction</span>::<span class="n">Return</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">                </span><span class="c1">// Clean up the local stack</span>
<span class="w">                </span><span class="k">while</span><span class="w"> </span><span class="n">fp</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="c1">// Restore pc and fp</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">narguments</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">                </span><span class="n">pc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">                </span><span class="n">fp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">                </span><span class="c1">// Clean up arguments</span>
<span class="w">                </span><span class="k">while</span><span class="w"> </span><span class="n">narguments</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="w">                    </span><span class="n">narguments</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="c1">// Add back return value</span>
<span class="w">                </span><span class="n">data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
</pre></div>
<p>And yes, this implementation would be more efficient if instead of
literally pushing and popping we just incremented/decremented a
stack pointer.</p>
<p>And that's it! We're completely done a basic parser, compiler, and
virtual machine for a subet of Lua. Is it janky? Yeah. Is it simple?
Kind of? Does it work? It seems to!</p>
<h3 id="summary">Summary</h3><p>Ok we've got &lt;1200 lines of Rust enough to run some decent Lua
programs. We run this fib program against this implementation and
against Lua 5.4.3 (which isn't LuaJIT) and what do we see?</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>cargo<span class="w"> </span>build<span class="w"> </span>--release
$<span class="w"> </span>cat<span class="w"> </span>test/fib.lua
<span class="k">function</span><span class="w"> </span>fib<span class="o">(</span>n<span class="o">)</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span>n<span class="w"> </span>&lt;<span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="k">then</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span>n<span class="p">;</span>
<span class="w">   </span>end

<span class="w">   </span><span class="nb">local</span><span class="w"> </span><span class="nv">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>fib<span class="o">(</span>n-1<span class="o">)</span><span class="p">;</span>
<span class="w">   </span><span class="nb">local</span><span class="w"> </span><span class="nv">n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>fib<span class="o">(</span>n-2<span class="o">)</span><span class="p">;</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span>n1<span class="w"> </span>+<span class="w"> </span>n2<span class="p">;</span>
end

print<span class="o">(</span>fib<span class="o">(</span><span class="m">30</span><span class="o">))</span><span class="p">;</span>
$<span class="w"> </span><span class="nb">time</span><span class="w"> </span>./target/release/lust<span class="w"> </span>test/fib.lua
<span class="m">832040</span>
./target/release/lust<span class="w"> </span>test/fib.lua<span class="w">  </span><span class="m">0</span>.29s<span class="w"> </span>user<span class="w"> </span><span class="m">0</span>.00s<span class="w"> </span>system<span class="w"> </span><span class="m">99</span>%<span class="w"> </span>cpu<span class="w"> </span><span class="m">0</span>.293<span class="w"> </span>total
$<span class="w"> </span><span class="nb">time</span><span class="w"> </span>lua<span class="w"> </span>test/fib.lua
<span class="m">832040</span>
lua<span class="w"> </span>test/fib.lua<span class="w">  </span><span class="m">0</span>.06s<span class="w"> </span>user<span class="w"> </span><span class="m">0</span>.00s<span class="w"> </span>system<span class="w"> </span><span class="m">99</span>%<span class="w"> </span>cpu<span class="w"> </span><span class="m">0</span>.063<span class="w"> </span>total
</pre></div>
<p>This implementation is a bit slower! Time to do some profiling and maybe
revisit some of those aforementioned inefficiencies.</p>
<p class="note">
  Big thanks to <a
  href="https://twitter.com/christianfscott/status/1475832498663792640">Christian
  Scott on Twitter</a> for pointing out I should not be benchmarking
  with debug builds!
  <br /><br />
  And thanks
  to <a href="https://www.reddit.com/r/rust/comments/rqgm8t/comment/hqbwgwj/">reddit123123123123
  on Reddit</a> for suggesting I use <code>cargo clippy</code> to
  clean up my code.
  <br /><br />
  Thanks to <a href="https://github.com/eatonphil/lust/issues/1">GiffE
  on Github</a> for pointing out some key inconsistencies between this
  implementation and Lua. I won't modify anything because a perfect
  Lua subset wasn't the goal, but I'm sharing because it was good
  analysis and criticism of this implementation.
</p><p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">I wrote a new blog post on parsing, compiling, and virtual machine evaluation for a super minimal Lua implementation written from scratch in Rust!<a href="https://t.co/8qFviEecJo">https://t.co/8qFviEecJo</a> <a href="https://t.co/d1MGArlErR">pic.twitter.com/d1MGArlErR</a></p>&mdash; Phil Eaton (@phil_eaton) <a href="https://twitter.com/phil_eaton/status/1475828516835008513?ref_src=twsrc%5Etfw">December 28, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>
<style>.feedback{display:initial;}</style>
	</div>
	<div class="feedback">
	  <h4>Feedback</h4>
	  <p>As always,
	      please <a href="mailto:phil@eatonphil.com">email</a>
	      or <a href="https://twitter.com/eatonphil">tweet me</a>
	      with questions, corrections, or ideas!</p>

	</div>
      </div>
    </div>
    <footer>
      <div class="container">
	<div>
	  <div class="row">
	    <div class="feedback">
	      <h4>Frequent Topics</h4>
	      <div class="tags"><a href="/tags/javascript.html" class="tag">javascript (24)</a><a href="/tags/go.html" class="tag">go (24)</a><a href="/tags/databases.html" class="tag">databases (24)</a><a href="/tags/parsing.html" class="tag">parsing (21)</a><a href="/tags/postgres.html" class="tag">postgres (18)</a><a href="/tags/compilers.html" class="tag">compilers (14)</a><a href="/tags/sql.html" class="tag">sql (11)</a><a href="/tags/interpreters.html" class="tag">interpreters (11)</a><a href="/tags/zig.html" class="tag">zig (9)</a><a href="/tags/lisp.html" class="tag">lisp (9)</a><a href="/tags/books.html" class="tag">books (9)</a><a href="/tags/python.html" class="tag">python (8)</a><a href="/tags/linux.html" class="tag">linux (7)</a><a href="/tags/learning.html" class="tag">learning (7)</a><a href="/tags/json.html" class="tag">json (7)</a><a href="/tags/x86-amd64.html" class="tag">x86/amd64 (6)</a><a href="/tags/scheme.html" class="tag">scheme (6)</a><a href="/tags/c.html" class="tag">c (6)</a><a href="/tags/typescript.html" class="tag">typescript (5)</a><a href="/tags/mysql.html" class="tag">mysql (5)</a></div>
	    </div>
	  </div>
	  <div id="subscribe">
	    <style type="text/css">
  /* LOADER */
  .ml-form-embedSubmitLoad {
      display: inline-block;
      width: 20px;
      height: 20px;
  }
  .g-recaptcha {
      transform: scale(1);
      -webkit-transform: scale(1);
      transform-origin: 0 0;
      -webkit-transform-origin: 0 0;
      height: ;
  }
  .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0,0,0,0);
      border: 0;
  }
  .ml-form-embedSubmitLoad:after {
      content: " ";
      display: block;
      width: 11px;
      height: 11px;
      margin: 1px;
      border-radius: 50%;
      border: 4px solid #fff;
      border-color: #ffffff #ffffff #ffffff transparent;
      animation: ml-form-embedSubmitLoad 1.2s linear infinite;
  }
  @keyframes ml-form-embedSubmitLoad {
      0% {
          transform: rotate(0deg);
      }
      100% {
          transform: rotate(360deg);
      }
  }
  #mlb2-3175296.ml-form-embedContainer {
      box-sizing: border-box;
      display: table;
      margin: 0 auto;
      position: static;
      width: 100% !important;
  }
  #mlb2-3175296.ml-form-embedContainer h3,
  #mlb2-3175296.ml-form-embedContainer p,
  #mlb2-3175296.ml-form-embedContainer span,
  #mlb2-3175296.ml-form-embedContainer button {
      text-transform: none !important;
      letter-spacing: normal !important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper {
      border-width: 0px;
      border-color: transparent;
  border-radius: 4px;
  border-style: solid;
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  position: relative;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-align-left { text-align: left; }
  #mlb2-3175296.ml-form-embedContainer .ml-form-align-center {
  text-align: center;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-align-default { display: table-cell !important; vertical-align: middle !important; text-align: center !important; }
  #mlb2-3175296.ml-form-embedContainer .ml-form-align-right { text-align: right; }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedHeader img {
  border-top-left-radius: 4px;
  border-top-right-radius: 4px;
  height: auto;
  margin: 0 auto !important;
  max-width: 100%;
  width: undefinedpx;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody.ml-form-embedBodyHorizontal {
  padding-bottom: 0;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent {
  text-align: left;
  margin: 0 0 20px 0;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent p,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent p {
  color: #000000;
  font-size: 14px;
  font-weight: 400;
  line-height: 20px;
  margin: 0 0 10px 0;
  text-align: left;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent ul,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent ol,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent ul,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent ol {
  color: #000000;
  font-size: 14px;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent ol ol,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent ol ol {
  list-style-type: lower-alpha;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent ol ol ol,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent ol ol ol {
  list-style-type: lower-roman;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent p a,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent p a {
  color: #000000;
  text-decoration: underline;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-block-form .ml-field-group {
  text-align: left!important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-block-form .ml-field-group label {
  margin-bottom: 5px;
  color: #333333;
  font-size: 14px;
  font-weight: bold; font-style: normal; text-decoration: none;;
  display: inline-block;
  line-height: 20px;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent p:last-child,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-successBody .ml-form-successContent p:last-child {
  margin: 0;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody form {
  margin: 0;
  width: 100%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-formContent,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow {
  margin: 0 0 20px 0;
  width: 100%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow {
  float: left;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-formContent.horozintalForm {
  margin: 0;
  padding: 0 0 20px 0;
  width: 100%;
  height: auto;
  float: left;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow {
  margin: 0 0 10px 0;
  width: 100%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow.ml-last-item {
  margin: 0;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow.ml-formfieldHorizintal {
  margin: 0;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow input {
  background-color: #ffffff !important;
  color: #333333 !important;
  border-color: #cccccc;
  border-radius: 4px !important;
  border-style: solid !important;
  border-width: 1px !important;
  font-size: 14px !important;
  height: auto;
  line-height: 21px !important;
  margin-bottom: 0;
  margin-top: 0;
  margin-left: 0;
  margin-right: 0;
  padding: 10px 10px !important;
  width: 100% !important;
  box-sizing: border-box !important;
  max-width: 100% !important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow input::-webkit-input-placeholder,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow input::-webkit-input-placeholder { color: #333333; }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow input::-moz-placeholder,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow input::-moz-placeholder { color: #333333; }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow input:-ms-input-placeholder,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow input:-ms-input-placeholder { color: #333333; }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow input:-moz-placeholder,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow input:-moz-placeholder { color: #333333; }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow textarea, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow textarea {
  background-color: #ffffff !important;
  color: #333333 !important;
  border-color: #cccccc;
  border-radius: 4px !important;
  border-style: solid !important;
  border-width: 1px !important;
  font-size: 14px !important;
  height: auto;
  line-height: 21px !important;
  margin-bottom: 0;
  margin-top: 0;
  padding: 10px 10px !important;
  width: 100% !important;
  box-sizing: border-box !important;
  max-width: 100% !important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-radio .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::before {
  border-color: #cccccc!important;
  background-color: #ffffff!important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow input.custom-control-input[type="checkbox"]{
  box-sizing: border-box;
  padding: 0;
  position: absolute;
  z-index: -1;
  opacity: 0;
  margin-top: 5px;
  margin-left: -1.5rem;
  overflow: visible;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::before {
  border-radius: 4px!important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow input[type=checkbox]:checked~.label-description::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox input[type=checkbox]:checked~.label-description::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-input:checked~.custom-control-label::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-input:checked~.custom-control-label::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox input[type=checkbox]:checked~.label-description::after {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8'%3e%3cpath fill='%23fff' d='M6.564.75l-3.59 3.612-1.538-1.55L0 4.26 2.974 7.25 8 2.193z'/%3e%3c/svg%3e");
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-input:checked~.custom-control-label::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-input:checked~.custom-control-label::after {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='3' fill='%23fff'/%3e%3c/svg%3e");
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-input:checked~.custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-radio .custom-control-input:checked~.custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-input:checked~.custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-input:checked~.custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox input[type=checkbox]:checked~.label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox input[type=checkbox]:checked~.label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow input[type=checkbox]:checked~.label-description::before  {
  border-color: #000000!important;
  background-color: #000000!important;
  color: #ffffff!important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-radio .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-label::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-radio .custom-control-label::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-label::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-label::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-label::after {
  top: 2px;
  box-sizing: border-box;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox .label-description::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::after {
  top: 0px!important;
  box-sizing: border-box!important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::after {
  top: 0px!important;
  box-sizing: border-box!important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox .label-description::after {
  top: 0px!important;
  box-sizing: border-box!important;
  position: absolute;
  left: -1.5rem;
  display: block;
  width: 1rem;
  height: 1rem;
  content: "";
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox .label-description::before {
  top: 0px!important;
  box-sizing: border-box!important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .custom-control-label::before {
  position: absolute;
  top: 4px;
  left: -1.5rem;
  display: block;
  width: 16px;
  height: 16px;
  pointer-events: none;
  content: "";
  background-color: #ffffff;
  border: #adb5bd solid 1px;
  border-radius: 50%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .custom-control-label::after {
  position: absolute;
  top: 2px!important;
  left: -1.5rem;
  display: block;
  width: 1rem;
  height: 1rem;
  content: "";
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox .label-description::before, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::before {
  position: absolute;
  top: 4px;
  left: -1.5rem;
  display: block;
  width: 16px;
  height: 16px;
  pointer-events: none;
  content: "";
  background-color: #ffffff;
  border: #adb5bd solid 1px;
  border-radius: 50%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox .label-description::after {
  position: absolute;
  top: 0px!important;
  left: -1.5rem;
  display: block;
  width: 1rem;
  height: 1rem;
  content: "";
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::after {
  position: absolute;
  top: 0px!important;
  left: -1.5rem;
  display: block;
  width: 1rem;
  height: 1rem;
  content: "";
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .custom-radio .custom-control-label::after {
  background: no-repeat 50%/50% 50%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .custom-checkbox .custom-control-label::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedPermissions .ml-form-embedPermissionsOptionsCheckbox .label-description::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-interestGroupsRow .ml-form-interestGroupsRowCheckbox .label-description::after, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description::after {
  background: no-repeat 50%/50% 50%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-control, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-control {
  position: relative;
  display: block;
  min-height: 1.5rem;
  padding-left: 1.5rem;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-input, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-radio .custom-control-input, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-input, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-input {
  position: absolute;
  z-index: -1;
  opacity: 0;
  box-sizing: border-box;
  padding: 0;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-radio .custom-control-label, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-radio .custom-control-label, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-checkbox .custom-control-label, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-checkbox .custom-control-label {
  color: #000000;
  font-size: 12px!important;
  line-height: 22px;
  margin-bottom: 0;
  position: relative;
  vertical-align: top;
  font-style: normal;
  font-weight: 700;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow .custom-select, #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .custom-select {
  background-color: #ffffff !important;
  color: #333333 !important;
  border-color: #cccccc;
  border-radius: 4px !important;
  border-style: solid !important;
  border-width: 1px !important;
  font-size: 14px !important;
  line-height: 20px !important;
  margin-bottom: 0;
  margin-top: 0;
  padding: 10px 28px 10px 12px !important;
  width: 100% !important;
  box-sizing: border-box !important;
  max-width: 100% !important;
  height: auto;
  display: inline-block;
  vertical-align: middle;
  background: url('https://assets.mlcdn.com/ml/images/default/dropdown.svg') no-repeat right .75rem center/8px 10px;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow {
  height: auto;
  width: 100%;
  float: left;
  }
  .ml-form-formContent.horozintalForm .ml-form-horizontalRow .ml-input-horizontal { width: 70%; float: left; }
  .ml-form-formContent.horozintalForm .ml-form-horizontalRow .ml-button-horizontal { width: 30%; float: left; }
  .ml-form-formContent.horozintalForm .ml-form-horizontalRow .ml-button-horizontal.labelsOn { padding-top: 25px;  }
  .ml-form-formContent.horozintalForm .ml-form-horizontalRow .horizontal-fields { box-sizing: border-box; float: left; padding-right: 10px;  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow input {
  background-color: #ffffff;
  color: #333333;
  border-color: #cccccc;
  border-radius: 4px;
  border-style: solid;
  border-width: 1px;
  font-size: 14px;
  line-height: 20px;
  margin-bottom: 0;
  margin-top: 0;
  padding: 10px 10px;
  width: 100%;
  box-sizing: border-box;
  overflow-y: initial;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow button {
  background-color: #000000 !important;
  border-color: #000000;
  border-style: solid;
  border-width: 1px;
  border-radius: 4px;
  box-shadow: none;
  color: #ffffff !important;
  cursor: pointer;
  font-size: 14px !important;
  font-weight: 700;
  line-height: 20px;
  margin: 0 !important;
  padding: 10px !important;
  width: 100%;
  height: auto;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow button:hover {
  background-color: #333333 !important;
  border-color: #333333 !important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
  position: absolute;
  z-index: -1;
  opacity: 0;
  margin-top: 5px;
  margin-left: -1.5rem;
  overflow: visible;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow .label-description {
  color: #000000;
  display: block;
  font-size: 12px;
  text-align: left;
  margin-bottom: 0;
  position: relative;
  vertical-align: top;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow label {
  font-weight: normal;
  margin: 0;
  padding: 0;
  position: relative;
  display: block;
  min-height: 24px;
  padding-left: 24px;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow label a {
  color: #000000;
  text-decoration: underline;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow label p {
  color: #000000 !important;
  font-size: 12px !important;
  font-weight: normal !important;
  line-height: 18px !important;
  padding: 0 !important;
  margin: 0 5px 0 0 !important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow label p:last-child {
  margin: 0;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedSubmit {
  margin: 0 0 20px 0;
  float: left;
  width: 100%;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedSubmit button {
  background-color: #000000 !important;
  border: none !important;
  border-radius: 4px !important;
  box-shadow: none !important;
  color: #ffffff !important;
  cursor: pointer;
  font-size: 14px !important;
  font-weight: 700 !important;
  line-height: 21px !important;
  height: auto;
  padding: 10px !important;
  width: 100% !important;
  box-sizing: border-box !important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedSubmit button.loading {
  display: none;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedSubmit button:hover {
  background-color: #333333 !important;
  }
  .ml-subscribe-close {
  width: 30px;
  height: 30px;
  background: url('https://assets.mlcdn.com/ml/images/default/modal_close.png') no-repeat;
  background-size: 30px;
  cursor: pointer;
  margin-top: -10px;
  margin-right: -10px;
  position: absolute;
  top: 0;
  right: 0;
  }
  .ml-error input, .ml-error textarea, .ml-error select {
  border-color: red!important;
  }
  .ml-error .custom-checkbox-radio-list {
  border: 1px solid red !important;
  border-radius: 4px;
  padding: 10px;
  }
  .ml-error .label-description,
  .ml-error .label-description p,
  .ml-error .label-description p a,
  .ml-error label:first-child {
  color: #ff0000 !important;
  }
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow.ml-error .label-description p,
  #mlb2-3175296.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-checkboxRow.ml-error .label-description p:first-letter {
  color: #ff0000 !important;
  }
  @media only screen and (max-width: 400px){
  .ml-form-embedWrapper.embedDefault, .ml-form-embedWrapper.embedPopup { width: 100%!important; }
  .ml-form-formContent.horozintalForm { float: left!important; }
  .ml-form-formContent.horozintalForm .ml-form-horizontalRow { height: auto!important; width: 100%!important; float: left!important; }
  .ml-form-formContent.horozintalForm .ml-form-horizontalRow .ml-input-horizontal { width: 100%!important; }
  .ml-form-formContent.horozintalForm .ml-form-horizontalRow .ml-input-horizontal > div { padding-right: 0px!important; padding-bottom: 10px; }
    .ml-form-formContent.horozintalForm .ml-button-horizontal { width: 100%!important; }
    .ml-form-formContent.horozintalForm .ml-button-horizontal.labelsOn { padding-top: 0px!important; }
    }
</style>
<div id="mlb2-3175296" class="ml-form-embedContainer ml-subscribe-form ml-subscribe-form-3175296">
  <hr />
  <div class="ml-form-align-center ">
    <div class="ml-form-embedWrapper embedForm">
      <div class="ml-form-embedBody ml-form-embedBodyDefault row-form">
        <div class="ml-form-embedContent" style=" ">
          <h4>Subscribe</h4>
          <p>Enter your email if you'd like to be kept in the loop about future articles!<br><br>You can expect 2 to 4 messages per month depending on how motivated I'm feeling. :)</p>
	  <p></p>
	  <p>Cheers,<br>Phil</p>
        </div>
        <form class="ml-block-form" action="https://assets.mailerlite.com/jsonp/303114/forms/78235486326359572/subscribe" data-code="" method="post" target="_blank">
          <div class="ml-form-formContent">
            <div class="ml-form-fieldRow ml-last-item">
              <div class="ml-field-group ml-field-email ml-validate-email ml-validate-required">
                <!-- input -->
                <input aria-label="email" aria-required="true" type="email" class="form-control" data-inputmask="" name="fields[email]" placeholder="Email" autocomplete="email">
                <!-- /input -->
                <!-- textarea -->
                <!-- /textarea -->
                <!-- select -->
                <!-- /select -->
                <!-- checkboxes -->
		<!-- /checkboxes -->
                <!-- radio -->
                <!-- /radio -->
                <!-- countries -->
                <!-- /countries -->
              </div>
            </div>
          </div>
          <!-- Privacy policy -->
          <!-- /Privacy policy -->
	  <div class="ml-form-recaptcha ml-validate-required" style="float: left;">
            <style type="text/css">
	      .ml-form-recaptcha {
		  margin-bottom: 20px;
	      }
	      .ml-form-recaptcha.ml-error iframe {
		  border: solid 1px #ff0000;
	      }
	      @media screen and (max-width: 480px) {
		  .ml-form-recaptcha {
		      width: 220px!important
		  }
		  .g-recaptcha {
		      transform: scale(0.78);
		      -webkit-transform: scale(0.78);
		      transform-origin: 0 0;
		      -webkit-transform-origin: 0 0;
		  }
	      }
	    </style>
	    <script src="https://www.google.com/recaptcha/api.js"></script>
	    <div class="g-recaptcha" data-sitekey="6Lf1KHQUAAAAAFNKEX1hdSWCS3mRMv4FlFaNslaD"></div>
	  </div>
          <input type="hidden" name="ml-submit" value="1">
          <div class="ml-form-embedSubmit">
            <button type="submit" class="primary">Subscribe</button>
            <button disabled="disabled" style="display: none;" type="button" class="loading">
              <div class="ml-form-embedSubmitLoad"></div>
              <span class="sr-only">Loading...</span>
            </button>
          </div>
          <input type="hidden" name="anticsrf" value="true">
        </form>
      </div>
      <div class="ml-form-successBody row-success" style="display: none">
        <div class="ml-form-successContent">
          <h3>Thanks :)</h3>
          <p>You're in.</p>
        </div>
      </div>
    </div>
  </div>
</div>
<script>
  function ml_webform_success_3175296() {
      var $ = ml_jQuery || jQuery;
      $('.ml-subscribe-form-3175296 .row-success').show();
      $('.ml-subscribe-form-3175296 .row-form').hide();
  }
</script>
<script src="https://groot.mailerlite.com/js/w/webforms.min.js?v300817f630ad0e957914d0b28a2b6d78" type="text/javascript"></script>

	  </div>
	</div>
      </div>
    </footer>
    <script async onload="loadGA()" src="https://www.googletagmanager.com/gtag/js?id=UA-58109156-2"></script>
    <script>
      function loadGA() {
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());
	  gtag('config', 'UA-58109156-2');
      }
    </script>
    <script defer src="https://cdn.usefathom.com/script.js" data-site="CEPUOLOQ"></script>
  </body>
</html>
