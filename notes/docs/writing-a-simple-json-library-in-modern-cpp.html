<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="canonical" href="https://notes.eatonphil.com/writing-a-simple-json-library-in-modern-cpp.html">
    <title>Writing a simple JSON library from scratch: a tour through modern C++ | notes.eatonphil.com</title>
    <meta name="description" content="Writing a simple JSON library from scratch: a tour through modern C++" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono">
  </head>
  <body>
    <header>
      <div class="lfw">
	<div class="container">
	  <div class="row">
	    <a href="https://eatonphil.com/30.html">Turning 30, a little fundraiser ðŸŽ‰</a>
	  </div>
	</div>
      </div>
      <div class="container">
        <div>
          <div class="row">
	    <div>
	      <a href="https://eatonphil.com" class="sm-link">
		Home
              </a>
	      <a href="/" class="sm-link">
		Blog
              </a>
	      <a href="/rss.xml" class="sm-link">
		RSS
              </a>
	    </div>

	    <div class="subscribe">
	      <!-- <a href="https://eatonphil.com/hire-me.html">Hire me</a> -->
	      <!--
		  Hardcode link to home page because some pages don't
		  have a subscribe box. Some pages hide the subscribe.
		-->
	      <a href="https://eatonphil.com/subscribe.html">
		Subscribe
	      </a>
            </div>
	  </div>
	  <hr />
	  <div class="">
            <h2>August 26, 2021</h2>
            <h1>Writing a simple JSON library from scratch: a tour through modern C++</h1>
	    
            <div class="row" style="padding-bottom: 5px">
              <div class="tags"><a href="/tags/json.html" class="tag">json</a><a href="/tags/parsing.html" class="tag">parsing</a><a href="/tags/c++.html" class="tag">c++</a></div>
            </div>
	  </div>
	</div>
      </div>
    </header>
    <div class="container">
      <div class="col-6">
	<div class="post">
          <p>Modern C++ has a lot of cool features. Move semantics means passing
around structs in functions is cheap. <code>std::shared_ptr</code>
means I don't have to manage any memory; no
more <code>new</code>/<code>delete</code>! (But try as I might to
understand <code>std::unique_ptr</code>, I'm just not there yet.)</p>
<p>The syntax has also gotten some treatment with <code>auto</code> and
tuple destructuring.</p>
<p>In order to test out this modern C++ I wanted a small but meaningful
project that operates on very dynamic data. The two that always come
to mind are JSON parsers or Lisp interpreters.</p>
<p>This post walks through
writing a basic JSON library from scratch using only the standard
library. The source code for the resulting library is available <a href="https://github.com/eatonphil/cpp-json">on
Github</a>.</p>
<p>The biggest simplification we'll make is that rather than full JSON
numbers, we'll only allow integers.</p>
<p class="note">
  Big caveat! I couldn't be farther from a C++ expert! Email or tweet
  me as you see mistakes, madness, lies.
</p><h3 id="api">API</h3><p>The two big parts of the API will be about lexing (turning a string
into an array of tokens) and parsing (turning an array of tokens into
a JSON object-tree). A better implementation would implement the lexer
as taking a character stream rather than a string, but taking a string
is simpler. So we'll stick with that.</p>
<p>Both of these functions can fail so we'll return a tuple in both cases
with a string containing a possibly blank error message.</p>
<p>We will define the header in <code>./include/json.hpp</code>.</p>
<div class="highlight"><pre><span></span><span class="cp">#ifndef JSON_H</span>
<span class="cp">#define JSON_H</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tuple&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">json</span><span class="w"> </span><span class="p">{</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">JSONToken</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lex</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">JSONValue</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">parse</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">JSONToken</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace json</span>

<span class="cp">#endif</span>
</pre></div>
<p>The token returned by <code>lex</code> will need to contain the
token's string value, the location (offset) in the original source, a
pointer to the full source (for debugging), and the token's type. The
token type itself will be an enum of either string, number, syntax
(colon, bracket, etc.), boolean, or null.</p>
<div class="highlight"><pre><span></span><span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;memory&gt;</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">json</span><span class="w"> </span><span class="p">{</span>

<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">JSONTokenType</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Number</span><span class="p">,</span><span class="w"> </span><span class="n">Syntax</span><span class="p">,</span><span class="w"> </span><span class="n">Boolean</span><span class="p">,</span><span class="w"> </span><span class="n">Null</span><span class="w"> </span><span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">JSONToken</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">  </span><span class="n">JSONTokenType</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">location</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">full_source</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// namespace json</span>

<span class="p">...</span>
</pre></div>
<p>This is the only place in the entire code we'll pass around a
pointer. Using <code>std::shared_ptr</code> means we don't have to do
any manual memory management either. No <code>new</code> or
<code>delete</code>.</p>
<p>Next, <code>JSONValue</code> is a struct containing optional string,
boolean, number, array, and object fields with a type num to
differentiate.</p>
<div class="highlight"><pre><span></span><span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;map&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;optional&gt;</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">json</span><span class="w"> </span><span class="p">{</span>

<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">JSONValueType</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Number</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="p">,</span><span class="w"> </span><span class="n">Array</span><span class="p">,</span><span class="w"> </span><span class="n">Boolean</span><span class="p">,</span><span class="w"> </span><span class="n">Null</span><span class="w"> </span><span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">JSONValue</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">string</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">number</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">boolean</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">JSONValue</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">array</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">JSONValue</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">object</span><span class="p">;</span>
<span class="w">  </span><span class="n">JSONValueType</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">JSONTokenType</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Number</span><span class="p">,</span><span class="w"> </span><span class="n">Syntax</span><span class="p">,</span><span class="w"> </span><span class="n">Boolean</span><span class="p">,</span><span class="w"> </span><span class="n">Null</span><span class="w"> </span><span class="p">};</span>

<span class="p">...</span>
</pre></div>
<p>Thanks to <code>std::optional</code> we can avoid using pointers to
describe these fields. I did take a look at <code>std::variant</code>
but it seemed like its API was overly complex.</p>
<p>Finally, we'll add two more functions: a high level <code>parse</code>
function that combines the job of lexing and parsing, and a
<code>deparse</code> function for printing a <code>JSONValue</code> as
a JSON string.</p>
<div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">JSONValue</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">parse</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">JSONToken</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">JSONValue</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">parse</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">deparse</span><span class="p">(</span><span class="n">JSONValue</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">whitespace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace json</span>
<span class="p">...</span>
</pre></div>
<p>Now we're ready to start on the implementation.</p>
<h3 id="lexing">Lexing</h3><p>First up is lexing; turning a JSON string into an array of tokens: a
number, string, null keyword, boolean keyword, or syntax like comma or
colon.</p>
<p>The main lex loop skips whitespace and calls helper functions for each
kind of token. If a token is found, we accumulate it and move to the
end of that token (some tokens like <code>:</code> are a single
character, some tokens like <code>"my great string"</code> are
multiple characters.)</p>
<p>Each token we find gets a pointer to the original JSON source for use
in error messages if parsing fails. Again this will be the only time
we explicitly pass around pointers in this implementation. We don't do
any manual management because we're going to use
<code>std::shared_ptr</code>.</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;json.hpp&quot;</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">json</span><span class="w"> </span><span class="p">{</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">JSONToken</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lex</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">raw_json</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">JSONToken</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tokens</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// All tokens will embed a pointer to the raw JSON for debugging purposes</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">original_copy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">raw_json</span><span class="p">);</span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">generic_lexers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">lex_syntax</span><span class="p">,</span><span class="w"> </span><span class="n">lex_string</span><span class="p">,</span><span class="w"> </span><span class="n">lex_number</span><span class="p">,</span><span class="w"> </span><span class="n">lex_null</span><span class="p">,</span><span class="w"> </span><span class="n">lex_true</span><span class="p">,</span><span class="w"> </span><span class="n">lex_false</span><span class="p">};</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">raw_json</span><span class="p">.</span><span class="n">length</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Skip past whitespace</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">new_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lex_whitespace</span><span class="p">(</span><span class="n">raw_json</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">new_index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="k">continue</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">lexer</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">generic_lexers</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">token</span><span class="p">,</span><span class="w"> </span><span class="n">new_index</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lexer</span><span class="p">(</span><span class="n">raw_json</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">new_index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Error while lexing, return early</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">error</span><span class="p">.</span><span class="n">length</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="p">{{},</span><span class="w"> </span><span class="n">error</span><span class="p">};</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Store reference to the original source</span>
<span class="w">        </span><span class="n">token</span><span class="p">.</span><span class="n">full_source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">original_copy</span><span class="p">;</span>
<span class="w">        </span><span class="n">tokens</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
<span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="n">found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">found</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">continue</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{{},</span><span class="w"> </span><span class="n">format_error</span><span class="p">(</span><span class="s">&quot;Unable to lex&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">raw_json</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)};</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">};</span>
<span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace json</span>
</pre></div>
<p>Two neat things you'll notice in there are tuple literal syntax
(<code>{tokens, ""}</code>) and how easy it is to type a value
containing an array of function pointers using auto
(<code>generic_lexers</code>).</p>
<h4 id="format_error">format_error</h4><p>Since we referenced <code>format_error</code>, let's define it. This
needs to accept a message prefix, the full JSON string, and the index
offset where the error should point to.</p>
<p>Inside the function we'll iterate over the string until we find the
entire line containing this index offset. We'll display that line and
a pointer to the character that is causing/starting the error.</p>
<div class="highlight"><pre><span></span><span class="p">...</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sstream&gt;</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">json</span><span class="w"> </span><span class="p">{</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">format_error</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">source</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">column</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">lastline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">whitespace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">source</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">line</span><span class="o">++</span><span class="p">;</span>
<span class="w">      </span><span class="n">column</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">      </span><span class="n">lastline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="w">      </span><span class="n">whitespace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\t&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">column</span><span class="o">++</span><span class="p">;</span>
<span class="w">      </span><span class="n">lastline</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;  &quot;</span><span class="p">;</span>
<span class="w">      </span><span class="n">whitespace</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;  &quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">column</span><span class="o">++</span><span class="p">;</span>
<span class="w">      </span><span class="n">lastline</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">      </span><span class="n">whitespace</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">counter</span><span class="o">++</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Continue accumulating the lastline for debugging</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">source</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source</span><span class="p">[</span><span class="n">counter</span><span class="p">];</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">lastline</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">    </span><span class="n">counter</span><span class="o">++</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; at line &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, column &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">column</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">lastline</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">whitespace</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;^&quot;</span><span class="p">;</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
<span class="p">}</span>

<span class="p">...</span>
</pre></div>
<p>The <code>printf</code> API is annoying and Clang 12 (latest Clang on
latest Fedora) doesn't seem to support <code>std::format</code>. So we
just use
<code>std::sstream</code> to do string "formatting".</p>
<p>But ok, back to lexing! Next up: whitespace.</p>
<h4 id="lex_whitespace">lex_whitespace</h4><p>This function's job is to skip past whitespace. Thankfully we've got
<code>std::isspace</code> to help.</p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">lex_whitespace</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">raw_json</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">isspace</span><span class="p">(</span><span class="n">raw_json</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">raw_json</span><span class="p">.</span><span class="n">length</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>It's very simple!</p>
<h4 id="lex_syntax">lex_syntax</h4><p>All of the generic lexers follow the same pattern. They return either
a valid token and the index where the token ends, or they return an
error string.</p>
<p>Since all the syntax elements in JSON (<code>,</code>, <code>:</code>,
<code>{</code>, <code>}</code>, <code>[</code> and , <code>]</code>)
are single characters, we don't need to write a "longest substring"
helper function. We simply check if the current character is one of
these characters and return a syntax token if so.</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">JSONToken</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lex_syntax</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">raw_json</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">JSONToken</span><span class="w"> </span><span class="n">token</span><span class="p">{</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">JSONTokenType</span><span class="o">::</span><span class="n">Syntax</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">};</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">raw_json</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;[&#39;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;]&#39;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;{&#39;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;}&#39;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;:&#39;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;,&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">token</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">    </span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">token</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
<h3 id="lex_string">lex_string</h3><p>This one manages state so it's a little more complex. We need to check
if the current character is a double quote, then iterate over
characters until we find the ending quote.</p>
<p>It's possible to hit EOF here so we need to handle that case. And
handling nested quotes is left as an exercise for the reader. :)</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">JSONToken</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lex_string</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">raw_json</span><span class="p">,</span>
<span class="w">                                                   </span><span class="kt">int</span><span class="w"> </span><span class="n">original_index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">original_index</span><span class="p">;</span>
<span class="w">  </span><span class="n">JSONToken</span><span class="w"> </span><span class="n">token</span><span class="p">{</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">JSONTokenType</span><span class="o">::</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">};</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">raw_json</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;&quot;&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">token</span><span class="p">,</span><span class="w"> </span><span class="n">original_index</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">};</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// TODO: handle nested quotes</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">raw_json</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;&quot;&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">raw_json</span><span class="p">.</span><span class="n">length</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">token</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">format_error</span><span class="p">(</span><span class="s">&quot;Unexpected EOF while lexing string&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">raw_json</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">)};</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">token</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">    </span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">token</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
<p>Nothing too special to discuss here. So on to lexing numbers.</p>
<h3 id="lex_number">lex_number</h3><p>Since we're only supporting integers, this one has no internal
state. We check characters until we stop seeing digits.</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">JSONToken</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lex_number</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">raw_json</span><span class="p">,</span>
<span class="w">                                                   </span><span class="kt">int</span><span class="w"> </span><span class="n">original_index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">original_index</span><span class="p">;</span>
<span class="w">  </span><span class="n">JSONToken</span><span class="w"> </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">JSONTokenType</span><span class="o">::</span><span class="n">Number</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">};</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// TODO: handle not just integers</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">raw_json</span><span class="p">.</span><span class="n">length</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">raw_json</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="sc">&#39;0&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="sc">&#39;9&#39;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">token</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">    </span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">token</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
<p>Done. On to keywords: <code>null</code>, <code>false</code>, <code>true</code>.</p>
<h3 id="lex_keyword">lex_keyword</h3><p>This is a helper function that will check for a literal keyword.</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">JSONToken</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lex_keyword</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">raw_json</span><span class="p">,</span>
<span class="w">                                                    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">keyword</span><span class="p">,</span>
<span class="w">                                                    </span><span class="n">JSONTokenType</span><span class="w"> </span><span class="n">type</span><span class="p">,</span>
<span class="w">                                                    </span><span class="kt">int</span><span class="w"> </span><span class="n">original_index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">original_index</span><span class="p">;</span>
<span class="w">  </span><span class="n">JSONToken</span><span class="w"> </span><span class="n">token</span><span class="p">{</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">};</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">keyword</span><span class="p">[</span><span class="n">index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">original_index</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">raw_json</span><span class="p">[</span><span class="n">index</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">raw_json</span><span class="p">.</span><span class="n">length</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">original_index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">keyword</span><span class="p">.</span><span class="n">length</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">token</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">keyword</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">token</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
<p>With this defined we can now implement <code>lex_false</code>,
<code>lex_true</code>, and <code>lex_null</code>.</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">JSONToken</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lex_null</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">raw_json</span><span class="p">,</span>
<span class="w">                                                 </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">lex_keyword</span><span class="p">(</span><span class="n">raw_json</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;null&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">JSONTokenType</span><span class="o">::</span><span class="n">Null</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">JSONToken</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lex_true</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">raw_json</span><span class="p">,</span>
<span class="w">                                                 </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">lex_keyword</span><span class="p">(</span><span class="n">raw_json</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;true&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">JSONTokenType</span><span class="o">::</span><span class="n">Boolean</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">JSONToken</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lex_false</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">raw_json</span><span class="p">,</span>
<span class="w">                                                  </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">lex_keyword</span><span class="p">(</span><span class="n">raw_json</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;false&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">JSONTokenType</span><span class="o">::</span><span class="n">Boolean</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>And that's it for lexing! And although we defined all of these
top-down, you'll want to write them mostly in reverse order or put in
forward declarations.</p>
<p>If you wanted to you could now write a simple <code>main.cpp</code>
like:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;json.hpp&quot;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Expected JSON input argument to parse&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">in</span><span class="p">{</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]};</span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">json</span><span class="o">::</span><span class="n">lex</span><span class="p">(</span><span class="n">in</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">error</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tokens</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Set up a Makefile:</p>
<div class="highlight"><pre><span></span><span class="nf">main</span><span class="o">:</span><span class="w"> </span>*.<span class="n">cpp</span> ./<span class="n">include</span>/*.<span class="n">hpp</span>
<span class="w">        </span>clang++<span class="w"> </span>-g<span class="w"> </span>-Wall<span class="w"> </span>-std<span class="o">=</span>c++2a<span class="w"> </span>-I./include<span class="w"> </span>*.cpp<span class="w"> </span>-o<span class="w"> </span><span class="nv">$@</span>
</pre></div>
<p>Build with <code>make</code> and run <code>./main '{"a": 1}'</code>
to see the list of tokens printed out.</p>
<p>Now let's move on to parsing from the array of tokens.</p>
<h3 id="parsing">Parsing</h3><p>This process takes the array of tokens and turns them into a tree
structure. The tree develops children as we spot <code>[</code> or
<code>{</code> tokens. The tree child ends when we spot <code>]</code>
or <code>}</code> tokens.</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">JSONValue</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">parse</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">JSONToken</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tokens</span><span class="p">,</span>
<span class="w">                                              </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokens</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">token</span><span class="p">.</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">JSONTokenType</span><span class="o">::</span><span class="no">Number</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">stod</span><span class="p">(</span><span class="n">token</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">JSONValue</span><span class="p">{.</span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JSONValueType</span><span class="o">::</span><span class="n">Number</span><span class="p">},</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">};</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">JSONTokenType</span><span class="o">::</span><span class="no">Boolean</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">JSONValue</span><span class="p">{.</span><span class="n">boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">token</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;true&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JSONValueType</span><span class="o">::</span><span class="n">Boolean</span><span class="p">},</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">};</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">JSONTokenType</span><span class="o">::</span><span class="no">Null</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">JSONValue</span><span class="p">{.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JSONValueType</span><span class="o">::</span><span class="n">Null</span><span class="p">},</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">};</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">JSONTokenType</span><span class="o">::</span><span class="no">String</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">JSONValue</span><span class="p">{.</span><span class="n">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">token</span><span class="p">.</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JSONValueType</span><span class="o">::</span><span class="n">String</span><span class="p">},</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">};</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">JSONTokenType</span><span class="o">::</span><span class="no">Syntax</span><span class="p">:</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">token</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;[&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="n">new_index</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse_array</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">JSONValue</span><span class="p">{.</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JSONValueType</span><span class="o">::</span><span class="n">Array</span><span class="p">},</span><span class="w"> </span><span class="n">new_index</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">};</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">token</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;{&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="n">new_index</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse_object</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">JSONValue</span><span class="p">{.</span><span class="n">object</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="p">(</span><span class="n">object</span><span class="p">),</span><span class="w"> </span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JSONValueType</span><span class="o">::</span><span class="n">Object</span><span class="p">},</span><span class="w"> </span><span class="n">new_index</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">};</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{{},</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">format_parse_error</span><span class="p">(</span><span class="s">&quot;Failed to parse&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">token</span><span class="p">)};</span>
<span class="p">}</span>
</pre></div>
<p>This in turn reference <code>format_parse_error</code> on failure
which is an error-string-maker similar to
<code>format_error</code>. It actually calls <code>format_error</code>
with more details specific to parsing.</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">JSONTokenType_to_string</span><span class="p">(</span><span class="n">JSONTokenType</span><span class="w"> </span><span class="n">jtt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">jtt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">JSONTokenType</span><span class="o">::</span><span class="no">String</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;String&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">JSONTokenType</span><span class="o">::</span><span class="no">Number</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Number&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">JSONTokenType</span><span class="o">::</span><span class="no">Syntax</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Syntax&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">JSONTokenType</span><span class="o">::</span><span class="no">Boolean</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Boolean&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">JSONTokenType</span><span class="o">::</span><span class="no">Null</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Null&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">format_parse_error</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">JSONToken</span><span class="w"> </span><span class="n">token</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">  </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Unexpected token &#39;&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">token</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;&#39;, type &#39;&quot;</span>
<span class="w">    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">JSONTokenType_to_string</span><span class="p">(</span><span class="n">token</span><span class="p">.</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;&#39;, index &quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">base</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">format_error</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">str</span><span class="p">(),</span><span class="w"> </span><span class="o">*</span><span class="n">token</span><span class="p">.</span><span class="n">full_source</span><span class="p">,</span><span class="w"> </span><span class="n">token</span><span class="p">.</span><span class="n">location</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p class="note">
  This function depended on a helper for turning the
  <code>JSONTokenType</code> enum into a string. As a user it's very
  annoying when langauges doesn't give you stringifier methods for enums
  by default for debugging. I know there's some ways to do this with
  reflection in C++ but it seemed hairy.

  But I digest.
</p><h4 id="parse_array">parse_array</h4><p>This function was called by <code>parse</code> when we found an
opening bracket. This function needs to recursively call parse and
then check for a comma and call parse again ... until it finds the
closing bracket.</p>
<p>It will fail if it every finds something other than a comma or closing
bracket following a succesful call to <code>parse</code>.</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">JSONValue</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span>
<span class="n">parse_array</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">JSONToken</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">JSONValue</span><span class="o">&gt;</span><span class="w"> </span><span class="n">children</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">tokens</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokens</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">JSONTokenType</span><span class="o">::</span><span class="n">Syntax</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;]&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">children</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">};</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokens</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">children</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">{{},</span>
<span class="w">                </span><span class="n">index</span><span class="p">,</span>
<span class="w">                </span><span class="n">format_parse_error</span><span class="p">(</span><span class="s">&quot;Expected comma after element in array&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">)};</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">child</span><span class="p">,</span><span class="w"> </span><span class="n">new_index</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">error</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">{{},</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">};</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">children</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
<span class="w">    </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_index</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="p">{},</span>
<span class="w">      </span><span class="n">index</span><span class="p">,</span>
<span class="w">      </span><span class="n">format_parse_error</span><span class="p">(</span><span class="s">&quot;Unexpected EOF while parsing array&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">tokens</span><span class="p">[</span><span class="n">index</span><span class="p">])};</span>
<span class="p">}</span>
</pre></div>
<p>And finally we need to implement <code>parse_object</code>.</p>
<h4 id="parse_object">parse_object</h4><p>This function is similar to <code>parse_array</code> but it needs to
find <code>$string COLON $parse() COMMA</code> pattern pairs.</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">JSONValue</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span>
<span class="n">parse_object</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">JSONToken</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">JSONValue</span><span class="o">&gt;</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">tokens</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokens</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">JSONTokenType</span><span class="o">::</span><span class="n">Syntax</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;}&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">};</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokens</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="p">{},</span>
<span class="w">            </span><span class="n">index</span><span class="p">,</span>
<span class="w">            </span><span class="n">format_parse_error</span><span class="p">(</span><span class="s">&quot;Expected comma after element in object&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">)};</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">{{},</span>
<span class="w">                </span><span class="n">index</span><span class="p">,</span>
<span class="w">                </span><span class="n">format_parse_error</span><span class="p">(</span>
<span class="w">                    </span><span class="s">&quot;Expected key-value pair or closing brace in object&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">)};</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">new_index</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">error</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">{{},</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">};</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">JSONValueType</span><span class="o">::</span><span class="n">String</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="p">{},</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">format_parse_error</span><span class="p">(</span><span class="s">&quot;Expected string key in object&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">)};</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_index</span><span class="p">;</span>
<span class="w">    </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokens</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">JSONTokenType</span><span class="o">::</span><span class="n">Syntax</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;:&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">{{},</span>
<span class="w">              </span><span class="n">index</span><span class="p">,</span>
<span class="w">              </span><span class="n">format_parse_error</span><span class="p">(</span><span class="s">&quot;Expected colon after key in object&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">)};</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokens</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">new_index1</span><span class="p">,</span><span class="w"> </span><span class="n">error1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">error1</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">{{},</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">error1</span><span class="p">};</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">values</span><span class="p">[</span><span class="n">key</span><span class="p">.</span><span class="n">string</span><span class="p">.</span><span class="n">value</span><span class="p">()]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_index1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
<p>These parse functions are all slightly tedious but still very
simple. And thankfully, we're done!</p>
<p>We can now implement the variation of <code>parse</code> that ties
together lexing and parsing.</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">JSONValue</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">parse</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">source</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">tokens</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">json</span><span class="o">::</span><span class="n">lex</span><span class="p">(</span><span class="n">source</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">error</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{{},</span><span class="w"> </span><span class="n">error</span><span class="p">};</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">ast</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">error1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">json</span><span class="o">::</span><span class="n">parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">ast</span><span class="p">,</span><span class="w"> </span><span class="n">error1</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
<p>And we're completely done the string to <code>JSONValue</code> code.</p>
<h3 id="deparse">deparse</h3><p>The very last piece of the implementation is to do the reverse of the
past operations: generate a string from a <code>JSONValue</code>.</p>
<p>This is a recursive function and the only mildly tricky part is
deciding how to do whitespace if we want a prettier output.</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">deparse</span><span class="p">(</span><span class="n">JSONValue</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">whitespace</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">JSONValueType</span><span class="o">::</span><span class="no">String</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">string</span><span class="p">.</span><span class="n">value</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">JSONValueType</span><span class="o">::</span><span class="no">Boolean</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">boolean</span><span class="p">.</span><span class="n">value</span><span class="p">()</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;false&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">JSONValueType</span><span class="o">::</span><span class="no">Number</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">number</span><span class="p">.</span><span class="n">value</span><span class="p">());</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">JSONValueType</span><span class="o">::</span><span class="no">Null</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;null&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">JSONValueType</span><span class="o">::</span><span class="no">Array</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;[</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">array</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">      </span><span class="n">s</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">whitespace</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;  &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">deparse</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">whitespace</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;  &quot;</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">s</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="n">s</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">whitespace</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;]&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">JSONValueType</span><span class="o">::</span><span class="no">Object</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;{</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">object</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">values</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">s</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">whitespace</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;  &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">+</span>
<span class="w">           </span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">deparse</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">whitespace</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;  &quot;</span><span class="p">);</span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">s</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="n">s</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">      </span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">whitespace</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;}&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Done. Done. Done.</p>
<h3 id="main.cpp">main.cpp</h3><p>This program will simply accept a JSON input, parse it, and pretty
print it right back out. Kind of like a simplified <code>jq</code>.</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;json.hpp&quot;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Expected JSON input argument to parse&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">in</span><span class="p">{</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]};</span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">ast</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">json</span><span class="o">::</span><span class="n">parse</span><span class="p">(</span><span class="n">in</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">error</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">json</span><span class="o">::</span><span class="n">deparse</span><span class="p">(</span><span class="n">ast</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>Build it with <code>make</code> that we already defined, and run it against
something big like
<a href="https://github.com/eatonphil/cpp-json/blob/main/test/glossary.json">this</a>.</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>cpp-json
$<span class="w"> </span>make
$<span class="w"> </span>./main<span class="w"> </span><span class="s2">&quot;</span><span class="k">$(</span>cat<span class="w"> </span>./test/glossary.json<span class="k">)</span><span class="s2">&quot;</span>
<span class="o">{</span>
<span class="w">  </span><span class="s2">&quot;glossary&quot;</span>:<span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="s2">&quot;GlossDiv&quot;</span>:<span class="w"> </span><span class="o">{</span>
<span class="w">      </span><span class="s2">&quot;GlossList&quot;</span>:<span class="w"> </span><span class="o">{</span>
<span class="w">        </span><span class="s2">&quot;GlossEntry&quot;</span>:<span class="w"> </span><span class="o">{</span>
<span class="w">          </span><span class="s2">&quot;Abbrev&quot;</span>:<span class="w"> </span><span class="s2">&quot;ISO 8879:1986&quot;</span>,
<span class="w">          </span><span class="s2">&quot;Acronym&quot;</span>:<span class="w"> </span><span class="s2">&quot;SGML&quot;</span>,
<span class="w">          </span><span class="s2">&quot;GlossDef&quot;</span>:<span class="w"> </span><span class="o">{</span>
<span class="w">            </span><span class="s2">&quot;GlossSeeAlso&quot;</span>:<span class="w"> </span><span class="o">[</span>
<span class="w">              </span><span class="s2">&quot;GML&quot;</span>,
<span class="w">              </span><span class="s2">&quot;XML&quot;</span>
<span class="w">            </span><span class="o">]</span>,
<span class="w">            </span><span class="s2">&quot;para&quot;</span>:<span class="w"> </span><span class="s2">&quot;A meta-markup language, used to create markup languages such as DocBook.&quot;</span>
<span class="w">          </span><span class="o">}</span>,
<span class="w">          </span><span class="s2">&quot;GlossSee&quot;</span>:<span class="w"> </span><span class="s2">&quot;markup&quot;</span>,
<span class="w">          </span><span class="s2">&quot;GlossTerm&quot;</span>:<span class="w"> </span><span class="s2">&quot;Standard Generalized Markup Language&quot;</span>,
<span class="w">          </span><span class="s2">&quot;ID&quot;</span>:<span class="w"> </span><span class="s2">&quot;SGML&quot;</span>,
<span class="w">          </span><span class="s2">&quot;SortAs&quot;</span>:<span class="w"> </span><span class="s2">&quot;SGML&quot;</span>
<span class="w">        </span><span class="o">}</span>
<span class="w">      </span><span class="o">}</span>,
<span class="w">      </span><span class="s2">&quot;title&quot;</span>:<span class="w"> </span><span class="s2">&quot;S&quot;</span>
<span class="w">    </span><span class="o">}</span>,
<span class="w">    </span><span class="s2">&quot;title&quot;</span>:<span class="w"> </span><span class="s2">&quot;example glossary&quot;</span>
<span class="w">  </span><span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>Or something incorrect like:</p>
<div class="highlight"><pre><span></span>./main<span class="w"> </span><span class="s1">&#39;{&quot;foo&quot;: [{ 1: 2 }]}&#39;</span>
Unexpected<span class="w"> </span>token<span class="w"> </span><span class="s1">&#39;1&#39;</span>,<span class="w"> </span><span class="nb">type</span><span class="w"> </span><span class="s1">&#39;Number&#39;</span>,<span class="w"> </span>index
Expected<span class="w"> </span>string<span class="w"> </span>key<span class="w"> </span><span class="k">in</span><span class="w"> </span>object<span class="w"> </span>at<span class="w"> </span>line<span class="w"> </span><span class="m">1</span>,<span class="w"> </span>column<span class="w"> </span><span class="m">11</span>
<span class="o">{</span><span class="s2">&quot;foo&quot;</span>:<span class="w"> </span><span class="o">[{</span><span class="w"> </span><span class="m">1</span>:<span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="o">}]}</span>
<span class="w">           </span>^
</pre></div>
<p>And give Valgrind the old try:</p>
<div class="highlight"><pre><span></span>valgrind<span class="w"> </span>./main<span class="w"> </span><span class="s1">&#39;{&quot;a&quot;: [1, 2, null, { &quot;c&quot;: 129 }]}&#39;</span>
<span class="o">==</span><span class="nv">153027</span><span class="o">==</span><span class="w"> </span>Memcheck,<span class="w"> </span>a<span class="w"> </span>memory<span class="w"> </span>error<span class="w"> </span><span class="nv">detector</span>
<span class="o">==</span><span class="nv">153027</span><span class="o">==</span><span class="w"> </span>Copyright<span class="w"> </span><span class="o">(</span>C<span class="o">)</span><span class="w"> </span><span class="m">2002</span>-2017,<span class="w"> </span>and<span class="w"> </span>GNU<span class="w"> </span>GPL<span class="err">&#39;</span>d,<span class="w"> </span>by<span class="w"> </span>Julian<span class="w"> </span>Seward<span class="w"> </span>et<span class="w"> </span>al.
<span class="o">==</span><span class="nv">153027</span><span class="o">==</span><span class="w"> </span>Using<span class="w"> </span>Valgrind-3.17.0<span class="w"> </span>and<span class="w"> </span>LibVEX<span class="p">;</span><span class="w"> </span>rerun<span class="w"> </span>with<span class="w"> </span>-h<span class="w"> </span><span class="k">for</span><span class="w"> </span>copyright<span class="w"> </span><span class="nv">info</span>
<span class="o">==</span><span class="nv">153027</span><span class="o">==</span><span class="w"> </span>Command:<span class="w"> </span>./main<span class="w"> </span><span class="o">{</span><span class="s2">&quot;a&quot;</span>:<span class="se">\ </span><span class="o">[</span><span class="m">1</span>,<span class="se">\ </span><span class="m">2</span>,<span class="se">\ </span>null,<span class="se">\ </span><span class="o">{</span><span class="se">\ </span><span class="s2">&quot;c&quot;</span>:<span class="se">\ </span><span class="m">129</span><span class="se">\ </span><span class="o">}]}</span>
<span class="o">==</span><span class="nv">153027</span><span class="o">==</span>
<span class="o">{</span>
<span class="w">  </span><span class="s2">&quot;a&quot;</span>:<span class="w"> </span><span class="o">[</span>
<span class="w">    </span><span class="m">1</span>.000000,
<span class="w">    </span><span class="m">2</span>.000000,
<span class="w">    </span>null,
<span class="w">    </span><span class="o">{</span>
<span class="w">      </span><span class="s2">&quot;c&quot;</span>:<span class="w"> </span><span class="m">129</span>.000000
<span class="w">    </span><span class="o">}</span>
<span class="w">  </span><span class="o">]</span>
<span class="o">}==</span><span class="nv">153027</span><span class="o">==</span>
<span class="o">==</span><span class="nv">153027</span><span class="o">==</span><span class="w"> </span>HEAP<span class="w"> </span>SUMMARY:
<span class="o">==</span><span class="nv">153027</span><span class="o">==</span><span class="w">     </span><span class="k">in</span><span class="w"> </span>use<span class="w"> </span>at<span class="w"> </span>exit:<span class="w"> </span><span class="m">0</span><span class="w"> </span>bytes<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="nv">blocks</span>
<span class="o">==</span><span class="nv">153027</span><span class="o">==</span><span class="w">   </span>total<span class="w"> </span>heap<span class="w"> </span>usage:<span class="w"> </span><span class="m">128</span><span class="w"> </span>allocs,<span class="w"> </span><span class="m">128</span><span class="w"> </span>frees,<span class="w"> </span><span class="m">105</span>,386<span class="w"> </span>bytes<span class="w"> </span><span class="nv">allocated</span>
<span class="o">==</span><span class="nv">153027</span><span class="o">==</span>
<span class="o">==</span><span class="nv">153027</span><span class="o">==</span><span class="w"> </span>All<span class="w"> </span>heap<span class="w"> </span>blocks<span class="w"> </span>were<span class="w"> </span>freed<span class="w"> </span>--<span class="w"> </span>no<span class="w"> </span>leaks<span class="w"> </span>are<span class="w"> </span><span class="nv">possible</span>
<span class="o">==</span><span class="nv">153027</span><span class="o">==</span>
<span class="o">==</span><span class="nv">153027</span><span class="o">==</span><span class="w"> </span>For<span class="w"> </span>lists<span class="w"> </span>of<span class="w"> </span>detected<span class="w"> </span>and<span class="w"> </span>suppressed<span class="w"> </span>errors,<span class="w"> </span>rerun<span class="w"> </span>with:<span class="w"> </span>-s
<span class="o">==</span><span class="nv">153027</span><span class="o">==</span><span class="w"> </span>ERROR<span class="w"> </span>SUMMARY:<span class="w"> </span><span class="m">0</span><span class="w"> </span>errors<span class="w"> </span>from<span class="w"> </span><span class="m">0</span><span class="w"> </span>contexts<span class="w"> </span><span class="o">(</span>suppressed:<span class="w"> </span><span class="m">0</span><span class="w"> </span>from<span class="w"> </span><span class="m">0</span><span class="o">)</span>
</pre></div>
<p>Pretty sweet. Modern C++, I like it!</p>
<p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">I don&#39;t do a lot of C++ so I wanted to get a sense for what it can look like today.<br><br>This post walks through a number of new-ish C++ features as we build a handwritten recursive descent parser for JSON using only the standard library.<a href="https://t.co/cCN6nP0pDi">https://t.co/cCN6nP0pDi</a> <a href="https://t.co/0AZNEZv4Ss">pic.twitter.com/0AZNEZv4Ss</a></p>&mdash; Phil Eaton (@phil_eaton) <a href="https://twitter.com/phil_eaton/status/1431000902710796292?ref_src=twsrc%5Etfw">August 26, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>
<style>.feedback{display:initial;}</style>
	</div>
	<div class="feedback">
	  <h4>Feedback</h4>
	  <p>As always,
	      please <a href="mailto:phil@eatonphil.com">email</a>
	      or <a href="https://twitter.com/eatonphil">tweet me</a>
	      with questions, corrections, or ideas!</p>

	</div>
      </div>
    </div>
    <footer>
      <div class="container">
	<div>
	  <div id="subscribe">
	    <iframe frameBorder="0" src="https://cdn.forms-content-1.sg-form.com/e8ed4c3b-dd46-11f0-b6e6-ce075f2c5f80"/>

	  </div>
	</div>
      </div>
    </footer>
    <script async onload="loadGA()" src="https://www.googletagmanager.com/gtag/js?id=UA-58109156-2"></script>
    <script>
      function loadGA() {
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());
	  gtag('config', 'UA-58109156-2');
      }
    </script>
    <script defer src="https://cdn.usefathom.com/script.js" data-site="CEPUOLOQ"></script>
  </body>
</html>
