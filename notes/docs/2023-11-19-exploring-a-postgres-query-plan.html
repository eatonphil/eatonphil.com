<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="canonical" href="https://notes.eatonphil.com/2023-11-19-exploring-a-postgres-query-plan.html">
    <title>Exploring a Postgres query plan | notes.eatonphil.com</title>
    <meta name="description" content="Exploring a Postgres query plan" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono">

    <script async onload="loadGA()" src="https://www.googletagmanager.com/gtag/js?id=UA-58109156-2"></script>
    <script>
      function loadGA() {
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());
	  gtag('config', 'UA-58109156-2');
      }
    </script>
    <script defer src="https://cdn.usefathom.com/script.js" data-site="CEPUOLOQ"></script>
  </head>
  <body>
    <header>
      <div class="lfw">
	<div class="container">
	  <div class="row">
	    <a href="https://eatonphil.com/2025-holiday-fundraiser.html">2025 Holiday Fundraiser</a>
	  </div>
	</div>
      </div>
      <div class="container">
        <div>
          <div class="row">
	    <div>
	      <a href="https://eatonphil.com" class="sm-link">
		Home
              </a>
	      <a href="/" class="sm-link">
		Blog
              </a>
	      <a href="/rss.xml" class="sm-link">
		RSS
              </a>
	    </div>

	    <div class="subscribe">
	      <!-- <a href="https://eatonphil.com/hire-me.html">Hire me</a> -->
	      <!--
		  Hardcode link to home page because some pages don't
		  have a subscribe box. Some pages hide the subscribe.
		-->
	      <a href="https://eatonphil.com/subscribe.html">
		Subscribe
	      </a>
            </div>
	  </div>
	  <hr />
	  <div class="">
            <h2>November 19, 2023</h2>
            <h1>Exploring a Postgres query plan</h1>
	    
            <div class="row" style="padding-bottom: 5px">
              <div class="tags"><a href="/tags/c.html" class="tag">c</a><a href="/tags/postgres.html" class="tag">postgres</a><a href="/tags/databases.html" class="tag">databases</a></div>
            </div>
	  </div>
	</div>
      </div>
    </header>
    <div class="container">
      <div class="col-6">
	<div class="post">
          <p><!-- -*- mode: markdown -*- --></p>
<p>I learned this week that you can intercept and redirect Postgres query
execution. You can hook into the execution layer so you're given a
query plan and you get to decide what to do with it. What rows to
return, if any, and where they come from.</p>
<p>That's very interesting. So I started writing code to explore execution
hooks. However, I got stuck interpreting the query plan. Either
there's no query plan walking infrastructure or I just didn't find it.</p>
<p>So this post is a digression into walking a Postgres query plan. By
the end we'll be able to run <code>psql -c 'SELECT a FROM x WHERE a &gt; 1'</code>
and reconstruct the entire SQL string from a Postgres
<a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/include/executor/execdesc.h#L33"><code>QueryDesc</code></a>
object, the query plan object Postgres builds.</p>
<p>With that query plan walking infrastructure in place, we'll be in a
good state to not just print out the query plan while walking it but
instead to translate the query plan or evaluate it in our own way
(e.g. over column-wise data, or <a href="https://github.com/citusdata/postgres_vectorization_test">vectorized execution over row-wise
data</a>).</p>
<p>Code for this project is <a href="https://github.com/eatonphil/pgexec">available on
Github</a>.</p>
<h3 id="what-is-a-query-plan?">What is a query plan?</h3><p>If you're familiar with parsers and compilers, a query plan is like an
intermediate representation (IR) of a program. It is not as raw as an
abstract syntax tree (AST); it has already been optimized.</p>
<p>If that doesn't mean anything to you, think of a query plan as a
structured and optimized version of the SQL query you submit to your
database. It isn't text anymore. It is <a href="https://buttondown.email/jaffray/archive/why-are-query-plans-trees/">probably a
tree</a>.</p>
<p>Check out another Justin Jaffray <a href="https://justinjaffray.com/what-is-a-query-optimizer-for/">article on the
subject</a> for
more detail.</p>
<h3 id="development-environment">Development environment</h3><p>Before we get to walking the query plan, let's set up the
infrastructure to intercept query execution where we can eventually
add in our print debugging of the query plan reconstructed as a SQL
string.</p>
<p>Once you've got <a href="https://wiki.postgresql.org/wiki/Compile_and_Install_from_source_code">Postgres build
dependencies</a>,
build and install a debug version of Postgres:</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/postgres/postgres<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">cd</span><span class="w"> </span>postgres
$<span class="w"> </span><span class="c1"># Make sure you&#39;re on the same commit I&#39;m on, just to be safe.</span>
$<span class="w"> </span>git<span class="w"> </span>checkout<span class="w"> </span>b218fbb7a35fcf31539bfad12732038fe082a2eb
$<span class="w"> </span>./configure<span class="w"> </span>--enable-cassert<span class="w"> </span>--enable-debug<span class="w"> </span><span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">&quot;-ggdb -Og -g3 -fno-omit-frame-pointer&quot;</span>
$<span class="w"> </span>make<span class="w"> </span>-j8
$<span class="w"> </span><span class="c1"># Installs to to /usr/local/pgsql/bin.</span>
$<span class="w"> </span>sudo<span class="w"> </span>make<span class="w"> </span>install
</pre></div>
<p>I'm not going to cover Postgres extension infrastructure in detail. I
wrote a bit about it in <a href="https://notes.eatonphil.com/2023-11-01-postgres-table-access-methods.html">my last
post</a>.
You need only read the first half, if at all; not the actual Table
Access Method implementation.</p>
<p>It will be even simpler in this post because Postgres hooks are
extensions but not extensions you install with <code>CREATE EXTENSION</code>. If
you want to read about the different kinds of Postgres extensions,
check out <a href="https://tembo.io/blog/four-types-of-extensions/">this
article</a> by Steven
Miller.</p>
<p>The minimum we need, aside from the hook code itself, is a Makefile
that uses
<a href="https://www.postgresql.org/docs/current/extend-pgxs.html">PGXS</a>:</p>
<div class="highlight"><pre><span></span><span class="nv">MODULES</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>pgexec

<span class="nv">PG_CONFIG</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>/usr/local/pgsql/bin/pg_config
<span class="nv">PGXS</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">$(</span>shell<span class="w"> </span><span class="k">$(</span>PG_CONFIG<span class="k">)</span><span class="w"> </span>--pgxs<span class="k">)</span>
<span class="cp">include $(PGXS)</span>
</pre></div>
<p>The <code>MODULES</code> value there corresponds to the C file we'll create
shortly, <code>pgexec.c</code>.</p>
<p class="note">
  This <code>pg_config</code> binary path is important because you
  might have different versions of Postgres installed, for example by
  your package manager. It is important that the extension is built
  against the same version of Postgres which will load the extension.
</p><p>Now we're ready for some hook code.</p>
<h3 id="intercepting-query-execution">Intercepting query execution</h3><p>You can find the basic structure of a hook (and which hooks are
available) in Tamika Nomara's <a href="https://github.com/taminomara/psql-hooks">unofficial Postgres hooks
docs</a>.</p>
<p class="note">
  There is no official central place describing all hooks I could find
  in Postgres docs. Some hooks are described in various places
  throughout the docs though.
</p><p>Based on that page, we can write a bare minimum hook that will
intercept queries, log when we've done so, and pass control back
to the standard execution path for the actual query. In <code>pgexec.c</code>:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;postgres.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;fmgr.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;executor/executor.h&quot;</span>

<span class="n">PG_MODULE_MAGIC</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="n">ExecutorRun_hook_type</span><span class="w"> </span><span class="n">prev_executor_run_hook</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">print_plan</span><span class="p">(</span><span class="n">QueryDesc</span><span class="o">*</span><span class="w"> </span><span class="n">queryDesc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">elog</span><span class="p">(</span><span class="n">LOG</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[pgexec] HOOKED SUCCESSFULLY!&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">pgexec_run_hook</span><span class="p">(</span>
<span class="w">  </span><span class="n">QueryDesc</span><span class="o">*</span><span class="w"> </span><span class="n">queryDesc</span><span class="p">,</span>
<span class="w">  </span><span class="n">ScanDirection</span><span class="w"> </span><span class="n">direction</span><span class="p">,</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">count</span><span class="p">,</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">execute_once</span>
<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">print_plan</span><span class="p">(</span><span class="n">queryDesc</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">prev_executor_run_hook</span><span class="p">(</span><span class="n">queryDesc</span><span class="p">,</span><span class="w"> </span><span class="n">direction</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">execute_once</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">_PG_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">prev_executor_run_hook</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExecutorRun_hook</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prev_executor_run_hook</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">prev_executor_run_hook</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">standard_ExecutorRun</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">ExecutorRun_hook</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pgexec_run_hook</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">_PG_fini</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ExecutorRun_hook</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev_executor_run_hook</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>You can discover the <code>standard_ExectutorRun</code> function from a quick
<code>git grep ExecutorRun_hook</code> in the Postgres source which leads to
<a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/backend/executor/execMain.c#L306">src/backend/executor/execMain.c#L306</a>:</p>
<div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">ExecutorRun</span><span class="p">(</span><span class="n">QueryDesc</span><span class="w"> </span><span class="o">*</span><span class="n">queryDesc</span><span class="p">,</span>
<span class="w">            </span><span class="n">ScanDirection</span><span class="w"> </span><span class="n">direction</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">count</span><span class="p">,</span>
<span class="w">            </span><span class="kt">bool</span><span class="w"> </span><span class="n">execute_once</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ExecutorRun_hook</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="o">*</span><span class="n">ExecutorRun_hook</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">queryDesc</span><span class="p">,</span><span class="w"> </span><span class="n">direction</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">execute_once</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="n">standard_ExecutorRun</span><span class="p">(</span><span class="n">queryDesc</span><span class="p">,</span><span class="w"> </span><span class="n">direction</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">execute_once</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>So our hook will just log and pass back execution to the existing
execution hook. Let's build and install the extension.</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>make
<span class="gp">$ </span>sudo<span class="w"> </span>make<span class="w"> </span>install
</pre></div>
<p>Now we'll create a new database and tell it to load the extension.</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>/usr/local/pgsql/bin/initdb<span class="w"> </span>test-db
<span class="gp">$ </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;shared_preload_libraries = &#39;pgexec&#39;&quot;</span><span class="w"> </span>&gt;<span class="w"> </span>test-db/postgresql.conf
</pre></div>
<p class="note">
  Remember, hooks are not <code>CREATE EXTENSION</code> extensions. As
  far as I can tell they can't be dynamically loaded (without some
  additional dynamic loading infrastructure one could potentially
  write). So every time you make a change you need to rebuild the
  extension, reinstall it, and restart the Postgres server.
</p><p>And start the server in the foreground:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>/usr/local/pgsql/bin/postgres<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--config-file<span class="o">=</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/test-db/postgresql.conf<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>-D<span class="w"> </span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/test-db
<span class="go">  -k $(pwd)/test-db</span>
<span class="go">2023-11-18 19:35:16.680 GMT [3215547] LOG:  starting PostgreSQL 17devel on x86_64-pc-linux-gnu, compiled by gcc (GCC) 13.2.1 20230728 (Red Hat 13.2.1-1), 64-bit</span>
<span class="go">2023-11-18 19:35:16.681 GMT [3215547] LOG:  listening on IPv6 address &quot;::1&quot;, port 5432</span>
<span class="go">2023-11-18 19:35:16.681 GMT [3215547] LOG:  listening on IPv4 address &quot;127.0.0.1&quot;, port 5432</span>
<span class="go">2023-11-18 19:35:16.681 GMT [3215547] LOG:  listening on Unix socket &quot;/tmp/.s.PGSQL.5432&quot;</span>
<span class="go">2023-11-18 19:35:16.682 GMT [3215550] LOG:  database system was shut down at 2023-11-18 19:20:16 GMT</span>
<span class="go">2023-11-18 19:35:16.684 GMT [3215547] LOG:  database system is ready to accept connections</span>
</pre></div>
<p>Keep an eye on this foreground process since this is where <code>elog(LOG,
...)</code> calls will show up.</p>
<p>Now in a new window, create a <code>test.sql</code> script that we can use to
exercise the hook:</p>
<div class="highlight"><pre><span></span><span class="k">DROP</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">IF</span><span class="w"> </span><span class="k">EXISTS</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="nb">INT</span><span class="p">);</span>
<span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="mi">309</span><span class="p">);</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</pre></div>
<p>Run <code>psql</code> so we can trigger the hook:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>/usr/local/pgsql/bin/psql<span class="w"> </span>-h<span class="w"> </span>localhost<span class="w"> </span>postgres<span class="w"> </span>-f<span class="w"> </span>test.sql
<span class="go">DROP TABLE</span>
<span class="go">CREATE TABLE</span>
<span class="go">INSERT 0 1</span>
<span class="go">  a</span>
<span class="go">-----</span>
<span class="go"> 309</span>
<span class="gp gp-VirtualEnv">(1 row)</span>
</pre></div>
<p>And in the <code>postgres</code> foreground process you should see a log:</p>
<div class="highlight"><pre><span></span><span class="go">2023-11-19 17:42:03.045 GMT [3242321] LOG:  [pgexec] HOOKED SUCCESSFULLY!</span>
<span class="go">2023-11-19 17:42:03.045 GMT [3242321] STATEMENT:  INSERT INTO x VALUES (309);</span>
<span class="go">2023-11-19 17:42:03.045 GMT [3242321] LOG:  [pgexec] HOOKED SUCCESSFULLY!</span>
<span class="go">2023-11-19 17:42:03.045 GMT [3242321] STATEMENT:  SELECT a FROM x WHERE a &gt; 1;</span>
</pre></div>
<p>That's our hook! Interestingly only the <code>INSERT</code> and <code>SELECT</code>
statements show up, not the <code>DROP</code> and <code>CREATE</code>.</p>
<p>Now let's see if we can reconstruct the query text from that first
argument, the <code>QueryDesc*</code> that <code>pgexec_run_hook</code> receives. And let's
simplify things for ourselves and only worry about reconstructing a
<code>SELECT</code> query.</p>
<h3 id="<code>node</code>s-and-<code>datum</code>s"><code>Node</code>s and <code>Datum</code>s</h3><p>But first, let's talk about two fundemental ways data in Postgres
(code) is organized.</p>
<p>Postgres code is extremely dynamic and, maybe relatedly,
fairly object-oriented. Almost every entity in Postgres is a
<a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/include/nodes/nodes.h#L128"><code>Node</code></a>. While
values in Postgres that are exposed to users of Postgres are
<a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/include/postgres.h#L64"><code>Datum</code></a>s.</p>
<p>Each node has a type,
<a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/include/nodes/nodes.h#L26"><code>NodeTag</code></a>,
that we can switch on to decide what to do. In contrast, <code>Datum</code> has
no type. The type of the <code>Datum</code> must be known by context before using
one of the transform functions like
<a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/include/postgres.h#L90"><code>DatumGetBool</code></a>
to retrieve a C value from a <code>Datum</code>.</p>
<p>A table is a <code>Node</code>. A query plan is a <code>Node</code>. A sequential scan is a
<code>Node</code>. A join is a <code>Node</code>. A literal in a query is a <code>Node</code>. The
value for the literal in a query is a <code>Datum</code>.</p>
<p>Here is how The Internals of PostgreSQL book
<a href="https://www.interdb.jp/pg/pgsql03.html">visualizes</a> a query plan for
example:</p>
<p><img src="https://www.interdb.jp/pg/img/fig-3-04.png" alt="https://www.interdb.jp/pg/img/fig-3-04.png"></p>
<p>Every box in that image is a <code>Node</code>.</p>
<p>And all <code>Node</code>s in code I've seen share a common definition prefix
like this:</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">SomeThing</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">pg_node_attr</span><span class="p">(</span><span class="n">abstract</span><span class="p">)</span><span class="w"> </span><span class="c1">// If the node is indeed abstract in the OOP sense.</span>
<span class="w">  </span><span class="n">NodeTag</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>Many <code>Node</code>s you'll see are abstract, like <code>Plan</code>. But by printing out
<code>NodeTag</code> and checking the value printed in
<code>src/include/nodes/nodetags.h</code>, you can find the concrete type of the
<code>Node</code>.</p>
<p><code>src/include/nodes/nodetags.h</code> is generated during a preprocessing
step. (Don't look if <a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/backend/nodes/gen_node_support.pl">regex in
Perl</a>
worries you).</p>
<p>We'll get back to <code>Node</code>s later.</p>
<h3 id="what's-in-a-<code>querydesc</code>?">What's in a <code>QueryDesc</code>?</h3><p>Let's take a look at the
<a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/include/executor/execdesc.h#L33"><code>QueryDesc</code></a>
struct:</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">QueryDesc</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* These fields are provided by CreateQueryDesc */</span>
<span class="w">    </span><span class="n">CmdType</span><span class="w">     </span><span class="n">operation</span><span class="p">;</span><span class="w">      </span><span class="cm">/* CMD_SELECT, CMD_UPDATE, etc. */</span>
<span class="w">    </span><span class="n">PlannedStmt</span><span class="w"> </span><span class="o">*</span><span class="n">plannedstmt</span><span class="p">;</span><span class="w">   </span><span class="cm">/* planner&#39;s output (could be utility, too) */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">sourceText</span><span class="p">;</span><span class="w">     </span><span class="cm">/* source text of the query */</span>
<span class="w">    </span><span class="n">Snapshot</span><span class="w">    </span><span class="n">snapshot</span><span class="p">;</span><span class="w">       </span><span class="cm">/* snapshot to use for query */</span>
<span class="w">    </span><span class="n">Snapshot</span><span class="w">    </span><span class="n">crosscheck_snapshot</span><span class="p">;</span><span class="w">    </span><span class="cm">/* crosscheck for RI update/delete */</span>
<span class="w">    </span><span class="n">DestReceiver</span><span class="w"> </span><span class="o">*</span><span class="n">dest</span><span class="p">;</span><span class="w">         </span><span class="cm">/* the destination for tuple output */</span>
<span class="w">    </span><span class="n">ParamListInfo</span><span class="w"> </span><span class="n">params</span><span class="p">;</span><span class="w">       </span><span class="cm">/* param values being passed in */</span>
<span class="w">    </span><span class="n">QueryEnvironment</span><span class="w"> </span><span class="o">*</span><span class="n">queryEnv</span><span class="p">;</span><span class="w"> </span><span class="cm">/* query environment passed in */</span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">instrument_options</span><span class="p">;</span><span class="w"> </span><span class="cm">/* OR of InstrumentOption flags */</span>

<span class="w">    </span><span class="cm">/* These fields are set by ExecutorStart */</span>
<span class="w">    </span><span class="n">TupleDesc</span><span class="w">   </span><span class="n">tupDesc</span><span class="p">;</span><span class="w">        </span><span class="cm">/* descriptor for result tuples */</span>
<span class="w">    </span><span class="n">EState</span><span class="w">     </span><span class="o">*</span><span class="n">estate</span><span class="p">;</span><span class="w">         </span><span class="cm">/* executor&#39;s query-wide state */</span>
<span class="w">    </span><span class="n">PlanState</span><span class="w">  </span><span class="o">*</span><span class="n">planstate</span><span class="p">;</span><span class="w">      </span><span class="cm">/* tree of per-plan-node state */</span>

<span class="w">    </span><span class="cm">/* This field is set by ExecutorRun */</span>
<span class="w">    </span><span class="kt">bool</span><span class="w">        </span><span class="n">already_executed</span><span class="p">;</span><span class="w">   </span><span class="cm">/* true if previously executed */</span>

<span class="w">    </span><span class="cm">/* This is always set NULL by the core system, but plugins can change it */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Instrumentation</span><span class="w"> </span><span class="o">*</span><span class="n">totaltime</span><span class="p">;</span><span class="w">  </span><span class="cm">/* total time spent in ExecutorRun */</span>
<span class="p">}</span><span class="w"> </span><span class="n">QueryDesc</span><span class="p">;</span>
</pre></div>
<p>The
<a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/include/nodes/plannodes.h#L46"><code>PlannedStmt</code></a>
field looks interesting. Let's take a look:</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">PlannedStmt</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">pg_node_attr</span><span class="p">(</span><span class="n">no_equal</span><span class="p">,</span><span class="w"> </span><span class="n">no_query_jumble</span><span class="p">)</span>

<span class="w">    </span><span class="n">NodeTag</span><span class="w">     </span><span class="n">type</span><span class="p">;</span>

<span class="w">    </span><span class="n">CmdType</span><span class="w">     </span><span class="n">commandType</span><span class="p">;</span><span class="w">    </span><span class="cm">/* select|insert|update|delete|merge|utility */</span>

<span class="w">    </span><span class="n">uint64</span><span class="w">      </span><span class="n">queryId</span><span class="p">;</span><span class="w">        </span><span class="cm">/* query identifier (copied from Query) */</span>

<span class="w">    </span><span class="kt">bool</span><span class="w">        </span><span class="n">hasReturning</span><span class="p">;</span><span class="w">   </span><span class="cm">/* is it insert|update|delete RETURNING? */</span>

<span class="w">    </span><span class="kt">bool</span><span class="w">        </span><span class="n">hasModifyingCTE</span><span class="p">;</span><span class="w">    </span><span class="cm">/* has insert|update|delete in WITH? */</span>

<span class="w">    </span><span class="kt">bool</span><span class="w">        </span><span class="n">canSetTag</span><span class="p">;</span><span class="w">      </span><span class="cm">/* do I set the command result tag? */</span>

<span class="w">    </span><span class="kt">bool</span><span class="w">        </span><span class="n">transientPlan</span><span class="p">;</span><span class="w">  </span><span class="cm">/* redo plan when TransactionXmin changes? */</span>

<span class="w">    </span><span class="kt">bool</span><span class="w">        </span><span class="n">dependsOnRole</span><span class="p">;</span><span class="w">  </span><span class="cm">/* is plan specific to current role? */</span>

<span class="w">    </span><span class="kt">bool</span><span class="w">        </span><span class="n">parallelModeNeeded</span><span class="p">;</span><span class="w"> </span><span class="cm">/* parallel mode required to execute? */</span>

<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">jitFlags</span><span class="p">;</span><span class="w">       </span><span class="cm">/* which forms of JIT should be performed */</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Plan</span><span class="w"> </span><span class="o">*</span><span class="n">planTree</span><span class="p">;</span><span class="w">      </span><span class="cm">/* tree of Plan nodes */</span>

<span class="w">    </span><span class="n">List</span><span class="w">       </span><span class="o">*</span><span class="n">rtable</span><span class="p">;</span><span class="w">         </span><span class="cm">/* list of RangeTblEntry nodes */</span>

<span class="w">    </span><span class="n">List</span><span class="w">       </span><span class="o">*</span><span class="n">permInfos</span><span class="p">;</span><span class="w">      </span><span class="cm">/* list of RTEPermissionInfo nodes for rtable</span>
<span class="cm">                                 * entries needing one */</span>

<span class="w">    </span><span class="cm">/* rtable indexes of target relations for INSERT/UPDATE/DELETE/MERGE */</span>
<span class="w">    </span><span class="n">List</span><span class="w">       </span><span class="o">*</span><span class="n">resultRelations</span><span class="p">;</span><span class="w">    </span><span class="cm">/* integer list of RT indexes, or NIL */</span>

<span class="w">    </span><span class="n">List</span><span class="w">       </span><span class="o">*</span><span class="n">appendRelations</span><span class="p">;</span><span class="w">    </span><span class="cm">/* list of AppendRelInfo nodes */</span>

<span class="w">    </span><span class="n">List</span><span class="w">       </span><span class="o">*</span><span class="n">subplans</span><span class="p">;</span><span class="w">       </span><span class="cm">/* Plan trees for SubPlan expressions; note</span>
<span class="cm">                                 * that some could be NULL */</span>

<span class="w">    </span><span class="n">Bitmapset</span><span class="w">  </span><span class="o">*</span><span class="n">rewindPlanIDs</span><span class="p">;</span><span class="w">  </span><span class="cm">/* indices of subplans that require REWIND */</span>

<span class="w">    </span><span class="n">List</span><span class="w">       </span><span class="o">*</span><span class="n">rowMarks</span><span class="p">;</span><span class="w">       </span><span class="cm">/* a list of PlanRowMark&#39;s */</span>

<span class="w">    </span><span class="n">List</span><span class="w">       </span><span class="o">*</span><span class="n">relationOids</span><span class="p">;</span><span class="w">   </span><span class="cm">/* OIDs of relations the plan depends on */</span>

<span class="w">    </span><span class="n">List</span><span class="w">       </span><span class="o">*</span><span class="n">invalItems</span><span class="p">;</span><span class="w">     </span><span class="cm">/* other dependencies, as PlanInvalItems */</span>

<span class="w">    </span><span class="n">List</span><span class="w">       </span><span class="o">*</span><span class="n">paramExecTypes</span><span class="p">;</span><span class="w"> </span><span class="cm">/* type OIDs for PARAM_EXEC Params */</span>

<span class="w">    </span><span class="n">Node</span><span class="w">       </span><span class="o">*</span><span class="n">utilityStmt</span><span class="p">;</span><span class="w">    </span><span class="cm">/* non-null if this is utility stmt */</span>

<span class="w">    </span><span class="cm">/* statement location in source string (copied from Query) */</span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">stmt_location</span><span class="p">;</span><span class="w">  </span><span class="cm">/* start location, or -1 if unknown */</span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">stmt_len</span><span class="p">;</span><span class="w">       </span><span class="cm">/* length in bytes; 0 means &quot;rest of string&quot; */</span>
<span class="p">}</span><span class="w"> </span><span class="n">PlannedStmt</span><span class="p">;</span>
</pre></div>
<p>The <code>struct Plan* planTree</code> field in there looks like what we'd want. But
<a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/include/nodes/plannodes.h#L119"><code>Plan</code></a>
is abstract:</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Plan</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">pg_node_attr</span><span class="p">(</span><span class="n">abstract</span><span class="p">,</span><span class="w"> </span><span class="n">no_equal</span><span class="p">,</span><span class="w"> </span><span class="n">no_query_jumble</span><span class="p">)</span>

<span class="w">    </span><span class="n">NodeTag</span><span class="w">     </span><span class="n">type</span><span class="p">;</span>
</pre></div>
<p>So let's try printing out the <code>planTree-&gt;type</code> field and find the
<code>Node</code> it is concretely. In <code>pgexec.c</code> change the definition of
<code>print_plan</code>:</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">print_plan</span><span class="p">(</span><span class="n">QueryDesc</span><span class="o">*</span><span class="w"> </span><span class="n">queryDesc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">elog</span><span class="p">(</span><span class="n">LOG</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[pgexec] HOOKED SUCCESSFULLY! %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">queryDesc</span><span class="o">-&gt;</span><span class="n">plannedstmt</span><span class="o">-&gt;</span><span class="n">planTree</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>Rebuild and reinstall the extension, and restart Postgres:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>make
<span class="gp">$ </span>sudo<span class="w"> </span>make<span class="w"> </span>install
<span class="gp">$ </span>/usr/local/pgsql/bin/postgres<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--config-file<span class="o">=</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/test-db/postgresql.conf<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>-D<span class="w"> </span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/test-db
<span class="go">  -k $(pwd)/test-db</span>
<span class="go">2023-11-18 19:35:16.680 GMT [3215547] LOG:  starting PostgreSQL 17devel on x86_64-pc-linux-gnu, compiled by gcc (GCC) 13.2.1 20230728 (Red Hat 13.2.1-1), 64-bit</span>
<span class="go">2023-11-18 19:35:16.681 GMT [3215547] LOG:  listening on IPv6 address &quot;::1&quot;, port 5432</span>
<span class="go">2023-11-18 19:35:16.681 GMT [3215547] LOG:  listening on IPv4 address &quot;127.0.0.1&quot;, port 5432</span>
<span class="go">2023-11-18 19:35:16.681 GMT [3215547] LOG:  listening on Unix socket &quot;/tmp/.s.PGSQL.5432&quot;</span>
<span class="go">2023-11-18 19:35:16.682 GMT [3215550] LOG:  database system was shut down at 2023-11-18 19:20:16 GMT</span>
<span class="go">2023-11-18 19:35:16.684 GMT [3215547] LOG:  database system is ready to accept connections</span>
</pre></div>
<p>And in another window run <code>psql</code>:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>/usr/local/pgsql/bin/psql<span class="w"> </span>-h<span class="w"> </span>localhost<span class="w"> </span>postgres<span class="w"> </span>-f<span class="w"> </span>test.sql
</pre></div>
<p>And check the logs from the <code>postgres</code> process we just started and you
should notice:</p>
<div class="highlight"><pre><span></span><span class="go">2023-11-19 17:46:18.834 GMT [3242495] LOG:  [pgexec] HOOKED SUCCESSFULLY! 322</span>
<span class="go">2023-11-19 17:46:18.834 GMT [3242495] STATEMENT:  SELECT a FROM x WHERE a &gt; 1;</span>
</pre></div>
<p>So <code>322</code> is the <code>NodeTag</code> for the <code>Plan</code>. If we look that up in
Postgres's <code>src/include/nodes/nodetags.h</code> (remember, this is generated
after <code>./configure &amp;&amp; make</code> so I can't link you to it):</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>grep<span class="w"> </span><span class="s1">&#39; = 322&#39;</span><span class="w"> </span>src/include/nodes/nodetags.h
<span class="go">        T_SeqScan = 322,</span>
</pre></div>
<p>Hey, that makes sense! A <code>SELECT</code> without any indexes definitely
sounds like a sequential scan!</p>
<h3 id="walking-a-sequential-scan">Walking a sequential scan</h3><p>Let's take a look at the
<a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/include/nodes/plannodes.h#L394"><code>SeqScan</code></a>
struct:</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">SeqScan</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Scan</span><span class="w">        </span><span class="n">scan</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">SeqScan</span><span class="p">;</span>
</pre></div>
<p>Ok, that's not very interesting. Let's look at
<a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/include/nodes/plannodes.h#L382"><code>Scan</code></a>
then:</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Scan</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">pg_node_attr</span><span class="p">(</span><span class="n">abstract</span><span class="p">)</span>

<span class="w">    </span><span class="n">Plan</span><span class="w">        </span><span class="n">plan</span><span class="p">;</span>
<span class="w">    </span><span class="n">Index</span><span class="w">       </span><span class="n">scanrelid</span><span class="p">;</span><span class="w">      </span><span class="cm">/* relid is index into the range table */</span>
<span class="p">}</span><span class="w"> </span><span class="n">Scan</span><span class="p">;</span>
</pre></div>
<p>That's interesting! <code>scanrelid</code> represents the table we're scanning. I
don't know what "range table" means exactly. But there was a field on
the <code>PlannedStmt</code> called <code>rtable</code> that seems relevant.</p>
<p><code>rtable</code> was described as a
<a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/include/nodes/pg_list.h#L53"><code>List</code></a>
of
<a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/include/nodes/parsenodes.h#L1019"><code>RangeTblEntry</code></a>
nodes. And browsing around the file where <code>List</code> is defined we can see
some nice methods for working with <code>List</code>s, like <code>list_length()</code>.</p>
<p>Let's print out the <code>scanrelid</code> and let's check out the length of the
<code>rtable</code> and see if it's filled out. Let's also restrict our
<code>print_plan</code> code to only look at <code>SeqScan</code> nodes. In <code>pgexec.c</code>:</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">print_plan</span><span class="p">(</span><span class="n">QueryDesc</span><span class="o">*</span><span class="w"> </span><span class="n">queryDesc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">SeqScan</span><span class="o">*</span><span class="w"> </span><span class="n">scan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="n">Plan</span><span class="o">*</span><span class="w"> </span><span class="n">plan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">queryDesc</span><span class="o">-&gt;</span><span class="n">plannedstmt</span><span class="o">-&gt;</span><span class="n">planTree</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">T_SeqScan</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">elog</span><span class="p">(</span><span class="n">LOG</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[pgexec] Unsupported plan type.&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">scan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">SeqScan</span><span class="o">*</span><span class="p">)</span><span class="n">plan</span><span class="p">;</span>

<span class="w">  </span><span class="n">elog</span><span class="p">(</span><span class="n">LOG</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[pgexec] relid: %d, rtable length: %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">scan</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">.</span><span class="n">scanrelid</span><span class="p">,</span><span class="w"> </span><span class="n">list_length</span><span class="p">(</span><span class="n">queryDesc</span><span class="o">-&gt;</span><span class="n">plannedstmt</span><span class="o">-&gt;</span><span class="n">rtable</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
<p>Rebuild and reinstall the extension, and restart Postgres. (You can
find the instructions for this above if you've forgotten.) Re-run the
<code>test.sql</code> script. And check the Postgres server logs. You should see:</p>
<div class="highlight"><pre><span></span><span class="go">2023-11-19 18:00:34.184 GMT [3244438] LOG:  [pgexec] relid: 1, rtable length: 1</span>
<span class="go">2023-11-19 18:00:34.184 GMT [3244438] STATEMENT:  SELECT a FROM x WHERE a &gt; 1;</span>
</pre></div>
<p>Awesome! So <code>rtable</code> does have data in it. There's only one table in
this query so its length makes sense to be <code>1</code>. The <code>scanrelid</code> being
<code>1</code> also though is weird. Let's fetch the nth value from the <code>rtable</code>
list using <code>scanrelid-1</code> as the index.</p>
<p>For the
<a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/include/nodes/parsenodes.h#L1019"><code>RangeTblEntry</code></a>
itself, let's take a look:</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">RTEKind</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">RTE_RELATION</span><span class="p">,</span><span class="w">               </span><span class="cm">/* ordinary relation reference */</span>
<span class="w">    </span><span class="n">RTE_SUBQUERY</span><span class="p">,</span><span class="w">               </span><span class="cm">/* subquery in FROM */</span>
<span class="w">    </span><span class="n">RTE_JOIN</span><span class="p">,</span><span class="w">                   </span><span class="cm">/* join */</span>
<span class="w">    </span><span class="n">RTE_FUNCTION</span><span class="p">,</span><span class="w">               </span><span class="cm">/* function in FROM */</span>
<span class="w">    </span><span class="n">RTE_TABLEFUNC</span><span class="p">,</span><span class="w">              </span><span class="cm">/* TableFunc(.., column list) */</span>
<span class="w">    </span><span class="n">RTE_VALUES</span><span class="p">,</span><span class="w">                 </span><span class="cm">/* VALUES (&lt;exprlist&gt;), (&lt;exprlist&gt;), ... */</span>
<span class="w">    </span><span class="n">RTE_CTE</span><span class="p">,</span><span class="w">                    </span><span class="cm">/* common table expr (WITH list element) */</span>
<span class="w">    </span><span class="n">RTE_NAMEDTUPLESTORE</span><span class="p">,</span><span class="w">        </span><span class="cm">/* tuplestore, e.g. for AFTER triggers */</span>
<span class="w">    </span><span class="n">RTE_RESULT</span><span class="p">,</span><span class="w">                 </span><span class="cm">/* RTE represents an empty FROM clause; such</span>
<span class="cm">                                 * RTEs are added by the planner, they&#39;re not</span>
<span class="cm">                                 * present during parsing or rewriting */</span>
<span class="p">}</span><span class="w"> </span><span class="n">RTEKind</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">RangeTblEntry</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">pg_node_attr</span><span class="p">(</span><span class="n">custom_read_write</span><span class="p">,</span><span class="w"> </span><span class="n">custom_query_jumble</span><span class="p">)</span>

<span class="w">    </span><span class="n">NodeTag</span><span class="w">     </span><span class="n">type</span><span class="p">;</span>

<span class="w">    </span><span class="n">RTEKind</span><span class="w">     </span><span class="n">rtekind</span><span class="p">;</span><span class="w">        </span><span class="cm">/* see above */</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * XXX the fields applicable to only some rte kinds should be merged into</span>
<span class="cm">     * a union.  I didn&#39;t do this yet because the diffs would impact a lot of</span>
<span class="cm">     * code that is being actively worked on.  FIXME someday.</span>
<span class="cm">     */</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Fields valid for a plain relation RTE (else zero):</span>
<span class="cm">     *</span>
<span class="cm">     * rellockmode is really LOCKMODE, but it&#39;s declared int to avoid having</span>
<span class="cm">     * to include lock-related headers here.  It must be RowExclusiveLock if</span>
<span class="cm">     * the RTE is an INSERT/UPDATE/DELETE/MERGE target, else RowShareLock if</span>
<span class="cm">     * the RTE is a SELECT FOR UPDATE/FOR SHARE target, else AccessShareLock.</span>
<span class="cm">     *</span>
<span class="cm">     * Note: in some cases, rule expansion may result in RTEs that are marked</span>
<span class="cm">     * with RowExclusiveLock even though they are not the target of the</span>
<span class="cm">     * current query; this happens if a DO ALSO rule simply scans the original</span>
<span class="cm">     * target table.  We leave such RTEs with their original lockmode so as to</span>
<span class="cm">     * avoid getting an additional, lesser lock.</span>
<span class="cm">     *</span>
<span class="cm">     * perminfoindex is 1-based index of the RTEPermissionInfo belonging to</span>
<span class="cm">     * this RTE in the containing struct&#39;s list of same; 0 if permissions need</span>
<span class="cm">     * not be checked for this RTE.</span>
<span class="cm">     *</span>
<span class="cm">     * As a special case, relid, relkind, rellockmode, and perminfoindex can</span>
<span class="cm">     * also be set (nonzero) in an RTE_SUBQUERY RTE.  This occurs when we</span>
<span class="cm">     * convert an RTE_RELATION RTE naming a view into an RTE_SUBQUERY</span>
<span class="cm">     * containing the view&#39;s query.  We still need to perform run-time locking</span>
<span class="cm">     * and permission checks on the view, even though it&#39;s not directly used</span>
<span class="cm">     * in the query anymore, and the most expedient way to do that is to</span>
<span class="cm">     * retain these fields from the old state of the RTE.</span>
<span class="cm">     *</span>
<span class="cm">     * As a special case, RTE_NAMEDTUPLESTORE can also set relid to indicate</span>
<span class="cm">     * that the tuple format of the tuplestore is the same as the referenced</span>
<span class="cm">     * relation.  This allows plans referencing AFTER trigger transition</span>
<span class="cm">     * tables to be invalidated if the underlying table is altered.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">Oid</span><span class="w">         </span><span class="n">relid</span><span class="p">;</span><span class="w">          </span><span class="cm">/* OID of the relation */</span>
<span class="w">    </span><span class="kt">char</span><span class="w">        </span><span class="n">relkind</span><span class="p">;</span><span class="w">        </span><span class="cm">/* relation kind (see pg_class.relkind) */</span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">rellockmode</span><span class="p">;</span><span class="w">    </span><span class="cm">/* lock level that query requires on the rel */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">TableSampleClause</span><span class="w"> </span><span class="o">*</span><span class="n">tablesample</span><span class="p">;</span><span class="w">  </span><span class="cm">/* sampling info, or NULL */</span>
<span class="w">    </span><span class="n">Index</span><span class="w">       </span><span class="n">perminfoindex</span><span class="p">;</span>
</pre></div>
<p>In <code>SELECT a FROM x</code>, <code>x</code> should be a plain relation RTE (to use the
terminology there). So we can add a guard that validates that. But we
don't get a <code>Relation</code>. (You might remember from my <a href="https://notes.eatonphil.com/2023-11-01-postgres-table-access-methods.html">previous
post</a>
that <code>Relation</code> is where we can finally see the table name.)</p>
<p>We get an <code>Oid</code> for the <code>Relation</code>. So we need to find a way to lookup
a <code>Relation</code> from an <code>Oid</code>. And by grepping around in Postgres (or via
judicious use of ChatGPT, I confess), we can notice
<a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/backend/utils/cache/relcache.c#L2056"><code>RelationIdGetRelation</code></a>
that takes an <code>Oid</code> and returns a <code>Relation</code>. Notice also that the
comment says we should close the relation when we're done with
<code>RelationClose</code>.</p>
<p>So putting it altogether (and again, reusing some code from that
previous post), we can print out the table name.</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">print_plan</span><span class="p">(</span><span class="n">QueryDesc</span><span class="o">*</span><span class="w"> </span><span class="n">queryDesc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">SeqScan</span><span class="o">*</span><span class="w"> </span><span class="n">scan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="n">RangeTblEntry</span><span class="o">*</span><span class="w"> </span><span class="n">rte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="n">Relation</span><span class="w"> </span><span class="n">relation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="w">  </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">tablename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="n">Plan</span><span class="o">*</span><span class="w"> </span><span class="n">plan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">queryDesc</span><span class="o">-&gt;</span><span class="n">plannedstmt</span><span class="o">-&gt;</span><span class="n">planTree</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">T_SeqScan</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">elog</span><span class="p">(</span><span class="n">LOG</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[pgexec] Unsupported plan type.&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">scan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">SeqScan</span><span class="o">*</span><span class="p">)</span><span class="n">plan</span><span class="p">;</span>
<span class="w">  </span><span class="n">rte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list_nth</span><span class="p">(</span><span class="n">queryDesc</span><span class="o">-&gt;</span><span class="n">plannedstmt</span><span class="o">-&gt;</span><span class="n">rtable</span><span class="p">,</span><span class="w"> </span><span class="n">scan</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">.</span><span class="n">scanrelid</span><span class="mi">-1</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">rtekind</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">RTE_RELATION</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">elog</span><span class="p">(</span><span class="n">LOG</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[pgexec] Unsupported FROM type: %d.&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">rtekind</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">relation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RelationIdGetRelation</span><span class="p">(</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">relid</span><span class="p">);</span>
<span class="w">  </span><span class="n">tablename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NameStr</span><span class="p">(</span><span class="n">relation</span><span class="o">-&gt;</span><span class="n">rd_rel</span><span class="o">-&gt;</span><span class="n">relname</span><span class="p">);</span>

<span class="w">  </span><span class="n">elog</span><span class="p">(</span><span class="n">LOG</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[pgexec] SELECT [todo] FROM %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">tablename</span><span class="p">);</span>

<span class="w">  </span><span class="n">RelationClose</span><span class="p">(</span><span class="n">relation</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>You'll also need to add a new <code>#include</code> for
<code>utils/rel.h</code>.</p>
<p>Rebuild and reinstall the extension, and restart Postgres. Re-run the
<code>test.sql</code> script. Check the Postgres server logs and you should see:</p>
<div class="highlight"><pre><span></span><span class="go">2023-11-19 18:36:03.986 GMT [3246777] LOG:  [pgexec] SELECT [todo] FROM x</span>
<span class="go">2023-11-19 18:36:03.986 GMT [3246777] STATEMENT:  SELECT a FROM x WHERE a &gt; 1;</span>
</pre></div>
<p>Fantastic! Before we get into walking the <code>SELECT</code> columns and the
(optional) <code>WHERE</code> clause, let's do some quick refactoring.</p>
<h3 id="a-string-builder">A string builder</h3><p>Let's add a little string builder library so we can emit a single
string we build up to a single <code>elog()</code> call.</p>
<p>I wrote this ahead of time and won't explain it here since the details
aren't relevant.</p>
<p>Just copy this and paste near the top of <code>pgexec.c</code>:</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">mem</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">PGExec_Buffer</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_init</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
<span class="w">  </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">mem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_resize_to_fit_additional</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">additional</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">newsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="n">Assert</span><span class="p">(</span><span class="n">additional</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">additional</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">newsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">additional</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="n">new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">newsize</span><span class="p">);</span>
<span class="w">  </span><span class="n">Assert</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">  </span><span class="n">memcpy</span><span class="p">(</span><span class="n">new</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">);</span>
<span class="w">  </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">newsize</span><span class="p">;</span>
<span class="w">  </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">mem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_append</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">);</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_appendz</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">buffer_append</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_append</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">chars</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">buffer_resize_to_fit_additional</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">chars</span><span class="p">);</span>
<span class="w">  </span><span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">mem</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">chars</span><span class="p">);</span>
<span class="w">  </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">chars</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_appendf</span><span class="p">(</span>
<span class="w">  </span><span class="n">PGExec_Buffer</span><span class="w"> </span><span class="o">*</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="kr">restrict</span><span class="p">,</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">)</span><span class="w"> </span><span class="n">__attribute__</span><span class="w"> </span><span class="p">((</span><span class="n">format</span><span class="w"> </span><span class="p">(</span><span class="n">gnu_printf</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)));</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_appendf</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="kr">restrict</span><span class="w"> </span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// First figure out how long the result will be.</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">chars</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">va_list</span><span class="w"> </span><span class="n">arglist</span><span class="p">;</span>
<span class="w">  </span><span class="n">va_start</span><span class="p">(</span><span class="n">arglist</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span><span class="p">);</span>
<span class="w">  </span><span class="n">chars</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vsnprintf</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="n">arglist</span><span class="p">);</span>
<span class="w">  </span><span class="n">Assert</span><span class="p">(</span><span class="n">chars</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// TODO: error handling.</span>

<span class="w">  </span><span class="c1">// Resize to fit result.</span>
<span class="w">  </span><span class="n">buffer_resize_to_fit_additional</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">chars</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Actually do the printf into buf.</span>
<span class="w">  </span><span class="n">va_end</span><span class="p">(</span><span class="n">arglist</span><span class="p">);</span>
<span class="w">  </span><span class="n">va_start</span><span class="p">(</span><span class="n">arglist</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span><span class="p">);</span>
<span class="w">  </span><span class="n">chars</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vsprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">mem</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="n">arglist</span><span class="p">);</span>
<span class="w">  </span><span class="n">Assert</span><span class="p">(</span><span class="n">chars</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// TODO: error handling.</span>
<span class="w">  </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">chars</span><span class="p">;</span>
<span class="w">  </span><span class="n">va_end</span><span class="p">(</span><span class="n">arglist</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">buffer_cstring</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">prev_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">buffer_append</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">zero</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span><span class="o">--</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">[</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Offset should stay the same. This is a fake NULL.</span>
<span class="w">  </span><span class="n">Assert</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">prev_offset</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_free</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>Next we'll modify <code>print_plan()</code> in <code>pgexec.c</code> to use it, and add stubs
for printing the <code>SELECT</code> columns and <code>WHERE</code> clauses.</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_where</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">QueryDesc</span><span class="o">*</span><span class="w"> </span><span class="n">queryDesc</span><span class="p">,</span><span class="w"> </span><span class="n">Plan</span><span class="o">*</span><span class="w"> </span><span class="n">plan</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">buffer_appendz</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; [where todo]&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_select_columns</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">QueryDesc</span><span class="o">*</span><span class="w"> </span><span class="n">queryDesc</span><span class="p">,</span><span class="w"> </span><span class="n">Plan</span><span class="o">*</span><span class="w"> </span><span class="n">plan</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">buffer_appendz</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[columns todo]&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">print_plan</span><span class="p">(</span><span class="n">QueryDesc</span><span class="o">*</span><span class="w"> </span><span class="n">queryDesc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">SeqScan</span><span class="o">*</span><span class="w"> </span><span class="n">scan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="n">RangeTblEntry</span><span class="o">*</span><span class="w"> </span><span class="n">rte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="n">Relation</span><span class="w"> </span><span class="n">relation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="w">  </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">tablename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="n">Plan</span><span class="o">*</span><span class="w"> </span><span class="n">plan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">queryDesc</span><span class="o">-&gt;</span><span class="n">plannedstmt</span><span class="o">-&gt;</span><span class="n">planTree</span><span class="p">;</span>
<span class="w">  </span><span class="n">PGExec_Buffer</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">T_SeqScan</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">elog</span><span class="p">(</span><span class="n">LOG</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[pgexec] Unsupported plan type.&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">scan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">SeqScan</span><span class="o">*</span><span class="p">)</span><span class="n">plan</span><span class="p">;</span>
<span class="w">  </span><span class="n">rte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list_nth</span><span class="p">(</span><span class="n">queryDesc</span><span class="o">-&gt;</span><span class="n">plannedstmt</span><span class="o">-&gt;</span><span class="n">rtable</span><span class="p">,</span><span class="w"> </span><span class="n">scan</span><span class="o">-&gt;</span><span class="n">scan</span><span class="p">.</span><span class="n">scanrelid</span><span class="mi">-1</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">rtekind</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">RTE_RELATION</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">elog</span><span class="p">(</span><span class="n">LOG</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[pgexec] Unsupported FROM type: %d.&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">rtekind</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">buffer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>

<span class="w">  </span><span class="n">relation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RelationIdGetRelation</span><span class="p">(</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">relid</span><span class="p">);</span>
<span class="w">  </span><span class="n">tablename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NameStr</span><span class="p">(</span><span class="n">relation</span><span class="o">-&gt;</span><span class="n">rd_rel</span><span class="o">-&gt;</span><span class="n">relname</span><span class="p">);</span>

<span class="w">  </span><span class="n">buffer_appendz</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;SELECT &quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">buffer_print_select_columns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">queryDesc</span><span class="p">,</span><span class="w"> </span><span class="n">plan</span><span class="p">);</span>
<span class="w">  </span><span class="n">buffer_appendf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; FROM %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">tablename</span><span class="p">);</span>
<span class="w">  </span><span class="n">buffer_print_where</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">queryDesc</span><span class="p">,</span><span class="w"> </span><span class="n">plan</span><span class="p">);</span>

<span class="w">  </span><span class="n">elog</span><span class="p">(</span><span class="n">LOG</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[pgexec] %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_cstring</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">));</span>

<span class="w">  </span><span class="n">RelationClose</span><span class="p">(</span><span class="n">relation</span><span class="p">);</span>
<span class="w">  </span><span class="n">buffer_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>Now we just need to implement the <code>buffer_print_where</code> and
<code>buffer_print_select_columns</code> functions and our walking infrastructure
will be done! For now. :)</p>
<h3 id="walking-the-<code>where</code>-clause">Walking the <code>WHERE</code> clause</h3><p>If you remember back to the <code>SeqScan</code> and <code>Scan</code> nodes, they were both
basically empty. They had a <code>Plan</code> and a <code>scanrelid</code>. So the rest of
the <code>SELECT</code> info must be in the <code>Plan</code> since it wasn't in the <code>Scan</code>.</p>
<p>Let's look at
<a href="https://github.com/postgres/postgres/blob/master/src/include/nodes/plannodes.h#L119"><code>Plan</code></a>
again. One part that stands out is:</p>
<div class="highlight"><pre><span></span><span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Common structural data for all Plan types.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">plan_node_id</span><span class="p">;</span><span class="w">   </span><span class="cm">/* unique across entire final plan tree */</span>
<span class="w">    </span><span class="n">List</span><span class="w">       </span><span class="o">*</span><span class="n">targetlist</span><span class="p">;</span><span class="w">     </span><span class="cm">/* target list to be computed at this node */</span>
<span class="w">    </span><span class="n">List</span><span class="w">       </span><span class="o">*</span><span class="n">qual</span><span class="p">;</span><span class="w">           </span><span class="cm">/* implicitly-ANDed qual conditions */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Plan</span><span class="w"> </span><span class="o">*</span><span class="n">lefttree</span><span class="p">;</span><span class="w">      </span><span class="cm">/* input plan tree(s) */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Plan</span><span class="w"> </span><span class="o">*</span><span class="n">righttree</span><span class="p">;</span>
<span class="w">    </span><span class="n">List</span><span class="w">       </span><span class="o">*</span><span class="n">initPlan</span><span class="p">;</span><span class="w">       </span><span class="cm">/* Init Plan nodes (un-correlated expr</span>
<span class="cm">                                 * subselects) */</span>
</pre></div>
<p><code>qual</code> kinda looks like a <code>WHERE</code> clause. (And <code>targetlist</code> kinda
looks like the columns the <code>SELECT</code> pulls).</p>
<p><a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/include/nodes/pg_list.h#L53"><code>List</code></a>s
just contain void pointers, so we can't tell what the type of <code>qual</code>
or <code>targetlist</code> children are. But I'm going to make a wild guess they
are <code>Node</code>s.</p>
<p>There's even a nice helper that casts void pointers to <code>Node*</code> and
pulls out the type,
<a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/include/nodes/nodes.h#L133"><code>nodeTag()</code></a>.</p>
<p>And reading around <code>pg_list.h</code> shows some interesting helper utilities
like
<a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/include/nodes/pg_list.h#L373"><code>foreach</code></a>
that we can use to iterate the list.</p>
<p>Let's try printing out the type of <code>qual</code>'s members.</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_where</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">QueryDesc</span><span class="o">*</span><span class="w"> </span><span class="n">queryDesc</span><span class="p">,</span><span class="w"> </span><span class="n">Plan</span><span class="o">*</span><span class="w"> </span><span class="n">plan</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ListCell</span><span class="o">*</span><span class="w"> </span><span class="n">cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">qual</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">buffer_appendz</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; WHERE &quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">foreach</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span><span class="w"> </span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">qual</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">buffer_appendz</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; AND &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="n">buffer_appendf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[node: %d]&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">nodeTag</span><span class="p">(</span><span class="n">lfirst</span><span class="p">(</span><span class="n">cell</span><span class="p">)));</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p class="note">
  Notice any <a
  href="https://twitter.com/eatonphil/status/1726265982094819631">vestiges
  of LISP</a>?
</p><p>Rebuild and reinstall the extension, and restart Postgres. Re-run the
<code>test.sql</code> script. Check the Postgres server logs and you should see:</p>
<div class="highlight"><pre><span></span><span class="go">2023-11-19 19:17:00.879 GMT [3250850] LOG:  [pgexec] SELECT [columns todo] FROM x WHERE [node: 15]</span>
<span class="go">2023-11-19 19:17:00.879 GMT [3250850] STATEMENT:  SELECT a FROM x WHERE a &gt; 1;</span>
</pre></div>
<p>Well, our code didn't crash! So the guess about <code>qual</code> <code>List</code> entries
being <code>Node</code>s seems right. Let's look up that node type in the
Postgres repo:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>grep<span class="w"> </span><span class="s1">&#39; = 15,&#39;</span><span class="w"> </span>src/include/nodes/nodetags.h
<span class="go">        T_OpExpr = 15,</span>
</pre></div>
<p>Woot! That is exactly what I'd expect the <code>WHERE</code> clause here to be.</p>
<p>Now that we know <code>qual</code> is a <code>List</code> of <code>Node</code>s, let's do a bit of
refactoring since <code>targetlist</code> will probably also be a <code>List</code> of
<code>Node</code>s. Back in <code>pgexec.c</code>:</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_expr</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">*</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_list</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">List</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="p">);</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_opexpr</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">OpExpr</span><span class="o">*</span><span class="w"> </span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">buffer_appendf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[opexpr: todo]&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_expr</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">expr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">nodeTag</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">T_OpExpr</span><span class="p">:</span>
<span class="w">    </span><span class="n">buffer_print_opexpr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">OpExpr</span><span class="o">*</span><span class="p">)</span><span class="n">expr</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>

<span class="w">  </span><span class="k">default</span><span class="o">:</span>
<span class="w">    </span><span class="n">buffer_appendf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[Unknown: %d]&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">nodeTag</span><span class="p">(</span><span class="n">expr</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_list</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">List</span><span class="o">*</span><span class="w"> </span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">sep</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ListCell</span><span class="o">*</span><span class="w"> </span><span class="n">cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">  </span><span class="n">foreach</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span><span class="w"> </span><span class="n">list</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">buffer_appendz</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">sep</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="n">buffer_print_expr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">)</span><span class="n">lfirst</span><span class="p">(</span><span class="n">cell</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_where</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">QueryDesc</span><span class="o">*</span><span class="w"> </span><span class="n">queryDesc</span><span class="p">,</span><span class="w"> </span><span class="n">Plan</span><span class="o">*</span><span class="w"> </span><span class="n">plan</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">qual</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">buffer_appendz</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; WHERE &quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">buffer_print_list</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">qual</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; AND &quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>And let's check out <code>OpExpr</code>!</p>
<h3 id="walking-<code>opexpr</code>">Walking <code>OpExpr</code></h3><p>Take a look at the definition of
<a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/include/nodes/primnodes.h#L748"><code>OpExpr</code></a>:</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">OpExpr</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Expr</span><span class="w">        </span><span class="n">xpr</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* PG_OPERATOR OID of the operator */</span>
<span class="w">    </span><span class="n">Oid</span><span class="w">         </span><span class="n">opno</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* PG_PROC OID of underlying function */</span>
<span class="w">    </span><span class="n">Oid</span><span class="w">         </span><span class="n">opfuncid</span><span class="w"> </span><span class="n">pg_node_attr</span><span class="p">(</span><span class="n">equal_ignore_if_zero</span><span class="p">,</span><span class="w"> </span><span class="n">query_jumble_ignore</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* PG_TYPE OID of result value */</span>
<span class="w">    </span><span class="n">Oid</span><span class="w">         </span><span class="n">opresulttype</span><span class="w"> </span><span class="n">pg_node_attr</span><span class="p">(</span><span class="n">query_jumble_ignore</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* true if operator returns set */</span>
<span class="w">    </span><span class="kt">bool</span><span class="w">        </span><span class="n">opretset</span><span class="w"> </span><span class="nf">pg_node_attr</span><span class="p">(</span><span class="n">query_jumble_ignore</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* OID of collation of result */</span>
<span class="w">    </span><span class="n">Oid</span><span class="w">         </span><span class="n">opcollid</span><span class="w"> </span><span class="n">pg_node_attr</span><span class="p">(</span><span class="n">query_jumble_ignore</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* OID of collation that operator should use */</span>
<span class="w">    </span><span class="n">Oid</span><span class="w">         </span><span class="n">inputcollid</span><span class="w"> </span><span class="n">pg_node_attr</span><span class="p">(</span><span class="n">query_jumble_ignore</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* arguments to the operator (1 or 2) */</span>
<span class="w">    </span><span class="n">List</span><span class="w">       </span><span class="o">*</span><span class="n">args</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* token location, or -1 if unknown */</span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">location</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">OpExpr</span><span class="p">;</span>
</pre></div>
<p>The important fields are <code>opno</code>, the <code>Oid</code> of the operator, and
<code>args</code>. <code>args</code> looks like another <code>List</code> of <code>Node</code>s so we already know
how to handle that.</p>
<p>But how do we find the string name of the operator? Presumably there's
infrastructure like <code>RelationIdGetRelation</code> that takes an <code>Oid</code> and
gets us an operator object.</p>
<p>Well I got stuck here as well. Again, thankfully, ChatGPT gave me some
suggestions. There's no great story for how I got it working. So here's
<code>buffer_print_opexpr</code>.</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_op</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">OpExpr</span><span class="o">*</span><span class="w"> </span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">HeapTuple</span><span class="w"> </span><span class="n">opertup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SearchSysCache1</span><span class="p">(</span><span class="n">OPEROID</span><span class="p">,</span><span class="w"> </span><span class="n">ObjectIdGetDatum</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">opno</span><span class="p">));</span>

<span class="w">  </span><span class="n">buffer_print_expr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">lfirst</span><span class="p">(</span><span class="n">list_nth_cell</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)));</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">HeapTupleIsValid</span><span class="p">(</span><span class="n">opertup</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Form_pg_operator</span><span class="w"> </span><span class="n">operator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Form_pg_operator</span><span class="p">)</span><span class="n">GETSTRUCT</span><span class="p">(</span><span class="n">opertup</span><span class="p">);</span>
<span class="w">    </span><span class="n">buffer_appendf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; %s &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">NameStr</span><span class="p">(</span><span class="n">operator</span><span class="o">-&gt;</span><span class="n">oprname</span><span class="p">));</span>
<span class="w">    </span><span class="n">ReleaseSysCache</span><span class="p">(</span><span class="n">opertup</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">buffer_appendf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[Unknown operation: %d]&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">op</span><span class="o">-&gt;</span><span class="n">opno</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// TODO: Support single operand operations.</span>
<span class="w">  </span><span class="n">buffer_print_expr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">lfirst</span><span class="p">(</span><span class="n">list_nth_cell</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)));</span>
<span class="p">}</span>
</pre></div>
<p>And add the following two includes to the top of <code>pgexec.c</code>:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;catalog/pg_operator.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;utils/syscache.h&quot;</span>
</pre></div>
<p>Rebuild and reinstall the extension, and restart Postgres. Re-run the
<code>test.sql</code> script. Check the Postgres server logs and you should see:</p>
<div class="highlight"><pre><span></span><span class="go">2023-11-19 19:42:52.916 GMT [3252974] LOG:  [pgexec] SELECT [columns todo] FROM x WHERE [Unknown: 6] &gt; [Unknown: 7]</span>
<span class="go">2023-11-19 19:42:52.916 GMT [3252974] STATEMENT:  SELECT a FROM x WHERE a &gt; 1;</span>
</pre></div>
<p>And we continue to make progress! Let's look up the type of these two
unknown nodes.</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>grep<span class="w"> </span><span class="s1">&#39; = 6,&#39;</span><span class="w"> </span>src/include/nodes/nodetags.h
<span class="go">        T_Var = 6,</span>
<span class="gp">$ </span>grep<span class="w"> </span><span class="s1">&#39; = 7,&#39;</span><span class="w"> </span>src/include/nodes/nodetags.h
<span class="go">        T_Const = 7,</span>
</pre></div>
<p>Let's deal with <code>Const</code> first.</p>
<h3 id="walking-<code>const</code>">Walking <code>Const</code></h3><p>If we take a look at the
<a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/include/nodes/primnodes.h#L292"><code>Const</code></a>
definition:</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">pg_node_attr</span><span class="p">(</span><span class="n">custom_copy_equal</span><span class="p">,</span><span class="w"> </span><span class="n">custom_read_write</span><span class="p">)</span>

<span class="w">    </span><span class="n">Expr</span><span class="w">        </span><span class="n">xpr</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* pg_type OID of the constant&#39;s datatype */</span>
<span class="w">    </span><span class="n">Oid</span><span class="w">         </span><span class="n">consttype</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* typmod value, if any */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">       </span><span class="n">consttypmod</span><span class="w"> </span><span class="n">pg_node_attr</span><span class="p">(</span><span class="n">query_jumble_ignore</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* OID of collation, or InvalidOid if none */</span>
<span class="w">    </span><span class="n">Oid</span><span class="w">         </span><span class="n">constcollid</span><span class="w"> </span><span class="n">pg_node_attr</span><span class="p">(</span><span class="n">query_jumble_ignore</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* typlen of the constant&#39;s datatype */</span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">constlen</span><span class="w"> </span><span class="nf">pg_node_attr</span><span class="p">(</span><span class="n">query_jumble_ignore</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* the constant&#39;s value */</span>
<span class="w">    </span><span class="n">Datum</span><span class="w">       </span><span class="n">constvalue</span><span class="w"> </span><span class="n">pg_node_attr</span><span class="p">(</span><span class="n">query_jumble_ignore</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* whether the constant is null (if true, constvalue is undefined) */</span>
<span class="w">    </span><span class="kt">bool</span><span class="w">        </span><span class="n">constisnull</span><span class="w"> </span><span class="nf">pg_node_attr</span><span class="p">(</span><span class="n">query_jumble_ignore</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Whether this datatype is passed by value.  If true, then all the</span>
<span class="cm">     * information is stored in the Datum.  If false, then the Datum contains</span>
<span class="cm">     * a pointer to the information.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="kt">bool</span><span class="w">        </span><span class="n">constbyval</span><span class="w"> </span><span class="nf">pg_node_attr</span><span class="p">(</span><span class="n">query_jumble_ignore</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * token location, or -1 if unknown.  All constants are tracked as</span>
<span class="cm">     * locations in query jumbling, to be marked as parameters.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">location</span><span class="w"> </span><span class="nf">pg_node_attr</span><span class="p">(</span><span class="n">query_jumble_location</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="n">Const</span><span class="p">;</span>
</pre></div>
<p>It looks like we need to switch on the <code>consttype</code> (an <code>Oid</code>) to
figure out how to interpret the <code>constvalue</code> (a <code>Datum</code>). Remember I
mentioned earlier that how to interpret a <code>Datum</code> is dependent on
context. <code>consttype</code> is the context here.</p>
<p>In this case, although <code>consttype</code> is an <code>Oid</code> and we had to use
Postgres infrastructure to look up the <code>Oid</code>'s corresponding object,
there are some builtin types and the literals we've queried with are
among them.</p>
<p>We can simply check if <code>consttype == INT4OID</code> and the interpret the
<code>Datum</code> as an <code>int32</code> if so. <code>DatumGetInt32</code> will get us that <code>int32</code>
in that case.</p>
<p>To support the new <code>Const</code> type, we'll add a case in
<code>buffer_print_expr</code> to look for a <code>T_Const</code>.</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_expr</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">expr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">nodeTag</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">T_Const</span><span class="p">:</span>
<span class="w">    </span><span class="n">buffer_print_const</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Const</span><span class="o">*</span><span class="p">)</span><span class="n">expr</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>

<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">T_OpExpr</span><span class="p">:</span>
<span class="w">    </span><span class="n">buffer_print_opexpr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">OpExpr</span><span class="o">*</span><span class="p">)</span><span class="n">expr</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>

<span class="w">  </span><span class="k">default</span><span class="o">:</span>
<span class="w">    </span><span class="n">buffer_appendf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[Unknown: %d]&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">nodeTag</span><span class="p">(</span><span class="n">expr</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>And add a new function, <code>buffer_print_const</code>:</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_const</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">Const</span><span class="o">*</span><span class="w"> </span><span class="n">cnst</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">cnst</span><span class="o">-&gt;</span><span class="n">consttype</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">INT4OID</span><span class="p">:</span>
<span class="w">    </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DatumGetInt32</span><span class="p">(</span><span class="n">cnst</span><span class="o">-&gt;</span><span class="n">constvalue</span><span class="p">);</span>
<span class="w">    </span><span class="n">buffer_appendf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>

<span class="w">  </span><span class="k">default</span><span class="o">:</span>
<span class="w">    </span><span class="n">buffer_appendf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[Unknown consttype oid: %d]&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cnst</span><span class="o">-&gt;</span><span class="n">consttype</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Rebuild and reinstall the extension, and restart Postgres. Re-run the
<code>test.sql</code> script. Check the Postgres server logs and you should see:</p>
<div class="highlight"><pre><span></span><span class="go">2023-11-19 19:53:47.922 GMT [3253746] LOG:  [pgexec] SELECT [columns todo] FROM x WHERE [Unknown: 6] &gt; 1</span>
<span class="go">2023-11-19 19:53:47.922 GMT [3253746] STATEMENT:  SELECT a FROM x WHERE a &gt; 1;</span>
</pre></div>
<p>Great! Now we just have to tackle <code>T_Var</code>.</p>
<h3 id="walking-<code>var</code>">Walking <code>Var</code></h3><p>Let's take a look at the definition of <a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/include/nodes/primnodes.h#L233"><code>Var</code></a>:</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Var</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Expr</span><span class="w">        </span><span class="n">xpr</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * index of this var&#39;s relation in the range table, or</span>
<span class="cm">     * INNER_VAR/OUTER_VAR/etc</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">varno</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * attribute number of this var, or zero for all attrs (&quot;whole-row Var&quot;)</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">AttrNumber</span><span class="w">  </span><span class="n">varattno</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* pg_type OID for the type of this var */</span>
<span class="w">    </span><span class="n">Oid</span><span class="w">         </span><span class="n">vartype</span><span class="w"> </span><span class="n">pg_node_attr</span><span class="p">(</span><span class="n">query_jumble_ignore</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* pg_attribute typmod value */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">       </span><span class="n">vartypmod</span><span class="w"> </span><span class="n">pg_node_attr</span><span class="p">(</span><span class="n">query_jumble_ignore</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* OID of collation, or InvalidOid if none */</span>
<span class="w">    </span><span class="n">Oid</span><span class="w">         </span><span class="n">varcollid</span><span class="w"> </span><span class="n">pg_node_attr</span><span class="p">(</span><span class="n">query_jumble_ignore</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * RT indexes of outer joins that can replace the Var&#39;s value with null.</span>
<span class="cm">     * We can omit varnullingrels in the query jumble, because it&#39;s fully</span>
<span class="cm">     * determined by varno/varlevelsup plus the Var&#39;s query location.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">Bitmapset</span><span class="w">  </span><span class="o">*</span><span class="n">varnullingrels</span><span class="w"> </span><span class="n">pg_node_attr</span><span class="p">(</span><span class="n">query_jumble_ignore</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * for subquery variables referencing outer relations; 0 in a normal var,</span>
<span class="cm">     * &gt;0 means N levels up</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">Index</span><span class="w">       </span><span class="n">varlevelsup</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * varnosyn/varattnosyn are ignored for equality, because Vars with</span>
<span class="cm">     * different syntactic identifiers are semantically the same as long as</span>
<span class="cm">     * their varno/varattno match.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="cm">/* syntactic relation index (0 if unknown) */</span>
<span class="w">    </span><span class="n">Index</span><span class="w">       </span><span class="n">varnosyn</span><span class="w"> </span><span class="n">pg_node_attr</span><span class="p">(</span><span class="n">equal_ignore</span><span class="p">,</span><span class="w"> </span><span class="n">query_jumble_ignore</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* syntactic attribute number */</span>
<span class="w">    </span><span class="n">AttrNumber</span><span class="w">  </span><span class="n">varattnosyn</span><span class="w"> </span><span class="n">pg_node_attr</span><span class="p">(</span><span class="n">equal_ignore</span><span class="p">,</span><span class="w"> </span><span class="n">query_jumble_ignore</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* token location, or -1 if unknown */</span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">location</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">Var</span><span class="p">;</span>
</pre></div>
<p>It looks like this refers to a relation in the range table list
again. So this means we need to have access to the full <code>PlannedStmt</code>
so we can read its <code>rtable</code> field again to find the table. Then we
need to look up the <code>Relation</code> for the table and then we can use the
<code>Var</code>'s <code>varattno</code> field to pick the nth attribute from the relation
and get its string representation.</p>
<p>However, ChatGPT found a slightly higher-level function:
<a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/backend/utils/cache/lsyscache.c#L826"><code>get_attname()</code></a>
that takes a relation <code>Oid</code> and an attribute index and returns the
string name of the column.</p>
<p>So here's what <code>buffer_print_var</code> looks like:</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_var</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">PlannedStmt</span><span class="o">*</span><span class="w"> </span><span class="n">stmt</span><span class="p">,</span><span class="w"> </span><span class="n">Var</span><span class="o">*</span><span class="w"> </span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="n">RangeTblEntry</span><span class="o">*</span><span class="w"> </span><span class="n">rte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list_nth</span><span class="p">(</span><span class="n">stmt</span><span class="o">-&gt;</span><span class="n">rtable</span><span class="p">,</span><span class="w"> </span><span class="n">var</span><span class="o">-&gt;</span><span class="n">varno</span><span class="mi">-1</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">rtekind</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">RTE_RELATION</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">elog</span><span class="p">(</span><span class="n">LOG</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[Unsupported relation type for var: %d].&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">rtekind</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_attname</span><span class="p">(</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">relid</span><span class="p">,</span><span class="w"> </span><span class="n">var</span><span class="o">-&gt;</span><span class="n">varattno</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">  </span><span class="n">buffer_appendz</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span>
<span class="w">  </span><span class="n">pfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>You'll also need to add another <code>#include</code> for <code>utils/lsyscache.h</code>.</p>
<p>Let's add the <code>case T_Var:</code> check in <code>buffer_print_expr</code>, and also
feed the <code>PlannedStmt*</code> through all the necessary <code>buffer_print_X</code>
functions:</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_expr</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">PlannedStmt</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">*</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_list</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">PlannedStmt</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">List</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="p">);</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_opexpr</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">PlannedStmt</span><span class="o">*</span><span class="w"> </span><span class="n">stmt</span><span class="p">,</span><span class="w"> </span><span class="n">OpExpr</span><span class="o">*</span><span class="w"> </span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">HeapTuple</span><span class="w"> </span><span class="n">opertup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SearchSysCache1</span><span class="p">(</span><span class="n">OPEROID</span><span class="p">,</span><span class="w"> </span><span class="n">ObjectIdGetDatum</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">opno</span><span class="p">));</span>

<span class="w">  </span><span class="n">buffer_print_expr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">stmt</span><span class="p">,</span><span class="w"> </span><span class="n">lfirst</span><span class="p">(</span><span class="n">list_nth_cell</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)));</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">HeapTupleIsValid</span><span class="p">(</span><span class="n">opertup</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Form_pg_operator</span><span class="w"> </span><span class="n">operator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Form_pg_operator</span><span class="p">)</span><span class="n">GETSTRUCT</span><span class="p">(</span><span class="n">opertup</span><span class="p">);</span>
<span class="w">    </span><span class="n">buffer_appendf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; %s &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">NameStr</span><span class="p">(</span><span class="n">operator</span><span class="o">-&gt;</span><span class="n">oprname</span><span class="p">));</span>
<span class="w">    </span><span class="n">ReleaseSysCache</span><span class="p">(</span><span class="n">opertup</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">buffer_appendf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[Unknown operation: %d]&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">op</span><span class="o">-&gt;</span><span class="n">opno</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// TODO: Support single operand operations.</span>
<span class="w">  </span><span class="n">buffer_print_expr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">stmt</span><span class="p">,</span><span class="w"> </span><span class="n">lfirst</span><span class="p">(</span><span class="n">list_nth_cell</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_const</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">Const</span><span class="o">*</span><span class="w"> </span><span class="n">cnst</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">cnst</span><span class="o">-&gt;</span><span class="n">consttype</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">INT4OID</span><span class="p">:</span>
<span class="w">    </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DatumGetInt32</span><span class="p">(</span><span class="n">cnst</span><span class="o">-&gt;</span><span class="n">constvalue</span><span class="p">);</span>
<span class="w">    </span><span class="n">buffer_appendf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>

<span class="w">  </span><span class="k">default</span><span class="o">:</span>
<span class="w">    </span><span class="n">buffer_appendf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[Unknown consttype oid: %d]&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cnst</span><span class="o">-&gt;</span><span class="n">consttype</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_var</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">PlannedStmt</span><span class="o">*</span><span class="w"> </span><span class="n">stmt</span><span class="p">,</span><span class="w"> </span><span class="n">Var</span><span class="o">*</span><span class="w"> </span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="n">RangeTblEntry</span><span class="o">*</span><span class="w"> </span><span class="n">rte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list_nth</span><span class="p">(</span><span class="n">stmt</span><span class="o">-&gt;</span><span class="n">rtable</span><span class="p">,</span><span class="w"> </span><span class="n">var</span><span class="o">-&gt;</span><span class="n">varno</span><span class="mi">-1</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">rtekind</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">RTE_RELATION</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">elog</span><span class="p">(</span><span class="n">LOG</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[Unsupported relation type for var: %d].&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">rtekind</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_attname</span><span class="p">(</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">relid</span><span class="p">,</span><span class="w"> </span><span class="n">var</span><span class="o">-&gt;</span><span class="n">varattno</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">  </span><span class="n">buffer_appendz</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span>
<span class="w">  </span><span class="n">pfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_expr</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">PlannedStmt</span><span class="o">*</span><span class="w"> </span><span class="n">stmt</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">expr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">nodeTag</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">T_Const</span><span class="p">:</span>
<span class="w">    </span><span class="n">buffer_print_const</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Const</span><span class="o">*</span><span class="p">)</span><span class="n">expr</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>

<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">T_Var</span><span class="p">:</span>
<span class="w">    </span><span class="n">buffer_print_var</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">stmt</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Var</span><span class="o">*</span><span class="p">)</span><span class="n">expr</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>

<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">T_OpExpr</span><span class="p">:</span>
<span class="w">    </span><span class="n">buffer_print_opexpr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">stmt</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">OpExpr</span><span class="o">*</span><span class="p">)</span><span class="n">expr</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>

<span class="w">  </span><span class="k">default</span><span class="o">:</span>
<span class="w">    </span><span class="n">buffer_appendf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[Unknown: %d]&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">nodeTag</span><span class="p">(</span><span class="n">expr</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_list</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">PlannedStmt</span><span class="o">*</span><span class="w"> </span><span class="n">stmt</span><span class="p">,</span><span class="w"> </span><span class="n">List</span><span class="o">*</span><span class="w"> </span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">sep</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ListCell</span><span class="o">*</span><span class="w"> </span><span class="n">cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">  </span><span class="n">foreach</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span><span class="w"> </span><span class="n">list</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">buffer_appendz</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">sep</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="n">buffer_print_expr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">stmt</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">)</span><span class="n">lfirst</span><span class="p">(</span><span class="n">cell</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_where</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">QueryDesc</span><span class="o">*</span><span class="w"> </span><span class="n">queryDesc</span><span class="p">,</span><span class="w"> </span><span class="n">Plan</span><span class="o">*</span><span class="w"> </span><span class="n">plan</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">qual</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">buffer_appendz</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; WHERE &quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">buffer_print_list</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">queryDesc</span><span class="o">-&gt;</span><span class="n">plannedstmt</span><span class="p">,</span><span class="w"> </span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">qual</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; AND &quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>Rebuild and reinstall the extension, and restart Postgres. Re-run the
<code>test.sql</code> script. Check the Postgres server logs and you should see:</p>
<div class="highlight"><pre><span></span><span class="go">2023-11-19 20:03:14.351 GMT [3254458] LOG:  [pgexec] SELECT [columns todo] FROM x WHERE a &gt; 1</span>
<span class="go">2023-11-19 20:03:14.351 GMT [3254458] STATEMENT:  SELECT a FROM x WHERE a &gt; 1;</span>
</pre></div>
<p>Huzzah!</p>
<h3 id="walking-the-column-list">Walking the column list</h3><p>Let's get rid of <code>[columns todo]</code>. We already had the idea that <code>List*
targetlist</code> on the <code>Plan</code> struct was a list of expression
<code>Node</code>s. Let's try it.</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_select_columns</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">QueryDesc</span><span class="o">*</span><span class="w"> </span><span class="n">queryDesc</span><span class="p">,</span><span class="w"> </span><span class="n">Plan</span><span class="o">*</span><span class="w"> </span><span class="n">plan</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">targetlist</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">buffer_print_list</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">queryDesc</span><span class="o">-&gt;</span><span class="n">plannedstmt</span><span class="p">,</span><span class="w"> </span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">targetlist</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>Rebuild and reinstall the extension, and restart Postgres. Re-run the
<code>test.sql</code> script. Check the Postgres server logs and you should see:</p>
<div class="highlight"><pre><span></span><span class="go">2023-11-19 20:12:48.091 GMT [3255398] LOG:  [pgexec] SELECT [Unknown: 53] FROM x WHERE a &gt; 1</span>
<span class="go">2023-11-19 20:12:48.091 GMT [3255398] STATEMENT:  SELECT a FROM x WHERE a &gt; 1;</span>
</pre></div>
<p>Hmm. Let's look up <code>Node</code> <code>53</code> in Postgres:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>grep<span class="w"> </span><span class="s1">&#39; = 53,&#39;</span><span class="w"> </span>src/include/nodes/nodetags.h
<span class="go">        T_TargetEntry = 53,</span>
</pre></div>
<p>Based on the definition of
<a href="https://github.com/postgres/postgres/blob/b218fbb7a35fcf31539bfad12732038fe082a2eb/src/include/nodes/primnodes.h#L1918"><code>TargetEntry</code></a>,
it looks like we can ignore most of the fields (because we don't need
to handle <code>SELECT a AS b</code> yet) and just proxy the child <code>expr</code> field.</p>
<p>Let's add a <code>case T_TargetEntry</code> to <code>buffer_print_expr</code>:</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_print_expr</span><span class="p">(</span><span class="n">PGExec_Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">PlannedStmt</span><span class="o">*</span><span class="w"> </span><span class="n">stmt</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">expr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">nodeTag</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">T_Const</span><span class="p">:</span>
<span class="w">    </span><span class="n">buffer_print_const</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Const</span><span class="o">*</span><span class="p">)</span><span class="n">expr</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>

<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">T_Var</span><span class="p">:</span>
<span class="w">    </span><span class="n">buffer_print_var</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">stmt</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Var</span><span class="o">*</span><span class="p">)</span><span class="n">expr</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>

<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">T_TargetEntry</span><span class="p">:</span>
<span class="w">    </span><span class="n">buffer_print_expr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">stmt</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">)((</span><span class="n">TargetEntry</span><span class="o">*</span><span class="p">)</span><span class="n">expr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">expr</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>

<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">T_OpExpr</span><span class="p">:</span>
<span class="w">    </span><span class="n">buffer_print_opexpr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">stmt</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">OpExpr</span><span class="o">*</span><span class="p">)</span><span class="n">expr</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>

<span class="w">  </span><span class="k">default</span><span class="o">:</span>
<span class="w">    </span><span class="n">buffer_appendf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[Unknown: %d]&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">nodeTag</span><span class="p">(</span><span class="n">expr</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Rebuild and reinstall the extension, and restart Postgres. Re-run the
<code>test.sql</code> script. Check the Postgres server logs and:</p>
<div class="highlight"><pre><span></span><span class="go">2023-11-19 20:17:51.114 GMT [3257827] LOG:  [pgexec] SELECT a FROM x WHERE a &gt; 1</span>
<span class="go">2023-11-19 20:17:51.114 GMT [3257827] STATEMENT:  SELECT a FROM x WHERE a &gt; 1;</span>
</pre></div>
<p>We did it!</p>
<h3 id="variations">Variations</h3><p>Let's try out some other queries to make sure this wasn't just luck.</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>/usr/local/pgsql/bin/psql<span class="w"> </span>-h<span class="w"> </span>localhost<span class="w"> </span>postgres<span class="w"> </span>-c<span class="w"> </span><span class="s1">&#39;SELECT a + 1 FROM x&#39;</span>
<span class="go"> ?column?</span>
<span class="go">----------</span>
<span class="go">      310</span>
<span class="gp gp-VirtualEnv">(1 row)</span>

<span class="gp">$ </span>/usr/local/pgsql/bin/psql<span class="w"> </span>-h<span class="w"> </span>localhost<span class="w"> </span>postgres<span class="w"> </span>-c<span class="w"> </span><span class="s1">&#39;SELECT a + 1 FROM x WHERE 2 &gt; a&#39;</span>
<span class="go"> ?column?</span>
<span class="go">----------</span>
<span class="gp gp-VirtualEnv">(0 rows)</span>
</pre></div>
<p>And back in the Postgres server logs:</p>
<div class="highlight"><pre><span></span><span class="go">2023-11-19 20:19:28.057 GMT [3257874] LOG:  [pgexec] SELECT a + 1 FROM x</span>
<span class="go">2023-11-19 20:19:28.057 GMT [3257874] STATEMENT:  SELECT a + 1 FROM x</span>
<span class="go">2023-11-19 20:19:30.474 GMT [3257878] LOG:  [pgexec] SELECT a + 1 FROM x WHERE 2 &gt; a</span>
<span class="go">2023-11-19 20:19:30.474 GMT [3257878] STATEMENT:  SELECT a + 1 FROM x WHERE 2 &gt; a</span>
</pre></div>
<p>Not bad!</p>
<h3 id="next-steps">Next steps</h3><p>Printing out the statement here isn't incredibly useful. But it
establishes a basis for future work that might avoid Postgres's query
execution engine and do the execution ourselves, or to proxy execution
to another system.</p>
<h3 id="postscript:-on-chatgpt">Postscript: On ChatGPT</h3><p>My recent Postgres explorations would have been basically impossible
if it weren't for being able to ask ChatGPT simple, stupid questions
like "How do I get from a Postgres <code>Var</code> to a column name".</p>
<p>It isn't always right. It doesn't always give great code. Actually, it
normally gives pretty weird code. But it's been extremely useful for
quick iteration when I get stuck.</p>
<p>The only other place the information exists is in small blog posts
around the internet, the Postgres mailing lists (that so far for me
hasn't been super responsive), and the code itself.</p>
<p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">I&#39;ve been on a Postgres roll. Let&#39;s dig into interpreting a Postgres query plan in preparation for future work on completely diverting the flow of Postgres query execution using execution hooks!<a href="https://t.co/EZrgoIiTuX">https://t.co/EZrgoIiTuX</a> <a href="https://t.co/7S6d6olPX8">pic.twitter.com/7S6d6olPX8</a></p>&mdash; Phil Eaton (@eatonphil) <a href="https://twitter.com/eatonphil/status/1726336428626587710?ref_src=twsrc%5Etfw">November 19, 2023</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>
<style>.feedback{display:initial;}</style>
	</div>
	<div class="feedback">
	  <h4>Feedback</h4>
	  <p>As always,
	      please <a href="mailto:phil@eatonphil.com">email</a>
	      or <a href="https://twitter.com/eatonphil">tweet me</a>
	      with questions, corrections, or ideas!</p>

	</div>
      </div>
    </div>
    <footer>
      <div class="container">
	<div>
	  <div id="subscribe">
	    <iframe frameBorder="0" src="https://cdn.forms-content-1.sg-form.com/e8ed4c3b-dd46-11f0-b6e6-ce075f2c5f80"/>

	  </div>
	</div>
      </div>
    </footer>
  </body>
</html>
