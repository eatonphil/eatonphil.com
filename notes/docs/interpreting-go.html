<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="canonical" href="https://notes.eatonphil.com/interpreting-go.html">
    <title>Interpreting Go | notes.eatonphil.com</title>
    <meta name="description" content="Interpreting Go" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono">
  </head>
  <body>
    <header>
      <div class="lfw">
	<div class="container">
	  <div class="row">
	    <a href="https://eatonphil.com/2025-holiday-fundraiser.html">2025 Holiday Fundraiser</a>
	  </div>
	</div>
      </div>
      <div class="container">
        <div>
          <div class="row">
	    <div>
	      <a href="https://eatonphil.com" class="sm-link">
		Home
              </a>
	      <a href="/" class="sm-link">
		Blog
              </a>
	      <a href="/rss.xml" class="sm-link">
		RSS
              </a>
	    </div>

	    <div class="subscribe">
	      <!-- <a href="https://eatonphil.com/hire-me.html">Hire me</a> -->
	      <!--
		  Hardcode link to home page because some pages don't
		  have a subscribe box. Some pages hide the subscribe.
		-->
	      <a href="https://eatonphil.com/subscribe.html">
		Subscribe
	      </a>
            </div>
	  </div>
	  <hr />
	  <div class="">
            <h2>October 12, 2019</h2>
            <h1>Interpreting Go</h1>
	    
            <div class="row" style="padding-bottom: 5px">
              <div class="tags"><a href="/tags/go.html" class="tag">go</a><a href="/tags/interpreters.html" class="tag">interpreters</a><a href="/tags/parsing.html" class="tag">parsing</a></div>
            </div>
	  </div>
	</div>
      </div>
    </header>
    <div class="container">
      <div class="col-6">
	<div class="post">
          <p>After spending some time at work on tooling for keeping documentation
in sync with Go struct definitions I had enough exposure to Go's
built-in parsing package that next steps were clear: write an
interpreter. <a href="http://notes.eatonphil.com/interpreting-typescript.html">It's a great way to get more comfortable with a
language's
AST.</a></p>
<p>In this post we'll use the Go parser package to interpret the AST
directly (as opposed to compiling to a bytecode VM) with enough to
support a recursive implementation of the fibonacci algorithm:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">fib</span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">fib</span><span class="p">(</span><span class="nx">a</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">fib</span><span class="p">(</span><span class="nx">a</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nb">println</span><span class="p">(</span><span class="nx">fib</span><span class="p">(</span><span class="mi">15</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
<p class="note">
  You'll note this isn't actually valid Go because we are using an
  undefined function <code>println</code>. We'll provide that for the
  runtime to make things easier on ourselves.
</p><p>The fibonacci algorithm is my goto minimal program that forces us to
deal with basic aspects of:</p>
<ul>
<li>Function definitions</li>
<li>Function calls</li>
<li>Function arguments</li>
<li>Function return values</li>
<li>If/else</li>
<li>Assignment</li>
<li>Arithmetic and boolean operators</li>
</ul>
<p>We'll do this in around 200 LoC. Project code is available on
<a href="https://github.com/eatonphil/goi">Github</a>.</p>
<p>A follow-up post will cover support for an iterative fibonacci
implementation with support for basic aspects of:</p>
<ul>
<li>Local variables</li>
<li>Loops</li>
</ul>
<h3 id="first-steps">First steps</h3><p>I always start exploring an AST by practicing error-driven
development. It's helpful to have the Go
<a href="https://golang.org/pkg/go/ast/">AST</a>,
<a href="https://golang.org/pkg/go/parser/">parser</a>, and
<a href="https://golang.org/pkg/go/token/">token</a> package docs handy as well.</p>
<p>We'll focus on single-file programs and start with
<a href="https://golang.org/pkg/go/parser/#ParseFile">parser.ParseFile</a>. This
function will return an
<a href="https://golang.org/pkg/go/ast/#File">*ast.File</a>. This in turn
contains a list of
<a href="https://golang.org/pkg/go/ast/#Decl">Decl</a>s. Unfortunately Go stops
being helpful at this point because we have no clue what is going to
implement this <code>Decl</code> interface. So we'll switch on the
concrete type and error until we know what we need to know.</p>
<div class="highlight"><pre><span></span><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="s">&quot;go/ast&quot;</span>
<span class="w">  </span><span class="s">&quot;go/parser&quot;</span>
<span class="w">  </span><span class="s">&quot;go/token&quot;</span>
<span class="w">  </span><span class="s">&quot;io/ioutil&quot;</span>
<span class="w">  </span><span class="s">&quot;log&quot;</span>
<span class="w">  </span><span class="s">&quot;os&quot;</span>
<span class="w">  </span><span class="s">&quot;reflect&quot;</span>
<span class="p">)</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">interpret</span><span class="p">(</span><span class="nx">f</span><span class="w"> </span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">File</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">decl</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">f</span><span class="p">.</span><span class="nx">Decls</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="nx">d</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">decl</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">default</span><span class="p">:</span>
<span class="w">      </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;Unknown decl type (%s): %+v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span><span class="w"> </span><span class="nx">d</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">fset</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">token</span><span class="p">.</span><span class="nx">NewFileSet</span><span class="p">()</span><span class="w"> </span><span class="c1">// positions are relative to fset</span>

<span class="w">  </span><span class="nx">src</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ioutil</span><span class="p">.</span><span class="nx">ReadFile</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;Unable to read file: %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">())</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nx">f</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parser</span><span class="p">.</span><span class="nx">ParseFile</span><span class="p">(</span><span class="nx">fset</span><span class="p">,</span><span class="w"> </span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="nx">src</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;Unable to parse file: %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">())</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nx">interpret</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>Build and run:</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>go<span class="w"> </span>build<span class="w"> </span>goi.go
$<span class="w"> </span>./goi<span class="w"> </span>fib.go
<span class="m">2019</span>/10/12<span class="w"> </span><span class="m">09</span>:43:48<span class="w"> </span>Unknown<span class="w"> </span>decl<span class="w"> </span><span class="nb">type</span><span class="w"> </span><span class="o">(</span>*ast.FuncDecl<span class="o">)</span>:<span class="w"> </span><span class="p">&amp;</span><span class="o">{</span>Doc:&lt;nil&gt;<span class="w"> </span>Recv:&lt;nil&gt;<span class="w"> </span>Name:fib<span class="w"> </span>Type:0xc000096320<span class="w"> </span>Body:0xc00009a3c0<span class="o">}</span>
</pre></div>
<p>Cool! This is the declaration of the <code>fib</code> function and its
type is <a href="https://golang.org/pkg/go/ast/#FuncDecl">*ast.FuncDecl</a>.</p>
<h3 id="interpreting-ast.funcdecl">Interpreting ast.FuncDecl</h3><p>A function declaration is going to need to add its name to a context
map, mapped to a function reference for use in function calls. Since
Go throws everything into the same context namespace this we can
simply pass around a map of strings to <code>value</code>s where a
<code>value</code> can be any Go value. To facilitate this, we'll
define a <code>value</code> struct to hold an integer to represent
"kind" and an empty interface "value". When a value is referenced it
will have to switch on the "kind" and then cast the "value".</p>
<p>Additionally, and unlike a value-oriented language like Scheme, we'll
need to track a set of <code>return</code> values at all stages
through interpretation so, when set, we can short circuit execution.</p>
<div class="highlight"><pre><span></span><span class="kd">type</span><span class="w"> </span><span class="nx">kind</span><span class="w"> </span><span class="kt">uint</span>

<span class="kd">const</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="nx">i64</span><span class="w"> </span><span class="nx">kind</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">iota</span>
<span class="w">  </span><span class="nx">fn</span>
<span class="w">  </span><span class="nx">bl</span>
<span class="p">)</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">kind</span><span class="w">  </span><span class="nx">kind</span>
<span class="w">  </span><span class="nx">value</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">context</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">value</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="nx">context</span><span class="p">)</span><span class="w"> </span><span class="nb">copy</span><span class="p">()</span><span class="w"> </span><span class="nx">context</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">cpy</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">context</span><span class="p">{}</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">cpy</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">value</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">cpy</span>
<span class="p">}</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">ret</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">set</span><span class="w"> </span><span class="kt">bool</span>
<span class="w">  </span><span class="nx">vs</span><span class="w">  </span><span class="p">[]</span><span class="nx">value</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">)</span><span class="w"> </span><span class="nx">setValues</span><span class="p">(</span><span class="nx">vs</span><span class="w"> </span><span class="p">[]</span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">r</span><span class="p">.</span><span class="nx">vs</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">vs</span>
<span class="w">  </span><span class="nx">r</span><span class="p">.</span><span class="nx">set</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">interpretFuncDecl</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">,</span><span class="w"> </span><span class="nx">fd</span><span class="w"> </span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">FuncDecl</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">ctx</span><span class="p">[</span><span class="nx">fd</span><span class="p">.</span><span class="nx">Name</span><span class="p">.</span><span class="nx">String</span><span class="p">()]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">value</span><span class="p">{</span>
<span class="w">    </span><span class="nx">fn</span><span class="p">,</span>
<span class="w">    </span><span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">,</span><span class="w"> </span><span class="nx">args</span><span class="w"> </span><span class="p">[]</span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="p">{},</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">interpret</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">f</span><span class="w"> </span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">File</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">decl</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">f</span><span class="p">.</span><span class="nx">Decls</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="nx">d</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">decl</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">FuncDecl</span><span class="p">:</span>
<span class="w">      </span><span class="nx">interpretFuncDecl</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">d</span><span class="p">)</span>
<span class="w">    </span><span class="k">default</span><span class="p">:</span>
<span class="w">      </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;Unknown decl type (%s): %+v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span><span class="w"> </span><span class="nx">d</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Now that we have the idea of return management and contexts set out,
let's fill out the actual function declaration callback. Inside we'll
need to copy the context so variables declared inside the function
are not visible outside. Then we'll iterate over the parameters and
map them in context to the associated argument. Finally we'll
interpret the body.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">interpretBlockStmt</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">,</span><span class="w"> </span><span class="nx">fd</span><span class="w"> </span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">BlockStmt</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">interpretFuncDecl</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">,</span><span class="w"> </span><span class="nx">fd</span><span class="w"> </span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">FuncDecl</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">ctx</span><span class="p">[</span><span class="nx">fd</span><span class="p">.</span><span class="nx">Name</span><span class="p">.</span><span class="nx">String</span><span class="p">()]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">value</span><span class="p">{</span>
<span class="w">    </span><span class="nx">fn</span><span class="p">,</span>
<span class="w">    </span><span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">,</span><span class="w"> </span><span class="nx">args</span><span class="w"> </span><span class="p">[]</span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">childCtx</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ctx</span><span class="p">.</span><span class="nb">copy</span><span class="p">()</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">param</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">fd</span><span class="p">.</span><span class="nx">Type</span><span class="p">.</span><span class="nx">Params</span><span class="p">.</span><span class="nx">List</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">childCtx</span><span class="p">[</span><span class="nx">param</span><span class="p">.</span><span class="nx">Names</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">String</span><span class="p">()]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">args</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="nx">interpretBlockStmt</span><span class="p">(</span><span class="nx">childCtx</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="nx">fd</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>And we'll add a call to the interpreted <code>main</code> to the end
of the interpreter's <code>main</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">fset</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">token</span><span class="p">.</span><span class="nx">NewFileSet</span><span class="p">()</span><span class="w"> </span><span class="c1">// positions are relative to fset</span>

<span class="w">  </span><span class="nx">src</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ioutil</span><span class="p">.</span><span class="nx">ReadFile</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;Unable to read file: %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">())</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nx">f</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">parser</span><span class="p">.</span><span class="nx">ParseFile</span><span class="p">(</span><span class="nx">fset</span><span class="p">,</span><span class="w"> </span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="nx">src</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;Unable to parse file: %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">())</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nx">ctx</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">context</span><span class="p">{}</span>
<span class="w">  </span><span class="nx">interpret</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="nx">f</span><span class="p">)</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="nx">ret</span>
<span class="w">  </span><span class="nx">ctx</span><span class="p">[</span><span class="s">&quot;main&quot;</span><span class="p">].</span><span class="nx">value</span><span class="p">.(</span><span class="kd">func</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">,</span><span class="w"> </span><span class="p">[]</span><span class="nx">value</span><span class="p">))(</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="p">[]</span><span class="nx">value</span><span class="p">{})</span>
<span class="p">}</span>
</pre></div>
<p>Next step!</p>
<h3 id="interpreting-ast.blockstmt">Interpreting ast.BlockStmt</h3><p>For this AST node, we'll iterate over each statement and interpret
it. If the return value has been set we'll execute the loop to
short circuit execution.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">interpretStmt</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">,</span><span class="w"> </span><span class="nx">stmt</span><span class="w"> </span><span class="nx">ast</span><span class="p">.</span><span class="nx">Stmt</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">interpretBlockStmt</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">,</span><span class="w"> </span><span class="nx">bs</span><span class="w"> </span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">BlockStmt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">stmt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">bs</span><span class="p">.</span><span class="nx">List</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">interpretStmt</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="nx">stmt</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">r</span><span class="p">.</span><span class="nx">set</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Next step!</p>
<h3 id="interpreting-ast.stmt">Interpreting ast.Stmt</h3><p>Since <a href="https://golang.org/pkg/go/ast/#Stmt">ast.Stmt</a> is another
interface, we're back to error-driven development.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">interpretStmt</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">,</span><span class="w"> </span><span class="nx">stmt</span><span class="w"> </span><span class="nx">ast</span><span class="p">.</span><span class="nx">Stmt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="nx">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">stmt</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">default</span><span class="p">:</span>
<span class="w">    </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;Unknown stmt type (%s): %+v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span><span class="w"> </span><span class="nx">s</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>And the trigger:</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>go<span class="w"> </span>build<span class="w"> </span>goi.go
$<span class="w"> </span>./goi<span class="w"> </span>fib.go
<span class="m">2019</span>/10/12<span class="w"> </span><span class="m">10</span>:15:14<span class="w"> </span>Unknown<span class="w"> </span>stmt<span class="w"> </span><span class="nb">type</span><span class="w"> </span><span class="o">(</span>*ast.ExprStmt<span class="o">)</span>:<span class="w"> </span><span class="p">&amp;</span><span class="o">{</span>X:0xc0000a02c0<span class="o">}</span>
</pre></div>
<p>Great! Checking the docs on
<a href="https://golang.org/pkg/go/ast/#ExprStmt">ast.ExprStmt</a> we'll just
skip directly to a call to a new function <code>interpretExpr</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">interpretExpr</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">,</span><span class="w"> </span><span class="nx">expr</span><span class="w"> </span><span class="nx">ast</span><span class="p">.</span><span class="nx">Expr</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">interpretStmt</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">,</span><span class="w"> </span><span class="nx">stmt</span><span class="w"> </span><span class="nx">ast</span><span class="p">.</span><span class="nx">Stmt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="nx">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">stmt</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">ExprStmt</span><span class="p">:</span>
<span class="w">    </span><span class="nx">interpretExpr</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="nx">s</span><span class="p">.</span><span class="nx">X</span><span class="p">)</span>
<span class="w">  </span><span class="k">default</span><span class="p">:</span>
<span class="w">    </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;Unknown stmt type (%s): %+v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span><span class="w"> </span><span class="nx">s</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Moving on!</p>
<h3 id="interpreting-ast.expr">Interpreting ast.Expr</h3><p>We've got another
<a href="https://golang.org/pkg/go/ast/#Expr">interface</a>. Let's error!</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">interpretExpr</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">,</span><span class="w"> </span><span class="nx">expr</span><span class="w"> </span><span class="nx">ast</span><span class="p">.</span><span class="nx">Expr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="nx">e</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">expr</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">default</span><span class="p">:</span>
<span class="w">    </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;Unknown expr type (%s): %+v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">e</span><span class="p">),</span><span class="w"> </span><span class="nx">e</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>And the trigger:</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>go<span class="w"> </span>build<span class="w"> </span>goi.go
$<span class="w"> </span>./goi<span class="w"> </span>fib.go
<span class="m">2019</span>/10/12<span class="w"> </span><span class="m">10</span>:19:16<span class="w"> </span>Unknown<span class="w"> </span>expr<span class="w"> </span><span class="nb">type</span><span class="w"> </span><span class="o">(</span>*ast.CallExpr<span class="o">)</span>:<span class="w"> </span><span class="p">&amp;</span><span class="o">{</span>Fun:println<span class="w"> </span>Lparen:146<span class="w"> </span>Args:<span class="o">[</span>0xc0000a2280<span class="o">]</span><span class="w"> </span>Ellipsis:0<span class="w"> </span>Rparen:154<span class="o">}</span>
</pre></div>
<p>Cool! For a call we'll evaluate the arguments, evaluate the function
expression itself, cast the resulting value to a function, and call
it.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">interpretCallExpr</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">,</span><span class="w"> </span><span class="nx">ce</span><span class="w"> </span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">CallExpr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">fnr</span><span class="w"> </span><span class="nx">ret</span>
<span class="w">  </span><span class="nx">interpretExpr</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">fnr</span><span class="p">,</span><span class="w"> </span><span class="nx">ce</span><span class="p">.</span><span class="nx">Fun</span><span class="p">)</span>
<span class="w">  </span><span class="nx">fn</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">fnr</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="w">  </span><span class="nx">values</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="nx">value</span><span class="p">{}</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">arg</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">ce</span><span class="p">.</span><span class="nx">Args</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">vr</span><span class="w"> </span><span class="nx">ret</span>
<span class="w">    </span><span class="nx">interpretExpr</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">vr</span><span class="p">,</span><span class="w"> </span><span class="nx">arg</span><span class="p">)</span>
<span class="w">    </span><span class="nx">values</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">values</span><span class="p">,</span><span class="w"> </span><span class="nx">vr</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nx">fn</span><span class="p">.</span><span class="nx">value</span><span class="p">.(</span><span class="kd">func</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">,</span><span class="w"> </span><span class="p">[]</span><span class="nx">value</span><span class="p">))(</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="nx">values</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p class="note">
  All of this casting is unsafe because we aren't doing a
  type-checking stage. But we can ignore this because if a
  type-checking stage were introduced (which it need to be at some
  point), it would prevent bad casts from happening.
</p><h3 id="handling-more-ast.expr-implementations">Handling more ast.Expr implementations</h3><p>Let's give the interpreter a shot again:</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>go<span class="w"> </span>build<span class="w"> </span>goi.go
$<span class="w"> </span>./goi<span class="w"> </span>fib.go
<span class="m">2019</span>/10/12<span class="w"> </span><span class="m">10</span>:28:17<span class="w"> </span>Unknown<span class="w"> </span>expr<span class="w"> </span><span class="nb">type</span><span class="w"> </span><span class="o">(</span>*ast.Ident<span class="o">)</span>:<span class="w"> </span>println
</pre></div>
<p>We'll need to add <a href="https://golang.org/pkg/go/ast/#Ident">ast.Ident</a>
support to <code>interpretCallExpr</code>. This will be a simple
lookup in context. We'll also add a <code>setValue</code> helper since
the <code>ret</code> value is serving double-duty as a value passing
mechanism and also a function's return value (solely where multiple
value are a thing).</p>
<div class="highlight"><pre><span></span><span class="o">...</span>


<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">)</span><span class="w"> </span><span class="nx">setValue</span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">r</span><span class="p">.</span><span class="nx">values</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[]</span><span class="nx">value</span><span class="p">{</span><span class="nx">v</span><span class="p">}</span>
<span class="w">  </span><span class="nx">r</span><span class="p">.</span><span class="nx">set</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">true</span>
<span class="p">}</span>

<span class="o">...</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">interpretExpr</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">,</span><span class="w"> </span><span class="nx">expr</span><span class="w"> </span><span class="nx">ast</span><span class="p">.</span><span class="nx">Expr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="nx">e</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">expr</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">CallExpr</span><span class="p">:</span>
<span class="w">    </span><span class="nx">interpretCallExpr</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="nx">e</span><span class="p">)</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">Ident</span><span class="p">:</span>
<span class="w">    </span><span class="nx">r</span><span class="p">.</span><span class="nx">setValue</span><span class="p">(</span><span class="nx">ctx</span><span class="p">[</span><span class="nx">e</span><span class="p">.</span><span class="nx">Name</span><span class="p">])</span>
<span class="w">  </span><span class="k">default</span><span class="p">:</span>
<span class="w">    </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;Unknown expr type (%s): %+v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">e</span><span class="p">),</span><span class="w"> </span><span class="nx">e</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>This is also a good time to add the <code>println</code> builtin to
our top-level context.</p>
<div class="highlight"><pre><span></span><span class="k">func</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">...</span>

<span class="w">  </span><span class="n">ctx</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">{}</span>
<span class="w">  </span><span class="n">interpret</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span>
<span class="w">  </span><span class="n">ctx</span><span class="p">[</span><span class="s2">&quot;println&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">{</span>
<span class="w">    </span><span class="n">fn</span><span class="p">,</span>
<span class="w">    </span><span class="k">func</span><span class="p">(</span><span class="n">ctx</span><span class="w"> </span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="p">[]</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">var</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="p">[]</span><span class="n">interface</span><span class="p">{}</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="nb">range</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">values</span><span class="o">...</span><span class="p">)</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">var</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">ret</span>
<span class="w">  </span><span class="n">ctx</span><span class="p">[</span><span class="s2">&quot;main&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="p">[]</span><span class="n">value</span><span class="p">))(</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="p">[]</span><span class="n">value</span><span class="p">{})</span>
<span class="p">}</span>
</pre></div>
<h3 id="more-ast.expr-implementations">More ast.Expr implementations</h3><p>Running the interpreter again we get:</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>go<span class="w"> </span>build<span class="w"> </span>goi.go
$<span class="w"> </span>./goi<span class="w"> </span>fib.go
<span class="m">2019</span>/10/12<span class="w"> </span><span class="m">10</span>:41:59<span class="w"> </span>Unknown<span class="w"> </span>expr<span class="w"> </span><span class="nb">type</span><span class="w"> </span><span class="o">(</span>*ast.BasicLit<span class="o">)</span>:<span class="w"> </span><span class="p">&amp;</span><span class="o">{</span>ValuePos:151<span class="w"> </span>Kind:INT<span class="w"> </span>Value:15<span class="o">}</span>
</pre></div>
<p>Easy enough: we'll switch on the "kind" and parse a string int to an
int and wrap it in our value type.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">interpretExpr</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">,</span><span class="w"> </span><span class="nx">expr</span><span class="w"> </span><span class="nx">ast</span><span class="p">.</span><span class="nx">Expr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="nx">e</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">expr</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">CallExpr</span><span class="p">:</span>
<span class="w">    </span><span class="nx">interpretCallExpr</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="nx">e</span><span class="p">)</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">Ident</span><span class="p">:</span>
<span class="w">    </span><span class="nx">r</span><span class="p">.</span><span class="nx">setValue</span><span class="p">(</span><span class="nx">ctx</span><span class="p">[</span><span class="nx">e</span><span class="p">.</span><span class="nx">Name</span><span class="p">])</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">BasicLit</span><span class="p">:</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="nx">e</span><span class="p">.</span><span class="nx">Kind</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nx">token</span><span class="p">.</span><span class="nx">INT</span><span class="p">:</span>
<span class="w">      </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">strconv</span><span class="p">.</span><span class="nx">ParseInt</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span>
<span class="w">      </span><span class="nx">r</span><span class="p">.</span><span class="nx">setValue</span><span class="p">(</span><span class="nx">value</span><span class="p">{</span><span class="nx">i64</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">})</span>
<span class="w">    </span><span class="k">default</span><span class="p">:</span>
<span class="w">      </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;Unknown basiclit type: %+v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">e</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="k">default</span><span class="p">:</span>
<span class="w">    </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;Unknown expr type (%s): %+v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">e</span><span class="p">),</span><span class="w"> </span><span class="nx">e</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Now we run again:</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>go<span class="w"> </span>build<span class="w"> </span>goi.go
$<span class="w"> </span>./goi<span class="w"> </span>fib.go
<span class="m">2019</span>/10/12<span class="w"> </span><span class="m">10</span>:48:46<span class="w"> </span>Unknown<span class="w"> </span>stmt<span class="w"> </span><span class="nb">type</span><span class="w"> </span><span class="o">(</span>*ast.IfStmt<span class="o">)</span>:<span class="w"> </span><span class="p">&amp;</span><span class="o">{</span>If:38<span class="w"> </span>Init:&lt;nil&gt;<span class="w"> </span>Cond:0xc0000ac150<span class="w"> </span>Body:0xc0000ac1b0<span class="w"> </span>Else:&lt;nil&gt;<span class="o">}</span>
</pre></div>
<p>Cool, more control flow!</p>
<h3 id="interpreting-ast.ifstmt">Interpreting ast.IfStmt</h3><p>For <a href="https://golang.org/pkg/go/ast/#IfStmt">ast.IfStmt</a> we interpret
the condition and, depending on the condition, interpret the body or
the else node. In order to make empty else interpreting easier, we'll
also add a nil short-circuit to <code>interpretStmt</code>.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">interpretIfStmt</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">,</span><span class="w"> </span><span class="nx">is</span><span class="w"> </span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">IfStmt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">interpretStmt</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">is</span><span class="p">.</span><span class="nx">Init</span><span class="p">)</span>

<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">cr</span><span class="w"> </span><span class="nx">ret</span>
<span class="w">  </span><span class="nx">interpretExpr</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">cr</span><span class="p">,</span><span class="w"> </span><span class="nx">is</span><span class="p">.</span><span class="nx">Cond</span><span class="p">)</span>
<span class="w">  </span><span class="nx">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">cr</span><span class="p">.</span><span class="nx">valus</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">c</span><span class="p">.</span><span class="nx">value</span><span class="p">.(</span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">interpretBlockStmt</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="nx">is</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nx">interpretStmt</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="nx">is</span><span class="p">.</span><span class="nx">Else</span><span class="p">)</span>
<span class="p">}</span>


<span class="kd">func</span><span class="w"> </span><span class="nx">interpretStmt</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">,</span><span class="w"> </span><span class="nx">stmt</span><span class="w"> </span><span class="nx">ast</span><span class="p">.</span><span class="nx">Stmt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">stmt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="nx">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">stmt</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">IfStmt</span><span class="p">:</span>
<span class="w">    </span><span class="nx">interpretIfStmt</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="nx">s</span><span class="p">)</span>

<span class="w">  </span><span class="o">...</span>
</pre></div>
<p>Let's try it out:</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>go<span class="w"> </span>build<span class="w"> </span>goi.go
$<span class="w"> </span>./goi<span class="w"> </span>fib.go
<span class="m">2019</span>/10/12<span class="w"> </span><span class="m">10</span>:56:28<span class="w"> </span>Unknown<span class="w"> </span>expr<span class="w"> </span><span class="nb">type</span><span class="w"> </span><span class="o">(</span>*ast.BinaryExpr<span class="o">)</span>:<span class="w"> </span><span class="p">&amp;</span><span class="o">{</span>X:a<span class="w"> </span>OpPos:43<span class="w"> </span>Op:<span class="o">==</span><span class="w"> </span>Y:0xc00008a120<span class="o">}</span>
</pre></div>
<p>Great!</p>
<h3 id="interpreting-ast.binaryexpr">Interpreting ast.BinaryExpr</h3><p>An <a href="https://golang.org/pkg/go/ast/#BinaryExpr">ast.BinaryExpr</a> has an
<code>Op</code> field that we'll switch on to decide what operations
to do. We'll interpret the left side and then the right side and
finally perform the operation and return the result. The three binary
operations we use in this program are <code>==</code>, <code>+</code>
and <code>-</code>. We'll look these up in <a href="https://golang.org/pkg/go/token/#Token">go/token
docs</a> to discover the
associated constants.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">interpretBinaryExpr</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">,</span><span class="w"> </span><span class="nx">bexpr</span><span class="w"> </span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">BinaryExpr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">xr</span><span class="p">,</span><span class="w"> </span><span class="nx">yr</span><span class="w"> </span><span class="nx">ret</span>
<span class="w">  </span><span class="nx">interpretExpr</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">xr</span><span class="p">,</span><span class="w"> </span><span class="nx">bexpr</span><span class="p">.</span><span class="nx">X</span><span class="p">)</span>
<span class="w">  </span><span class="nx">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">xr</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="w">  </span><span class="nx">interpretExpr</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">yr</span><span class="p">,</span><span class="w"> </span><span class="nx">bexpr</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="w">  </span><span class="nx">y</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">yr</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="nx">bexpr</span><span class="p">.</span><span class="nx">Op</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="nx">token</span><span class="p">.</span><span class="nx">ADD</span><span class="p">:</span>
<span class="w">    </span><span class="nx">r</span><span class="p">.</span><span class="nx">setValue</span><span class="p">(</span><span class="nx">value</span><span class="p">{</span><span class="nx">i64</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="p">.</span><span class="nx">value</span><span class="p">.(</span><span class="kt">int64</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">y</span><span class="p">.</span><span class="nx">value</span><span class="p">.(</span><span class="kt">int64</span><span class="p">)})</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="nx">token</span><span class="p">.</span><span class="nx">SUB</span><span class="p">:</span>
<span class="w">    </span><span class="nx">r</span><span class="p">.</span><span class="nx">setValue</span><span class="p">(</span><span class="nx">value</span><span class="p">{</span><span class="nx">i64</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="p">.</span><span class="nx">value</span><span class="p">.(</span><span class="kt">int64</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">y</span><span class="p">.</span><span class="nx">value</span><span class="p">.(</span><span class="kt">int64</span><span class="p">)})</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="nx">token</span><span class="p">.</span><span class="nx">EQL</span><span class="p">:</span>
<span class="w">    </span><span class="nx">r</span><span class="p">.</span><span class="nx">setValue</span><span class="p">(</span><span class="nx">value</span><span class="p">{</span><span class="nx">bl</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="p">.</span><span class="nx">value</span><span class="p">.(</span><span class="kt">int64</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">y</span><span class="p">.</span><span class="nx">value</span><span class="p">.(</span><span class="kt">int64</span><span class="p">)})</span>
<span class="w">  </span><span class="k">default</span><span class="p">:</span>
<span class="w">    </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;Unknown binary expression type: %+v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">bexpr</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">interpretExpr</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">,</span><span class="w"> </span><span class="nx">expr</span><span class="w"> </span><span class="nx">ast</span><span class="p">.</span><span class="nx">Expr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="nx">e</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">expr</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">BinaryExpr</span><span class="p">:</span>
<span class="w">    </span><span class="nx">interpretBinaryExpr</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="nx">e</span><span class="p">)</span>

<span class="w">  </span><span class="o">...</span>
</pre></div>
<p>Let's try one more time!</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>go<span class="w"> </span>build<span class="w"> </span>goi.go
$<span class="w"> </span>./goi<span class="w"> </span>fib.go
<span class="m">2019</span>/10/12<span class="w"> </span><span class="m">11</span>:06:19<span class="w"> </span>Unknown<span class="w"> </span>stmt<span class="w"> </span><span class="nb">type</span><span class="w"> </span><span class="o">(</span>*ast.ReturnStmt<span class="o">)</span>:<span class="w"> </span><span class="p">&amp;</span><span class="o">{</span>Return:94<span class="w"> </span>Results:<span class="o">[</span>0xc000070540<span class="o">]}</span>
</pre></div>
<p>Awesome, last step.</p>
<h3 id="interpreting-ast.returnstmt">Interpreting ast.ReturnStmt</h3><p>Based on the
<a href="https://golang.org/pkg/go/ast/#ReturnStmt">ast.ReturnStmt</a> definition
we'll have to interpret each expression and set all of them to the
<code>ret</code> value.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">interpretReturnStmt</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">,</span><span class="w"> </span><span class="nx">s</span><span class="w"> </span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">ReturnStmt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">values</span><span class="w"> </span><span class="p">[]</span><span class="nx">value</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">expr</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">s</span><span class="p">.</span><span class="nx">Results</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="nx">ret</span>
<span class="w">    </span><span class="nx">interpretExpr</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="nx">expr</span><span class="p">)</span>
<span class="w">    </span><span class="nx">values</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">values</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nx">r</span><span class="p">.</span><span class="nx">setValues</span><span class="p">(</span><span class="nx">values</span><span class="p">)</span>

<span class="w">  </span><span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">interpretStmt</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">ret</span><span class="p">,</span><span class="w"> </span><span class="nx">stmt</span><span class="w"> </span><span class="nx">ast</span><span class="p">.</span><span class="nx">Stmt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">stmt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="nx">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">stmt</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">ReturnStmt</span><span class="p">:</span>
<span class="w">    </span><span class="nx">interpretReturnStmt</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="nx">s</span><span class="p">)</span>

<span class="w">  </span><span class="o">...</span>
</pre></div>
<p>And let's try one last time:</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>go<span class="w"> </span>build<span class="w"> </span>goi.go
$<span class="w"> </span>./goi<span class="w"> </span>fib.go
<span class="m">377</span>
</pre></div>
<p>Looking good. :) Let's try with another input:</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>cat<span class="w"> </span>fib.go
package<span class="w"> </span>main

func<span class="w"> </span>fib<span class="o">(</span>a<span class="w"> </span>int<span class="o">)</span><span class="w"> </span>int<span class="w"> </span><span class="o">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="o">}</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="o">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span>fib<span class="o">(</span>a-1<span class="o">)</span><span class="w"> </span>+<span class="w"> </span>fib<span class="o">(</span>a-2<span class="o">)</span>
<span class="o">}</span>

func<span class="w"> </span>main<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">  </span>println<span class="o">(</span>fib<span class="o">(</span><span class="m">14</span><span class="o">))</span>
<span class="o">}</span>
$<span class="w"> </span>./goi<span class="w"> </span>fib.go
<span class="m">233</span>
</pre></div>
<p>We've got the basics of an interpreter for Golang.</p>
<p><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr">Here&#39;s a blog post on building a simple AST interpreter for Go to support running a recursive fibonacci implementation <a href="https://t.co/5Zz388d8ZN">https://t.co/5Zz388d8ZN</a></p>&mdash; Phil Eaton (@phil_eaton) <a href="https://twitter.com/phil_eaton/status/1183039387170430976?ref_src=twsrc%5Etfw">October 12, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>
<style>.feedback{display:initial;}</style>
	</div>
	<div class="feedback">
	  <h4>Feedback</h4>
	  <p>As always,
	      please <a href="mailto:phil@eatonphil.com">email</a>
	      or <a href="https://twitter.com/eatonphil">tweet me</a>
	      with questions, corrections, or ideas!</p>

	</div>
      </div>
    </div>
    <footer>
      <div class="container">
	<div>
	  <div id="subscribe">
	    <iframe frameBorder="0" src="https://cdn.forms-content-1.sg-form.com/e8ed4c3b-dd46-11f0-b6e6-ce075f2c5f80"/>

	  </div>
	</div>
      </div>
    </footer>
    <script async onload="loadGA()" src="https://www.googletagmanager.com/gtag/js?id=UA-58109156-2"></script>
    <script>
      function loadGA() {
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());
	  gtag('config', 'UA-58109156-2');
      }
    </script>
    <script defer src="https://cdn.usefathom.com/script.js" data-site="CEPUOLOQ"></script>
  </body>
</html>
