# [DRAFT] Intercepting and modifying Linux system calls with ptrace
## October 1, 2023
###### linux,x86/amd64,databases,zig,fault-injection,draft

How software fails is incredibly interesting. But real-world errors
can be infrequent to manifest. "Fault injection" is a technique in
software development that explicitly triggers errors in the hopes of
discovering bad logic, typically during automated tests. Jepsen and
ChaosMonkey help to instigate process and network failure, but what
about disk and filesystem errors?

I've been thinking about how to instigate file IO errors in programs
and three solutions seem apparent: 1) a custom FUSE filesystem, 2) an
LD_PRELOAD interception layer or 3) a ptrace system call interception
layer.

<p class="note">
  From a cursory look, while eBPF seems great for tracing system
  calls, it doesn't seem to be able to much in terms of modifying the
  system call other
  than <a href="https://github.com/iovisor/bpftrace/discussions/2280">altering
  a return value</a> and even then only if the kernel has been
  configured with this ability on.
</p>

I would like to try out FUSE sometime. But LD_PRELOAD layer only works
if IO goes through libc, which won't be the case for all programs. And
ptrace is something I've wanted to hack on for years, going back to
when I worked for a Linux security company that alerted on suspicious
system call patterns.

So this particular post will cover intercepting system calls
(syscalls) using ptrace with code written in Zig (since I think Zig is
easier to both read and write than C).

By the end, we'll be able to intercept and force short (incomplete)
writes in a Go, Python, and C program. Emulating a disk that is having
an issue completing the write. This is a case that isn't common, but
should probably be handled with retries in production code.

This post corresponds roughly to [this
commit](https://github.com/eatonphil/badio/tree/720c3ee0482e6dcb1dd49d1789bccf86747b7776)
on GitHub.

### A bad program

To begin with, I wanted an example of an error I could try to trigger
and thus catch in a bad program.

For short writes this is easy, we just try to write some text to disk
but we don't make sure we've written the whole thing. This is
extremely common code; or at least I've written it often.

```go
package main

import (
        "os"
)

func main() {
        f, err := os.OpenFile("test.txt", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)
        if err != nil {
                panic(err)
        }

        text := "some great stuff"
        _, _ = f.Write([]byte(text))

        _ = f.Close()
}
```

Most importantly here, if the `Write()` call doesn't write everything,
we won't know that. And the file will contain less than all of `some
great stuff`.

This logical mistake will happen rarely, if ever, on a normal disk.

Now that we've got an example program in main, let's see if we can
trigger this error.

### ptrace

ptrace is a somewhat cross-platform layer that allows you to intercept
syscalls in a process and read and modify memory and registers in
the process when the syscalls starts and before it finishes.

gdb and strace both use ptrace for their magic.

Although ptrace is cross-platform, actually writing
cross-platform-aware code with ptrace can be complex. So this post
assumes amd64/linux.

On a slight tangent, [here's a fun Brendan Gregg
post](https://www.brendangregg.com/blog/2014-05-11/strace-wow-much-syscall.html)
on the dangers of using strace (that is based on ptrace) in
production.

### Protocol

The ptrace protocol is described in the [ptrace
manpage](https://man7.org/linux/man-pages/man2/ptrace.2.html), but
[Chris Wellons](https://nullprogram.com/blog/2018/06/23/) and [a
University of Alberta
group](https://webdocs.cs.ualberta.ca/~paullu/C498/meng.ptrace.slides.pdf)
also provide a slightly nicer visual introduction. I referenced these
three pages heavily.

Specifically, rather than me explain, just take a look at this slide
from the UAlberta page.

![ptrace's syscall tracing protocol](/assets/ptraceprotocol.webp)

We fork and have the child call `PTRACE_TRACEME`. Then we handle each
syscall entrance by calling `PTRACE_SYSCALL` and waiting with `wait`
until the child has entered the syscall. It is in this moment we can
start to mess with things.

### Implementation

Let's turn that graphic into Zig code.

```zig
const std = @import("std");
const c = @cImport({
    @cInclude("sys/ptrace.h");
    @cInclude("sys/user.h");
    @cInclude("sys/wait.h");
    @cInclude("errno.h");
});

const cNullPtr: ?*anyopaque = null;

// TODO //

pub fn main() !void {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();

    var args = try std.process.argsAlloc(arena.allocator());
    std.debug.assert(args.len >= 2);

    const pid = try std.os.fork();

    if (pid < 0) {
        std.debug.print("Fork failed!\n", .{});
        return;
    } else if (pid == 0) {
        // Child process
        _ = c.ptrace(c.PTRACE_TRACEME, pid, cNullPtr, cNullPtr);
        return std.process.execv(
            arena.allocator(),
            args[1..],
        );
    } else {
        // Parent process
        const childPid = pid;
        _ = c.waitpid(childPid, 0, 0);
        var cm = ChildManager{ .arena = &arena, .childPid = childPid };
        try cm.childInterceptSyscalls();
    }
}
```

So like the graphic suggested, we fork and start a child process. That
means this Zig program should be called like:

```
$ zig build-exe --library c main.zig
$ ./main /actual/program/to/intercept --and --its args
```

Presumably, as with strace or gdb, we could instead attach to an
already running process with `PTRACE_ATTACH` or `PTRACE_SEIZE` (based
on the [ptrace
manpage](https://man7.org/linux/man-pages/man2/ptrace.2.html)) rather
than going the `PTRACE_TRACEME` route. But I haven't tried that out
yet.

#### ChildManager

Anyway, with the child ready to be intercepted, we can implement the
`ChildManager` that actually does the interception.

The core of the `ChildManager` is an infinite loop (at least as long
as the child process lives) that waits for the next syscall and then
calls a hook for the sytem call if it exists.

```zig
const ChildManager = struct {
    arena: *std.heap.ArenaAllocator,
    childPid: std.os.pid_t,
    
    // TODO //
    
    fn childInterceptSyscalls(
        cm: *ChildManager,
    ) !void {
        while (true) {
            // Handle syscall entrance
            const status = cm.childWaitForSyscall();
            if (std.os.W.IFEXITED(status)) {
                break;
            }

            var args: ABIArguments = cm.getABIArguments();
            const syscall = args.syscall();

            for (hooks) |hook| {
                if (syscall == hook.syscall) {
                    try hook.hook(cm.*, &args);
                }
            }
        }
    }
};
```

We'll ultimately write a hook for the `sys_write` syscall that
will force an incomplete write.

Back to the protocol, `childWaitForSyscall` will call `PTRACE_SYSCALL`
to allow the child process to start up again and continue until the
next syscall. We'll follow that by `wait`-ing for the child
process to be stopped again so we can handle the syscall entrance.

```zig
    fn childWaitForSyscall(cm: ChildManager) u32 {
        var status: i32 = 0;
        _ = c.ptrace(c.PTRACE_SYSCALL, cm.childPid, cNullPtr, cNullPtr);
        _ = c.waitpid(cm.childPid, &status, 0);
        return @bitCast(status);
    }
```

Now that we've intercepted a syscall (after `waitpid` finishes
blocking), we need to figure out what syscall it was. We do this by
calling `PTRACE_GETREGS` and reading the `rax` register which
according to [amd64/linux calling
convention](https://stackoverflow.com/a/54957101/1507139) is the
syscall called.

#### Registers

`PTRACE_GETREGS` fills out the [following
struct](https://sites.uclouvain.be/SystInfo/usr/include/sys/user.h.html):

```c
struct user_regs_struct
{
  unsigned long r15;
  unsigned long r14;
  unsigned long r13;
  unsigned long r12;
  unsigned long rbp;
  unsigned long rbx;
  unsigned long r11;
  unsigned long r10;
  unsigned long r9;
  unsigned long r8;
  unsigned long rax;
  unsigned long rcx;
  unsigned long rdx;
  unsigned long rsi;
  unsigned long rdi;
  unsigned long orig_rax;
  unsigned long rip;
  unsigned long cs;
  unsigned long eflags;
  unsigned long rsp;
  unsigned long ss;
  unsigned long fs_base;
  unsigned long gs_base;
  unsigned long ds;
  unsigned long es;
  unsigned long fs;
  unsigned long gs;
};
```

Let's write a little amd64/linux-specific wrapper for accessing
meaningful fields.

```zig
const ABIArguments = struct {
    regs: c.user_regs_struct,

    fn nth(aa: ABIArguments, i: u8) c_ulong {
        std.debug.assert(i < 4);

        return switch (i) {
            0 => aa.regs.rdi,
            1 => aa.regs.rsi,
            2 => aa.regs.rdx,
            else => unreachable,
        };
    }

    fn setNth(aa: *ABIArguments, i: u8, value: c_ulong) void {
        std.debug.assert(i < 4);

        switch (i) {
            0 => { aa.regs.rdi = value; },
            1 => { aa.regs.rsi = value; },
            2 => { aa.regs.rdx = value; },
            else => unreachable,
        }
    }

    fn result(aa: ABIArguments) c_ulong { return aa.regs.rax; }

    fn setResult(aa: *ABIArguments, value: c_ulong) void {
        aa.regs.rax = value;
    }

    fn syscall(aa: ABIArguments) c_ulong { return aa.regs.orig_rax; }
};
```

One thing to note is that the field we read to get `rax` is not
`aa.regs.rax` but `aa.regs.orig_rax`. This is because `rax` is also
the return value and `PTRACE_SYSCALL` gets called twice for some
syscalls on entrance and exit. The `orig_rax` field preserves the
original `rax` value on syscall entrance. You can read more about this
[here](https://stackoverflow.com/questions/6468896/why-is-orig-eax-provided-in-addition-to-eax/6469069#6469069).

#### Getting and setting registers

And then let's write the `ChildManager` code that actually calls
`PTRACE_GETREGS` to fill out one of these structs.

```zig
    fn getABIArguments(cm: ChildManager) ABIArguments {
        var args = ABIArguments{ .regs = undefined };
        _ = c.ptrace(c.PTRACE_GETREGS, cm.childPid, cNullPtr, &args.regs);
        return args;
    }
```

Setting registers is similar, we just pass the struct back and call
`PTRACE_SETREGS` instead:

```zig
    fn setABIArguments(cm: ChildManager, args: *ABIArguments) void {
        _ = c.ptrace(c.PTRACE_SETREGS, cm.childPid, cNullPtr, &args.regs);
    }
```

#### A hook

Now we finally have enough code to write a hook that can get and set
registers; i.e. manipulate a system call!

We'll start by registering a `sys_write` hook in the `hooks` field we
check in `childInterceptSyscalls` above.

```zig
    const hooks = &[_]struct {
        syscall: c_ulong,
        hook: *const fn (ChildManager, *ABIArguments) anyerror!void,
    }{.{
        .syscall = @intFromEnum(std.os.linux.syscalls.X64.write),
        .hook = writeHandler,
    }};
```

If we look at the [manpage for
`write`](https://man7.org/linux/man-pages/man2/write.2.html) we see it
takes three arguments: 1) the file descriptor (fd) to write to, 2) the
address to start writing data from, and 3) the number of bytes to
write. Going back to the [calling
convention](https://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-and-user-space-f)
that means the fd will be in `rdi`, the data address in `rsi`, and the
data length in `rdx`.

So if we shorten the data length, we should be creating a short
(incomplete) write.

```zig
    fn writeHandler(cm: ChildManager, entryArgs: *ABIArguments) anyerror!void {
        const fd = entryArgs.nth(0);
        const dataAddress = entryArgs.nth(1);
        var dataLength = entryArgs.nth(2);

        // Truncate some bytes
        if (dataLength > 2) {
            dataLength -= 2;
            entryArgs.setNth(2, dataLength);
            cm.setABIArguments(entryArgs);
        }
    }
```

In a more sophisticated version of this program, we could randomly
decide when to truncate data and randomly decide how much data to
truncate. However, for our purposes this is sufficient.

But there's are some real problems with this code. I started off with
something like this and when I ran this program against a basic Go
program, I saw duplicate requests.

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Ah ok, PTRACE_SYSCALL gets hit when you both enter and exit a syscall.<br><br>So each time you call PTRACE_SYSCALL and you do stuff, you just call it again afterwards to handle/wait for the exit. <a href="https://t.co/PjmNwcMepG">pic.twitter.com/PjmNwcMepG</a></p>&mdash; Phil Eaton (@eatonphil) <a href="https://twitter.com/eatonphil/status/1707846783035183267?ref_src=twsrc%5Etfw">September 29, 2023</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

So the deal with `PTRACE_SYSCALL` is that for (most?) syscalls, you
get to modify data before the data actually is handled by the
kernel. And you get to modify data after the kernel has finished the
syscall too.

This makes sense because `PTRACE_SYSCALL` (unlike `PTRACE_SYSEMU`)
still allows the syscall to actually happen. And if we wanted to, for
example, modify the syscall exit code, we'd have to do that after the
syscall was done not before it started. We are modifying registers
directly after all.

All this means for our Zig code is that when we handle `sys_write`, we
need to call `PTRACE_SYSCALL` again to process the syscall
exit. Otherwise we'd reach this `writeHandler` for both entries and
exists, which would require some additional way of disambiguating
entrances from exits.

```zig
    fn writeHandler(cm: ChildManager, entryArgs: *ABIArguments) anyerror!void {
        const fd = entryArgs.nth(0);
        const dataAddress = entryArgs.nth(1);
        var dataLength = entryArgs.nth(2);

        // Truncate some bytes
        if (dataLength > 2) {
            dataLength -= 2;
            entryArgs.setNth(2, dataLength);
            cm.setABIArguments(entryArgs);
        }

        const data = try cm.childReadData(dataAddress, dataLength);
        defer data.deinit();
        std.debug.print("Got a write on {}: {s}\n", .{ fd, data.items });

        // Handle syscall exit
        _ = cm.childWaitForSyscall();
    }
```

<p class="note">
  We could put the <code>cm.childWaitForSyscall()</code> waiting for
  the syscall exit in the main loop and I did try that at
  first. However, not all syscalls seemed to have the same entry and
  exit hook and this resulted in the hooks sometimes starting with a
  syscall exit rather than a syscall entry. So rather than making the
  code more complicated, I decided to only wait for the exit on
  syscalls I knew had an exit (by observation at least), like
  <code>sys_write</code>.
</p>

### Multiple writes? No bad logic?

So I had this code as is, correctly handling syscall entrances and
exits, but I was seeing multiple write calls. And the text file I was
writing to had the complete text I wanted to write. There was no short
write even though I truncated the data length.

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Ok so what happens in this Go program if I truncate the amount of data?<br><br>I assumed Go would do nothing since all I did was call `f.Write()` once and `f.Write()` returns a number of bytes written.<br><br>But actually, it still writes everything! <a href="https://t.co/OSalKEbERM">pic.twitter.com/OSalKEbERM</a></p>&mdash; Phil Eaton (@eatonphil) <a href="https://twitter.com/eatonphil/status/1707854642250408119?ref_src=twsrc%5Etfw">September 29, 2023</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

This took some digging into Go source code to understand. If you trace
what `os.File.Write()` does on Linux you eventually get to
[src/internal/poll/fd_unix.go](https://cs.opensource.google/go/go/+/refs/tags/go1.21.1:src/internal/poll/fd_unix.go):

```go
// Write implements io.Writer.
func (fd *FD) Write(p []byte) (int, error) {
        if err := fd.writeLock(); err != nil {
                return 0, err
        }
        defer fd.writeUnlock()
        if err := fd.pd.prepareWrite(fd.isFile); err != nil {
                return 0, err
        }
        var nn int
        for {
                max := len(p)
                if fd.IsStream && max-nn > maxRW {
                        max = nn + maxRW
                }
                n, err := ignoringEINTRIO(syscall.Write, fd.Sysfd, p[nn:max])
                if n > 0 {
                        nn += n
                }
                if nn == len(p) {
                        return nn, err
                }
                if err == syscall.EAGAIN && fd.pd.pollable() {
                        if err = fd.pd.waitWrite(fd.isFile); err == nil {
                                continue
                        }
                }
                if err != nil {
                        return nn, err
                }
                if n == 0 {
                        return nn, io.ErrUnexpectedEOF
                }
        }
}
```

Credits: Thanks Charlie Cummings for reviewing a draft of this post!
